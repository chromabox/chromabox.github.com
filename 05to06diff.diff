diff -rupN kernel/drivers/media/video/samsung/mhl_v1/Common_Def.h news/kernel/drivers/media/video/samsung/mhl_v1/Common_Def.h
--- kernel/drivers/media/video/samsung/mhl_v1/Common_Def.h	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/Common_Def.h	2011-06-17 19:41:22.000000000 +0900
@@ -1,217 +1,236 @@
-/*===========================================================================
-
-                       Common_Def.h
-              
-
-DESCRIPTION
-  
-
- Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             
-  No part of this work may be reproduced, modified, distributed, transmitted,    
- transcribed, or translated into any language or computer format, in any form   
-or by any means without written permission of: Silicon Image, Inc.,            
-1060 East Arques Avenue, Sunnyvale, California 94085                           
-===========================================================================*/
-#ifndef Common_Def_H
-#define Common_Def_H
-
-#include <linux/types.h>
-#include <linux/i2c.h>
-
-
-typedef u8 byte;
-typedef u32 word;
-typedef bool Bool;
-
-
-#define RCP_ENABLE 	1
-#define MSC_TESTER	0
-
-#define IS_CBUS 1  
-#define MHD_MAX_CHANNELS  1   // Number of MDHI channels
-
-// Generic Constants
-//==================
-#define FALSE                   0
-#define TRUE                    1
-
-#define OFF                     0
-#define ON                      1
-
-#define LOW                     0
-#define HIGH                    1
-
-// Generic Masks
-//==============
-#define LOW_BYTE                0x00FF
-
-#define LOW_NIBBLE              0x0F
-#define HI_NIBBLE               0xF0
-
-#define MSBIT                   0x80
-#define LSBIT                   0x01
-
-#define _ZERO					0x00
-
-#define BIT_0                   0x01
-#define BIT_1                   0x02
-#define BIT_2                   0x04
-#define BIT_3                   0x08
-#define BIT_4                   0x10
-#define BIT_5                   0x20
-#define BIT_6                   0x40
-#define BIT_7                   0x80
-
-
-
-struct i2c_client* get_sii9234_client(u8 device_id);
-u8 sii9234_i2c_read(struct i2c_client *client, u8 reg);
-int sii9234_i2c_write(struct i2c_client *client, u8 reg, u8 data);
-extern void sii9234_interrupt_event(void);
-
-extern void sii9234_cfg_power(bool on);
-extern void MHL_On(bool on);
-extern byte ReadByteTPI (byte Offset);
-Bool SiI9234_startTPI(void);
-
-// Device Power State
-#define MHL_DEV_UNPOWERED		0x00
-#define MHL_DEV_INACTIVE		0x01
-#define MHL_DEV_QUIET			0x03
-#define MHL_DEV_ACTIVE			0x04
-
-// Version that this chip supports
-#define	MHL_VER_MAJOR		(0x01 << 4)	// bits 4..7
-#define	MHL_VER_MINOR		0x00		// bits 0..3
-#define MHL_VERSION						(MHL_VER_MAJOR | MHL_VER_MINOR)
-
-//Device Category
-#define	MHL_DEV_CATEGORY_OFFSET				0x02
-#define	MHL_DEV_CATEGORY_POW_BIT			(BIT_4)
-
-#define	MHL_DEV_CAT_SOURCE					0x00
-#define	MHL_DEV_CAT_SINGLE_INPUT_SINK		0x01
-#define	MHL_DEV_CAT_MULTIPLE_INPUT_SINK		0x02
-#define	MHL_DEV_CAT_UNPOWERED_DONGLE		0x03
-#define	MHL_DEV_CAT_SELF_POWERED_DONGLE		0x04
-#define	MHL_DEV_CAT_HDCP_REPEATER			0x05
-#define	MHL_DEV_CAT_NON_DISPLAY_SINK		0x06
-#define	MHL_DEV_CAT_POWER_NEUTRAL_SINK		0x07
-#define	MHL_DEV_CAT_OTHER					0x80
-
-//Video Link Mode
-#define	MHL_DEV_VID_LINK_SUPPRGB444			0x01
-#define	MHL_DEV_VID_LINK_SUPPYCBCR444		0x02
-#define	MHL_DEV_VID_LINK_SUPPYCBCR422		0x04
-#define	MHL_DEV_VID_LINK_PPIXEL				0x08
-#define	MHL_DEV_VID_LINK_SUPP_ISLANDS		0x10
-
-//Audio Link Mode Support
-#define	MHL_DEV_AUD_LINK_2CH				0x01
-#define	MHL_DEV_AUD_LINK_8CH				0x02
-
-
-//Feature Flag in the devcap
-#define	MHL_DEV_FEATURE_FLAG_OFFSET			0x0A
-#define	MHL_FEATURE_RCP_SUPPORT				BIT_0	// Dongles have freedom to not support RCP
-#define	MHL_FEATURE_RAP_SUPPORT				BIT_1	// Dongles have freedom to not support RAP
-#define	MHL_FEATURE_SP_SUPPORT				BIT_2	// Dongles have freedom to not support SCRATCHPAD
-
-/*
-#define		MHL_POWER_SUPPLY_CAPACITY		16		// 160 mA current
-#define		MHL_POWER_SUPPLY_PROVIDED		16		// 160mA 0r 0 for Wolverine.
-#define		MHL_HDCP_STATUS					0		// Bits set dynamically
-*/
-
-// VIDEO TYPES
-#define		MHL_VT_GRAPHICS					0x00		
-#define		MHL_VT_PHOTO					0x02		
-#define		MHL_VT_CINEMA					0x04		
-#define		MHL_VT_GAMES					0x08		
-#define		MHL_SUPP_VT						0x80		
-
-//Logical Dev Map
-#define	MHL_DEV_LD_DISPLAY					(0x01 << 0)
-#define	MHL_DEV_LD_VIDEO					(0x01 << 1)
-#define	MHL_DEV_LD_AUDIO					(0x01 << 2)
-#define	MHL_DEV_LD_MEDIA					(0x01 << 3)
-#define	MHL_DEV_LD_TUNER					(0x01 << 4)
-#define	MHL_DEV_LD_RECORD					(0x01 << 5)
-#define	MHL_DEV_LD_SPEAKER					(0x01 << 6)
-#define	MHL_DEV_LD_GUI						(0x01 << 7)
-
-//Bandwidth
-#define	MHL_BANDWIDTH_LIMIT					22		// 225 MHz
-
-
-#define	MHL_STATUS_DCAP_RDY					BIT_0
-#define	MHL_INT_DCAP_CHG					BIT_0
-
-// On INTR_1 the EDID_CHG is located at BIT 0
-#define	MHL_INT_EDID_CHG					BIT_1
-
-#define		MHL_INT_AND_STATUS_SIZE			0x303		// This contains one nibble each - max offset
-#define		MHL_SCRATCHPAD_SIZE				16
-#define		MHL_MAX_BUFFER_SIZE				MHL_SCRATCHPAD_SIZE	// manually define highest number
-
-
-
-enum
-{
-    MHL_MSC_MSG_RCP             = 0x10,     // RCP sub-command
-    MHL_MSC_MSG_RCPK            = 0x11,     // RCP Acknowledge sub-command
-    MHL_MSC_MSG_RCPE            = 0x12,     // RCP Error sub-command
-    MHL_MSC_MSG_RAP             = 0x20,     // Mode Change Warning sub-command
-    MHL_MSC_MSG_RAPK            = 0x21     // MCW Acknowledge sub-command
-};
-
-//
-// MHL spec related defines
-//
-enum
-{
-	MHL_ACK						= 0x33,	// Command or Data byte acknowledge
-	MHL_NACK					= 0x34,	// Command or Data byte not acknowledge
-	MHL_ABORT					= 0x35,	// Transaction abort
-	MHL_WRITE_STAT				= 0x60 | 0x80,	// Write one status register strip top bit
-	MHL_SET_INT					= 0x60,	// Write one interrupt register
-	MHL_READ_DEVCAP				= 0x61,	// Read one register
-	MHL_GET_STATE				= 0x62,	// Read CBUS revision level from follower
-	MHL_GET_VENDOR_ID			= 0x63,	// Read vendor ID value from follower.
-	MHL_SET_HPD					= 0x64,	// Set Hot Plug Detect in follower
-	MHL_CLR_HPD					= 0x65,	// Clear Hot Plug Detect in follower
-	MHL_SET_CAP_ID				= 0x66,	// Set Capture ID for downstream device.
-	MHL_GET_CAP_ID				= 0x67,	// Get Capture ID from downstream device.
-	MHL_MSC_MSG					= 0x68,	// VS command to send RCP sub-commands
-	MHL_GET_SC1_ERRORCODE		= 0x69,	// Get Vendor-Specific command error code.
-	MHL_GET_DDC_ERRORCODE		= 0x6A,	// Get DDC channel command error code.
-	MHL_GET_MSC_ERRORCODE		= 0x6B,	// Get MSC command error code.
-	MHL_WRITE_BURST				= 0x6C,	// Write 1-16 bytes to responder’s scratchpad.
-	MHL_GET_SC3_ERRORCODE		= 0x6D	// Get channel 3 command error code.
-};
-
-#define	MHL_RAP_CONTENT_ON		0x10	// Turn content streaming ON.
-#define	MHL_RAP_CONTENT_OFF		0x11	// Turn content streaming OFF.
-
-///////////////////////////////////////////////////////////////////////////////
-//
-// MHL Timings applicable to this driver.
-//
-//
-#define	T_SRC_VBUS_CBUS_TO_STABLE	(200)	// 100 - 1000 milliseconds. Per MHL 1.0 Specs
-#define	T_SRC_WAKE_PULSE_WIDTH_1	(20)	// 20 milliseconds. Per MHL 1.0 Specs
-#define	T_SRC_WAKE_PULSE_WIDTH_2	(60)	// 60 milliseconds. Per MHL 1.0 Specs
-
-#define	T_SRC_WAKE_TO_DISCOVER		(500)	// 100 - 1000 milliseconds. Per MHL 1.0 Specs
-
-#define T_SRC_VBUS_CBUS_T0_STABLE 	(500)
-
-// Allow RSEN to stay low this much before reacting.
-// Per specs between 100 to 200 ms
-#define	T_SRC_RSEN_DEGLITCH			(150)
-
-// Wait this much after connection before reacting to RSEN (300-500ms)
-// Per specs between 300 to 500 ms
-#define	T_SRC_RXSENSE_CHK			(400)
-
-#endif
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed ¡°as is¡± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+#ifndef Common_Def_H
+#define Common_Def_H
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+
+typedef u8 byte;
+typedef u32 word;
+typedef bool Bool;
+
+
+#define RCP_ENABLE 	1
+#define MSC_TESTER	0
+
+#define IS_CBUS 1  
+#define MHD_MAX_CHANNELS  1   // Number of MDHI channels
+
+// Generic Constants
+//==================
+#define FALSE                   0
+#define TRUE                    1
+
+#define OFF                     0
+#define ON                      1
+
+#define LOW                     0
+#define HIGH                    1
+
+// Generic Masks
+//==============
+#define LOW_BYTE                0x00FF
+
+#define LOW_NIBBLE              0x0F
+#define HI_NIBBLE               0xF0
+
+#define MSBIT                   0x80
+#define LSBIT                   0x01
+
+#define _ZERO					0x00
+
+#define BIT_0                   0x01
+#define BIT_1                   0x02
+#define BIT_2                   0x04
+#define BIT_3                   0x08
+#define BIT_4                   0x10
+#define BIT_5                   0x20
+#define BIT_6                   0x40
+#define BIT_7                   0x80
+
+
+
+struct i2c_client* get_sii9234_client(u8 device_id);
+u8 sii9234_i2c_read(struct i2c_client *client, u8 reg);
+int sii9234_i2c_write(struct i2c_client *client, u8 reg, u8 data);
+extern void sii9234_interrupt_event(void);
+
+extern void sii9234_cfg_power(bool on);
+extern void MHL_On(bool on);
+extern byte ReadByteTPI (byte Offset);
+Bool SiI9234_startTPI(void);
+
+// Device Power State
+#define MHL_DEV_UNPOWERED		0x00
+#define MHL_DEV_INACTIVE		0x01
+#define MHL_DEV_QUIET			0x03
+#define MHL_DEV_ACTIVE			0x04
+
+// Version that this chip supports
+#define	MHL_VER_MAJOR		(0x01 << 4)	// bits 4..7
+#define	MHL_VER_MINOR		0x00		// bits 0..3
+#define MHL_VERSION						(MHL_VER_MAJOR | MHL_VER_MINOR)
+
+//Device Category
+#define	MHL_DEV_CATEGORY_OFFSET				0x02
+#define	MHL_DEV_CATEGORY_POW_BIT			(BIT_4)
+
+#define	MHL_DEV_CAT_SOURCE					0x00
+#define	MHL_DEV_CAT_SINGLE_INPUT_SINK		0x01
+#define	MHL_DEV_CAT_MULTIPLE_INPUT_SINK		0x02
+#define	MHL_DEV_CAT_UNPOWERED_DONGLE		0x03
+#define	MHL_DEV_CAT_SELF_POWERED_DONGLE		0x04
+#define	MHL_DEV_CAT_HDCP_REPEATER			0x05
+#define	MHL_DEV_CAT_NON_DISPLAY_SINK		0x06
+#define	MHL_DEV_CAT_POWER_NEUTRAL_SINK		0x07
+#define	MHL_DEV_CAT_OTHER					0x80
+
+//Video Link Mode
+#define	MHL_DEV_VID_LINK_SUPPRGB444			0x01
+#define	MHL_DEV_VID_LINK_SUPPYCBCR444		0x02
+#define	MHL_DEV_VID_LINK_SUPPYCBCR422		0x04
+#define	MHL_DEV_VID_LINK_PPIXEL				0x08
+#define	MHL_DEV_VID_LINK_SUPP_ISLANDS		0x10
+
+//Audio Link Mode Support
+#define	MHL_DEV_AUD_LINK_2CH				0x01
+#define	MHL_DEV_AUD_LINK_8CH				0x02
+
+
+//Feature Flag in the devcap
+#define	MHL_DEV_FEATURE_FLAG_OFFSET			0x0A
+#define	MHL_FEATURE_RCP_SUPPORT				BIT_0	// Dongles have freedom to not support RCP
+#define	MHL_FEATURE_RAP_SUPPORT				BIT_1	// Dongles have freedom to not support RAP
+#define	MHL_FEATURE_SP_SUPPORT				BIT_2	// Dongles have freedom to not support SCRATCHPAD
+
+/*
+#define		MHL_POWER_SUPPLY_CAPACITY		16		// 160 mA current
+#define		MHL_POWER_SUPPLY_PROVIDED		16		// 160mA 0r 0 for Wolverine.
+#define		MHL_HDCP_STATUS					0		// Bits set dynamically
+*/
+
+// VIDEO TYPES
+#define		MHL_VT_GRAPHICS					0x00		
+#define		MHL_VT_PHOTO					0x02		
+#define		MHL_VT_CINEMA					0x04		
+#define		MHL_VT_GAMES					0x08		
+#define		MHL_SUPP_VT						0x80		
+
+//Logical Dev Map
+#define	MHL_DEV_LD_DISPLAY					(0x01 << 0)
+#define	MHL_DEV_LD_VIDEO					(0x01 << 1)
+#define	MHL_DEV_LD_AUDIO					(0x01 << 2)
+#define	MHL_DEV_LD_MEDIA					(0x01 << 3)
+#define	MHL_DEV_LD_TUNER					(0x01 << 4)
+#define	MHL_DEV_LD_RECORD					(0x01 << 5)
+#define	MHL_DEV_LD_SPEAKER					(0x01 << 6)
+#define	MHL_DEV_LD_GUI						(0x01 << 7)
+
+//Bandwidth
+#define	MHL_BANDWIDTH_LIMIT					22		// 225 MHz
+
+
+#define	MHL_STATUS_DCAP_RDY					BIT_0
+#define	MHL_INT_DCAP_CHG					BIT_0
+
+// On INTR_1 the EDID_CHG is located at BIT 0
+#define	MHL_INT_EDID_CHG					BIT_1
+
+#define		MHL_INT_AND_STATUS_SIZE			0x303		// This contains one nibble each - max offset
+#define		MHL_SCRATCHPAD_SIZE				16
+#define		MHL_MAX_BUFFER_SIZE				MHL_SCRATCHPAD_SIZE	// manually define highest number
+
+
+
+enum
+{
+    MHL_MSC_MSG_RCP             = 0x10,     // RCP sub-command
+    MHL_MSC_MSG_RCPK            = 0x11,     // RCP Acknowledge sub-command
+    MHL_MSC_MSG_RCPE            = 0x12,     // RCP Error sub-command
+    MHL_MSC_MSG_RAP             = 0x20,     // Mode Change Warning sub-command
+    MHL_MSC_MSG_RAPK            = 0x21     // MCW Acknowledge sub-command
+};
+
+//
+// MHL spec related defines
+//
+enum
+{
+	MHL_ACK						= 0x33,	// Command or Data byte acknowledge
+	MHL_NACK					= 0x34,	// Command or Data byte not acknowledge
+	MHL_ABORT					= 0x35,	// Transaction abort
+	MHL_WRITE_STAT				= 0x60 | 0x80,	// Write one status register strip top bit
+	MHL_SET_INT					= 0x60,	// Write one interrupt register
+	MHL_READ_DEVCAP				= 0x61,	// Read one register
+	MHL_GET_STATE				= 0x62,	// Read CBUS revision level from follower
+	MHL_GET_VENDOR_ID			= 0x63,	// Read vendor ID value from follower.
+	MHL_SET_HPD					= 0x64,	// Set Hot Plug Detect in follower
+	MHL_CLR_HPD					= 0x65,	// Clear Hot Plug Detect in follower
+	MHL_SET_CAP_ID				= 0x66,	// Set Capture ID for downstream device.
+	MHL_GET_CAP_ID				= 0x67,	// Get Capture ID from downstream device.
+	MHL_MSC_MSG					= 0x68,	// VS command to send RCP sub-commands
+	MHL_GET_SC1_ERRORCODE		= 0x69,	// Get Vendor-Specific command error code.
+	MHL_GET_DDC_ERRORCODE		= 0x6A,	// Get DDC channel command error code.
+	MHL_GET_MSC_ERRORCODE		= 0x6B,	// Get MSC command error code.
+	MHL_WRITE_BURST				= 0x6C,	// Write 1-16 bytes to responder’s scratchpad.
+	MHL_GET_SC3_ERRORCODE		= 0x6D	// Get channel 3 command error code.
+};
+
+#define	MHL_RAP_CONTENT_ON		0x10	// Turn content streaming ON.
+#define	MHL_RAP_CONTENT_OFF		0x11	// Turn content streaming OFF.
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// MHL Timings applicable to this driver.
+//
+//
+#define	T_SRC_VBUS_CBUS_TO_STABLE	(200)	// 100 - 1000 milliseconds. Per MHL 1.0 Specs
+#define	T_SRC_WAKE_PULSE_WIDTH_1	(20)	// 20 milliseconds. Per MHL 1.0 Specs
+#define	T_SRC_WAKE_PULSE_WIDTH_2	(60)	// 60 milliseconds. Per MHL 1.0 Specs
+
+#define	T_SRC_WAKE_TO_DISCOVER		(500)	// 100 - 1000 milliseconds. Per MHL 1.0 Specs
+
+#define T_SRC_VBUS_CBUS_T0_STABLE 	(500)
+
+// Allow RSEN to stay low this much before reacting.
+// Per specs between 100 to 200 ms
+#define	T_SRC_RSEN_DEGLITCH			(150)
+
+// Wait this much after connection before reacting to RSEN (300-500ms)
+// Per specs between 300 to 500 ms
+#define	T_SRC_RXSENSE_CHK			(400)
+
+#endif
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/Kconfig news/kernel/drivers/media/video/samsung/mhl_v1/Kconfig
--- kernel/drivers/media/video/samsung/mhl_v1/Kconfig	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/Kconfig	2011-06-17 19:41:22.000000000 +0900
@@ -1,13 +1,13 @@
-#
-# Copyright (c) 2010 Samsung Electronics Co., Ltd.
-# 		http://www.samsung.com/
-# Aakash Manik
-#	aakash.manik@samsung.com
-# Licensed under GPLv2
-
-config VIDEO_MHL_V1
-	bool "Samsung Mobile HD Link Interface"
-#	depends on VIDEO_SAMSUNG
-	default n
-	help
-	  This is a MHL v1 driver for Samsung S5PV210.
+#
+# Copyright (c) 2010 Samsung Electronics Co., Ltd.
+# 		http://www.samsung.com/
+# Aakash Manik
+#	aakash.manik@samsung.com
+# Licensed under GPLv2
+
+config VIDEO_MHL_V1
+	bool "Samsung Mobile HD Link Interface"
+#	depends on VIDEO_SAMSUNG
+	default n
+	help
+	  This is a MHL v1 driver for Samsung S5PV210.
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/Makefile news/kernel/drivers/media/video/samsung/mhl_v1/Makefile
--- kernel/drivers/media/video/samsung/mhl_v1/Makefile	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/Makefile	2011-06-17 19:41:22.000000000 +0900
@@ -1,16 +1,16 @@
-# drivers/media/video/samsung/mhl_v1/Makefile
-#
-# Copyright (c) 2010 Samsung Electronics Co., Ltd.
-# 		http://www.samsung.com/
-# Aakash Manik
-#	aakash.manik@samsung.com
-# Licensed under GPLv2
-
-
-obj-$(CONFIG_VIDEO_MHL_V1) += sii9234.o \
-				si_RegioCbus.o \
-				SiI9234_I2C_master.o \
-				sii9234_driver.o \
-				si_apiCbus.o \
-				si_cpCbus.o 
-
+# drivers/media/video/samsung/mhl_v1/Makefile
+#
+# Copyright (c) 2010 Samsung Electronics Co., Ltd.
+# 		http://www.samsung.com/
+# Aakash Manik
+#	aakash.manik@samsung.com
+# Licensed under GPLv2
+
+
+obj-$(CONFIG_VIDEO_MHL_V1) += sii9234.o \
+				si_RegioCbus.o \
+				SiI9234_I2C_master.o \
+				sii9234_driver.o \
+				si_apiCbus.o \
+				si_cpCbus.o 
+
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/SiI9234_I2C_master.c news/kernel/drivers/media/video/samsung/mhl_v1/SiI9234_I2C_master.c
--- kernel/drivers/media/video/samsung/mhl_v1/SiI9234_I2C_master.c	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/SiI9234_I2C_master.c	2011-06-17 19:41:22.000000000 +0900
@@ -1,254 +1,262 @@
-/*===========================================================================
-
-                        SiI9024A I2C MASTER.C
-              
-
-DESCRIPTION
-  This file explains the SiI9024A initialization and call the virtual main function.
-  
-
- Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             
-  No part of this work may be reproduced, modified, distributed, transmitted,    
- transcribed, or translated into any language or computer format, in any form   
-or by any means without written permission of: Silicon Image, Inc.,            
-1060 East Arques Avenue, Sunnyvale, California 94085                           
-===========================================================================*/
-
-/*===========================================================================
-
-                      EDIT HISTORY FOR FILE
-
-when              who                         what, where, why
---------        ---                        ----------------------------------------------------------
-2010/10/25    Daniel Lee(Philju)      Initial version of file, SIMG Korea 
-===========================================================================*/
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/i2c.h>
-#include <linux/gpio.h>
-#include <plat/pm.h>
-#include <asm/irq.h>
-#include <linux/delay.h>
-#include <plat/gpio-cfg.h>
-#include <mach/regs-gpio.h>
-#include <mach/regs-clock.h>
-
-#include <linux/syscalls.h> 
-#include <linux/fcntl.h> 
-#include <asm/uaccess.h> 
-#include <linux/types.h>
-
-
-#include "Common_Def.h"
-#include "SiI9234_I2C_slave_add.h"
-
-
-/*===========================================================================
-
-===========================================================================*/
-
-#define READ   1
-#define WRITE  0
-
-#define LAST_BYTE      1
-#define NOT_LAST_BYTE  0
-
-
-#define TPI_INDEXED_PAGE_REG		0xBC
-#define TPI_INDEXED_OFFSET_REG		0xBD
-#define TPI_INDEXED_VALUE_REG		0xBE
-
-
-/*===========================================================================
-
-===========================================================================*/
-//------------------------------------------------------------------------------
-// Function: I2C_WriteByte
-// Description:
-//------------------------------------------------------------------------------
-void I2C_WriteByte(byte deviceID, byte offset, byte value)
-{
-
-	struct i2c_client* client_ptr = get_sii9234_client(deviceID);
-	if(!client_ptr)
-	{
-		printk("[MHL]I2C_WriteByte error %x\n",deviceID); 
-		return;	
-	}
-	
-	if(deviceID == 0x72)
-		sii9234_i2c_write(client_ptr,offset,value);
-	else if(deviceID == 0x7A)
-		sii9234_i2c_write(client_ptr,offset,value);
-	else if(deviceID == 0x92)
-		sii9234_i2c_write(client_ptr,offset,value);
-	else if(deviceID == 0xC8)
-		sii9234_i2c_write(client_ptr,offset,value);
-
-
-}
-
-
-byte I2C_ReadByte(byte deviceID, byte offset)
-{
-    	byte number = 0;
-	struct i2c_client* client_ptr = get_sii9234_client(deviceID);
-	if(!client_ptr)
-	{
-		printk("[MHL]I2C_ReadByte error %x\n",deviceID); 
-		return 0;	
-	}
-
-  
-  	if(deviceID == 0x72)
-		number = sii9234_i2c_read(client_ptr,offset);
-	else if(deviceID == 0x7A)
-		number = sii9234_i2c_read(client_ptr,offset);
-	else if(deviceID == 0x92)
-		number = sii9234_i2c_read(client_ptr,offset);
-	else if(deviceID == 0xC8)
-		number = sii9234_i2c_read(client_ptr,offset);
-	
-    return (number);
-
-}
-
-byte ReadByteTPI (byte Offset) 
-{
-	return I2C_ReadByte(SA_TX_Page0_Primary, Offset);
-}
-
-void WriteByteTPI (byte Offset, byte Data) 
-{
-	I2C_WriteByte(SA_TX_Page0_Primary, Offset, Data);
-}
-
-
-
-void ReadModifyWriteTPI(byte Offset, byte Mask, byte Data) 
-{
-
-	byte Temp;
-
-	Temp = ReadByteTPI(Offset);		// Read the current value of the register.
-	Temp &= ~Mask;					// Clear the bits that are set in Mask.
-	Temp |= (Data & Mask);			// OR in new value. Apply Mask to Value for safety.
-	WriteByteTPI(Offset, Temp);		// Write new value back to register.
-}
-
-byte ReadByteCBUS (byte Offset) 
-{
-	return I2C_ReadByte(SA_TX_CBUS_Primary, Offset);
-}
-
-void WriteByteCBUS(byte Offset, byte Data) 
-{
-	I2C_WriteByte(SA_TX_CBUS_Primary, Offset, Data);
-}
-
-void ReadModifyWriteCBUS(byte Offset, byte Mask, byte Value) 
-{
-  byte Temp;
-
-  Temp = ReadByteCBUS(Offset);
-  Temp &= ~Mask;
-  Temp |= (Value & Mask);
-  WriteByteCBUS(Offset, Temp);
-}
-
-
-//////////////////////////////////////////////////////////////////////////////
-//
-// FUNCTION		:	ReadIndexedRegister ()
-//
-// PURPOSE		:	Read the value from an indexed register.
-//
-//					Write:
-//						1. 0xBC => Indexed page num
-//						2. 0xBD => Indexed register offset
-//
-//					Read:
-//						3. 0xBE => Returns the indexed register value
-//
-// INPUT PARAMS	:	PageNum	-	indexed page number
-//					Offset	-	offset of the register within the indexed page.
-//
-// OUTPUT PARAMS:	None
-//
-// GLOBALS USED	:	None
-//
-// RETURNS		:	The value read from the indexed register.
-//
-//////////////////////////////////////////////////////////////////////////////
-
-byte ReadIndexedRegister (byte PageNum, byte Offset) 
-{
-	WriteByteTPI(TPI_INDEXED_PAGE_REG, PageNum);		// Indexed page
-	WriteByteTPI(TPI_INDEXED_OFFSET_REG, Offset);		// Indexed register
-	return ReadByteTPI(TPI_INDEXED_VALUE_REG);			// Return read value
-}
-
-
-//////////////////////////////////////////////////////////////////////////////
-//
-// FUNCTION		:	WriteIndexedRegister ()
-//
-// PURPOSE		:	Write a value to an indexed register
-//
-//					Write:
-//						1. 0xBC => Indexed page num
-//						2. 0xBD => Indexed register offset
-//						3. 0xBE => Set the indexed register value
-//
-// INPUT PARAMS	:	PageNum	-	indexed page number
-//					Offset	-	offset of the register within the indexed page.
-//					Data	-	the value to be written.
-//
-// OUTPUT PARAMS:	None
-//
-// GLOBALS USED :	None
-//
-// RETURNS		:	None
-//
-//////////////////////////////////////////////////////////////////////////////
-
-void WriteIndexedRegister (byte PageNum, byte Offset, byte Data) 
-{
-	WriteByteTPI(TPI_INDEXED_PAGE_REG, PageNum);		// Indexed page
-	WriteByteTPI(TPI_INDEXED_OFFSET_REG, Offset);		// Indexed register
-	WriteByteTPI(TPI_INDEXED_VALUE_REG, Data);			// Write value
-}
-
-
-//////////////////////////////////////////////////////////////////////////////
-//
-// FUNCTION		:	ReadModifyWriteIndexedRegister ()
-//
-// PURPOSE		:	Set or clear individual bits in a TPI register.
-//
-// INPUT PARAMS	:	PageNum	-	indexed page number
-//					Offset	-	the offset of the indexed register to be modified.
-//					Mask	-	"1" for each indexed register bit that needs to be
-//								modified
-//					Data	-	The desired value for the register bits in their
-//								proper positions
-//
-// OUTPUT PARAMS:	None
-//
-// GLOBALS USED	:	None
-//
-// RETURNS		:	void
-//
-//////////////////////////////////////////////////////////////////////////////
-
-void ReadModifyWriteIndexedRegister (byte PageNum, byte Offset, byte Mask, byte Data) 
-{
-
-	byte Temp;
-
-	Temp = ReadIndexedRegister (PageNum, Offset);	// Read the current value of the register.
-	Temp &= ~Mask;									// Clear the bits that are set in Mask.
-	Temp |= (Data & Mask);							// OR in new value. Apply Mask to Value for safety.
-	WriteByteTPI(TPI_INDEXED_VALUE_REG, Temp);		// Write new value back to register.
-}
-
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <plat/pm.h>
+#include <asm/irq.h>
+#include <linux/delay.h>
+#include <plat/gpio-cfg.h>
+#include <mach/regs-gpio.h>
+#include <mach/regs-clock.h>
+
+#include <linux/syscalls.h> 
+#include <linux/fcntl.h> 
+#include <asm/uaccess.h> 
+#include <linux/types.h>
+
+
+#include "Common_Def.h"
+#include "SiI9234_I2C_slave_add.h"
+
+
+/*===========================================================================
+
+===========================================================================*/
+
+#define READ   1
+#define WRITE  0
+
+#define LAST_BYTE      1
+#define NOT_LAST_BYTE  0
+
+
+#define TPI_INDEXED_PAGE_REG		0xBC
+#define TPI_INDEXED_OFFSET_REG		0xBD
+#define TPI_INDEXED_VALUE_REG		0xBE
+
+
+/*===========================================================================
+
+===========================================================================*/
+//------------------------------------------------------------------------------
+// Function: I2C_WriteByte
+// Description:
+//------------------------------------------------------------------------------
+void I2C_WriteByte(byte deviceID, byte offset, byte value)
+{
+
+	struct i2c_client* client_ptr = get_sii9234_client(deviceID);
+	if(!client_ptr)
+	{
+		printk("[MHL]I2C_WriteByte error %x\n",deviceID); 
+		return;	
+	}
+	
+	if(deviceID == 0x72)
+		sii9234_i2c_write(client_ptr,offset,value);
+	else if(deviceID == 0x7A)
+		sii9234_i2c_write(client_ptr,offset,value);
+	else if(deviceID == 0x92)
+		sii9234_i2c_write(client_ptr,offset,value);
+	else if(deviceID == 0xC8)
+		sii9234_i2c_write(client_ptr,offset,value);
+
+
+}
+
+
+byte I2C_ReadByte(byte deviceID, byte offset)
+{
+    	byte number = 0;
+	struct i2c_client* client_ptr = get_sii9234_client(deviceID);
+	if(!client_ptr)
+	{
+		printk("[MHL]I2C_ReadByte error %x\n",deviceID); 
+		return 0;	
+	}
+
+  
+  	if(deviceID == 0x72)
+		number = sii9234_i2c_read(client_ptr,offset);
+	else if(deviceID == 0x7A)
+		number = sii9234_i2c_read(client_ptr,offset);
+	else if(deviceID == 0x92)
+		number = sii9234_i2c_read(client_ptr,offset);
+	else if(deviceID == 0xC8)
+		number = sii9234_i2c_read(client_ptr,offset);
+	
+    return (number);
+
+}
+
+byte ReadByteTPI (byte Offset) 
+{
+	return I2C_ReadByte(SA_TX_Page0_Primary, Offset);
+}
+
+void WriteByteTPI (byte Offset, byte Data) 
+{
+	I2C_WriteByte(SA_TX_Page0_Primary, Offset, Data);
+}
+
+
+
+void ReadModifyWriteTPI(byte Offset, byte Mask, byte Data) 
+{
+
+	byte Temp;
+
+	Temp = ReadByteTPI(Offset);		// Read the current value of the register.
+	Temp &= ~Mask;					// Clear the bits that are set in Mask.
+	Temp |= (Data & Mask);			// OR in new value. Apply Mask to Value for safety.
+	WriteByteTPI(Offset, Temp);		// Write new value back to register.
+}
+
+byte ReadByteCBUS (byte Offset) 
+{
+	return I2C_ReadByte(SA_TX_CBUS_Primary, Offset);
+}
+
+void WriteByteCBUS(byte Offset, byte Data) 
+{
+	I2C_WriteByte(SA_TX_CBUS_Primary, Offset, Data);
+}
+
+void ReadModifyWriteCBUS(byte Offset, byte Mask, byte Value) 
+{
+  byte Temp;
+
+  Temp = ReadByteCBUS(Offset);
+  Temp &= ~Mask;
+  Temp |= (Value & Mask);
+  WriteByteCBUS(Offset, Temp);
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION		:	ReadIndexedRegister ()
+//
+// PURPOSE		:	Read the value from an indexed register.
+//
+//					Write:
+//						1. 0xBC => Indexed page num
+//						2. 0xBD => Indexed register offset
+//
+//					Read:
+//						3. 0xBE => Returns the indexed register value
+//
+// INPUT PARAMS	:	PageNum	-	indexed page number
+//					Offset	-	offset of the register within the indexed page.
+//
+// OUTPUT PARAMS:	None
+//
+// GLOBALS USED	:	None
+//
+// RETURNS		:	The value read from the indexed register.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+byte ReadIndexedRegister (byte PageNum, byte Offset) 
+{
+	WriteByteTPI(TPI_INDEXED_PAGE_REG, PageNum);		// Indexed page
+	WriteByteTPI(TPI_INDEXED_OFFSET_REG, Offset);		// Indexed register
+	return ReadByteTPI(TPI_INDEXED_VALUE_REG);			// Return read value
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION		:	WriteIndexedRegister ()
+//
+// PURPOSE		:	Write a value to an indexed register
+//
+//					Write:
+//						1. 0xBC => Indexed page num
+//						2. 0xBD => Indexed register offset
+//						3. 0xBE => Set the indexed register value
+//
+// INPUT PARAMS	:	PageNum	-	indexed page number
+//					Offset	-	offset of the register within the indexed page.
+//					Data	-	the value to be written.
+//
+// OUTPUT PARAMS:	None
+//
+// GLOBALS USED :	None
+//
+// RETURNS		:	None
+//
+//////////////////////////////////////////////////////////////////////////////
+
+void WriteIndexedRegister (byte PageNum, byte Offset, byte Data) 
+{
+	WriteByteTPI(TPI_INDEXED_PAGE_REG, PageNum);		// Indexed page
+	WriteByteTPI(TPI_INDEXED_OFFSET_REG, Offset);		// Indexed register
+	WriteByteTPI(TPI_INDEXED_VALUE_REG, Data);			// Write value
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION		:	ReadModifyWriteIndexedRegister ()
+//
+// PURPOSE		:	Set or clear individual bits in a TPI register.
+//
+// INPUT PARAMS	:	PageNum	-	indexed page number
+//					Offset	-	the offset of the indexed register to be modified.
+//					Mask	-	"1" for each indexed register bit that needs to be
+//								modified
+//					Data	-	The desired value for the register bits in their
+//								proper positions
+//
+// OUTPUT PARAMS:	None
+//
+// GLOBALS USED	:	None
+//
+// RETURNS		:	void
+//
+//////////////////////////////////////////////////////////////////////////////
+
+void ReadModifyWriteIndexedRegister (byte PageNum, byte Offset, byte Mask, byte Data) 
+{
+
+	byte Temp;
+
+	Temp = ReadIndexedRegister (PageNum, Offset);	// Read the current value of the register.
+	Temp &= ~Mask;									// Clear the bits that are set in Mask.
+	Temp |= (Data & Mask);							// OR in new value. Apply Mask to Value for safety.
+	WriteByteTPI(TPI_INDEXED_VALUE_REG, Temp);		// Write new value back to register.
+}
+
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/SiI9234_I2C_master.h news/kernel/drivers/media/video/samsung/mhl_v1/SiI9234_I2C_master.h
--- kernel/drivers/media/video/samsung/mhl_v1/SiI9234_I2C_master.h	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/SiI9234_I2C_master.h	2011-06-17 19:41:22.000000000 +0900
@@ -1,50 +1,59 @@
-/*===========================================================================
-
-                        SiI9024A I2C MASTER.C
-              
-
-DESCRIPTION
-  This file explains the SiI9024A initialization and call the virtual main function.
-  
-
- Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             
-  No part of this work may be reproduced, modified, distributed, transmitted,    
- transcribed, or translated into any language or computer format, in any form   
-or by any means without written permission of: Silicon Image, Inc.,            
-1060 East Arques Avenue, Sunnyvale, California 94085                           
-===========================================================================*/
-
-/*===========================================================================
-
-                      EDIT HISTORY FOR FILE
-
-when              who                         what, where, why
---------        ---                        ----------------------------------------------------------
-2010/10/25    Daniel Lee(Philju)      Initial version of file, SIMG Korea 
-===========================================================================*/
-#include "Common_Def.h"
-
-#include <linux/types.h>
-
-/*===========================================================================
-
-===========================================================================*/
-
-
-void I2C_WriteByte(byte deviceID, byte offset, byte value);
-byte I2C_ReadByte(byte deviceID, byte offset);
-
-byte ReadByteTPI (byte Offset); 
-void WriteByteTPI (byte Offset, byte Data);
-void WriteIndexedRegister (byte PageNum, byte Offset, byte Data);
-void ReadModifyWriteIndexedRegister (byte PageNum, byte Offset, byte Mask, byte Data);
-void ReadModifyWriteIndexedRegister (byte PageNum, byte Offset, byte Mask, byte Data);
-void ReadModifyWriteTPI(byte Offset, byte Mask, byte Data);
-void WriteByteCBUS(byte Offset, byte Data);
-void ReadModifyWriteCBUS(byte Offset, byte Mask, byte Value) ;
-byte ReadIndexedRegister (byte PageNum, byte Offset) ;
-byte ReadByteCBUS (byte Offset) ;
-
-
-
-
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+#include "Common_Def.h"
+
+#include <linux/types.h>
+
+/*===========================================================================
+
+===========================================================================*/
+
+
+void I2C_WriteByte(byte deviceID, byte offset, byte value);
+byte I2C_ReadByte(byte deviceID, byte offset);
+
+byte ReadByteTPI (byte Offset); 
+void WriteByteTPI (byte Offset, byte Data);
+void WriteIndexedRegister (byte PageNum, byte Offset, byte Data);
+void ReadModifyWriteIndexedRegister (byte PageNum, byte Offset, byte Mask, byte Data);
+void ReadModifyWriteIndexedRegister (byte PageNum, byte Offset, byte Mask, byte Data);
+void ReadModifyWriteTPI(byte Offset, byte Mask, byte Data);
+void WriteByteCBUS(byte Offset, byte Data);
+void ReadModifyWriteCBUS(byte Offset, byte Mask, byte Value) ;
+byte ReadIndexedRegister (byte PageNum, byte Offset) ;
+byte ReadByteCBUS (byte Offset) ;
+
+
+
+
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/SiI9234_I2C_slave_add.h news/kernel/drivers/media/video/samsung/mhl_v1/SiI9234_I2C_slave_add.h
--- kernel/drivers/media/video/samsung/mhl_v1/SiI9234_I2C_slave_add.h	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/SiI9234_I2C_slave_add.h	2011-06-17 19:41:22.000000000 +0900
@@ -1,75 +1,91 @@
-/*===========================================================================
-
-                      EDIT HISTORY FOR FILE
-
-when              who                         what, where, why
---------        ---                        ----------------------------------------------------------
-2010/11/06    Daniel Lee(Philju)      Initial version of file, SIMG Korea 
-===========================================================================*/
-
-/*===========================================================================
-                     INCLUDE FILES FOR MODULE
-===========================================================================*/
-
-/*===========================================================================
-                   FUNCTION DEFINITIONS
-===========================================================================*/
-
-typedef enum
-{
-
-	 SA_ADAC_ALT									= 0x24 //changed from 0x26 to avoid conflict with Simon
-	,SA_ADAC										= 0x26
-
-	,SA__PreAuthenticationPage1						= 0x50
-	,SA__PreAuthenticationPage2						= 0x52
-	,SA__PreAuthenticationPage3						= 0x54
-	
-	,SA_RX_Page0_Primary							= 0x60
-	,SA_RX_Page0_Secondary							= 0x62
-	,SA_PP_RX_TMDS_Ports_0_1						= 0x64
-	,SA_PP_RX_TMDS_Ports_2_3						= 0x66
-	,SA_RX_Page1_Primary							= 0x68 ,SA_PP_RX_TMDS_Port_4	= SA_RX_Page1_Primary
-	,SA_RX_Page1_Secondary							= 0x6A
-
-	,SA_TX_Page0_Primary							= 0x72 
-	,SA_RX_HDCP_EDDC								= 0x74
-	,SA_TX_Page0_Secondary							= 0x76
-	,SA_TX_Page1_Primary							= 0x7A
-	,SA_TX_Page1_Secondary							= 0x7E
-
-	,SA_TX_HEAC_Primary								= 0x90 ,SA_PP_Transmitter_TMDS	= SA_TX_HEAC_Primary
-	,SA_TX_HDMI_RX_Primary							= 0x92
-	,SA_TX_HEAC_Secondary							= 0x94 
-	,SA_TX_HDMI_RX_Secondary						= 0x96
-
-	,SA_EDID										= 0xA0
-
-	,SA_PP_Page0_Primary							= 0xB0
-	,SA_PP_Page0_Secondary							= 0xB2
-	,SA_PP_Page1_Primary							= 0xB8
-	,SA_PP_Page1_Secondary							= 0xBA
-
-	,SA_TX_CPI_Primary								= 0xC0
-	,SA_RX_CEC										= 0xC2
-	,SA_TX_CPI_Secondary							= 0xC4
-	,SA_TX_CBUS_Primary								= 0xC8
-	,SA_TX_CBUS_Secondary							= 0xCC
-
-	,SA_PP_HEAC										= 0xD0
-
-	,SA_RX_SAMABETH_PAGE_5							= 0xD8
-
-	,SA_PP_EDID_NVRAM								= 0xE0
-	,SA_RX_CBUS										= 0xE2
-	,SA_RX_CBUS_ALT									= 0xE4 //changed to avoid the conflict with the same slave addresses in Tx
-	,SA_PP_CTRL_Ports_0_3							= 0xE6
-	,SA_PP_CTRL_Port_4								= 0xE8
-}SiI_I2C_Default_SlaveAddresses_e;
-
-
-
-
-
-
-
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+typedef enum
+{
+
+	 SA_ADAC_ALT									= 0x24 //changed from 0x26 to avoid conflict with Simon
+	,SA_ADAC										= 0x26
+
+	,SA__PreAuthenticationPage1						= 0x50
+	,SA__PreAuthenticationPage2						= 0x52
+	,SA__PreAuthenticationPage3						= 0x54
+	
+	,SA_RX_Page0_Primary							= 0x60
+	,SA_RX_Page0_Secondary							= 0x62
+	,SA_PP_RX_TMDS_Ports_0_1						= 0x64
+	,SA_PP_RX_TMDS_Ports_2_3						= 0x66
+	,SA_RX_Page1_Primary							= 0x68 ,SA_PP_RX_TMDS_Port_4	= SA_RX_Page1_Primary
+	,SA_RX_Page1_Secondary							= 0x6A
+
+	,SA_TX_Page0_Primary							= 0x72 
+	,SA_RX_HDCP_EDDC								= 0x74
+	,SA_TX_Page0_Secondary							= 0x76
+	,SA_TX_Page1_Primary							= 0x7A
+	,SA_TX_Page1_Secondary							= 0x7E
+
+	,SA_TX_HEAC_Primary								= 0x90 ,SA_PP_Transmitter_TMDS	= SA_TX_HEAC_Primary
+	,SA_TX_HDMI_RX_Primary							= 0x92
+	,SA_TX_HEAC_Secondary							= 0x94 
+	,SA_TX_HDMI_RX_Secondary						= 0x96
+
+	,SA_EDID										= 0xA0
+
+	,SA_PP_Page0_Primary							= 0xB0
+	,SA_PP_Page0_Secondary							= 0xB2
+	,SA_PP_Page1_Primary							= 0xB8
+	,SA_PP_Page1_Secondary							= 0xBA
+
+	,SA_TX_CPI_Primary								= 0xC0
+	,SA_RX_CEC										= 0xC2
+	,SA_TX_CPI_Secondary							= 0xC4
+	,SA_TX_CBUS_Primary								= 0xC8
+	,SA_TX_CBUS_Secondary							= 0xCC
+
+	,SA_PP_HEAC										= 0xD0
+
+	,SA_RX_SAMABETH_PAGE_5							= 0xD8
+
+	,SA_PP_EDID_NVRAM								= 0xE0
+	,SA_RX_CBUS										= 0xE2
+	,SA_RX_CBUS_ALT									= 0xE4 //changed to avoid the conflict with the same slave addresses in Tx
+	,SA_PP_CTRL_Ports_0_3							= 0xE6
+	,SA_PP_CTRL_Port_4								= 0xE8
+}SiI_I2C_Default_SlaveAddresses_e;
+
+
+
+
+
+
+
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/SiI9234_Reg.h news/kernel/drivers/media/video/samsung/mhl_v1/SiI9234_Reg.h
--- kernel/drivers/media/video/samsung/mhl_v1/SiI9234_Reg.h	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/SiI9234_Reg.h	2011-06-17 19:41:22.000000000 +0900
@@ -1,471 +1,490 @@
-/*===========================================================================
-
-                      EDIT HISTORY FOR FILE
-
-when              who                         what, where, why
---------        ---                        ----------------------------------------------------------
-2010/11/06    Daniel Lee(Philju)      Initial version of file, SIMG Korea 
-===========================================================================*/
-
-/*===========================================================================
-                     INCLUDE FILES FOR MODULE
-===========================================================================*/
-
-
-/*===========================================================================
-                   FUNCTION DEFINITIONS
-===========================================================================*/
-#include "Common_Def.h"
-
-
-#define RGND_OPEN 0x00
-#define RGND_2K 0x01
-#define RGND_1K 0x02
-#define RGND_SHOT 0x03
-
-
-
-//page: 0 Offset: 0x78 Start
-#define PVT_HTBT_FAIL_EN BIT_7
-#define RGND_RDY_EN BIT_6
-#define VBUS_LOW_EN BIT_5
-#define CBUS_LKOUT_EN BIT_4
-#define USB_EST_EN BIT_3
-#define MHL_EST_EN BIT_2
-#define RPWR5V_CHANGE_EN BIT_1
-#define SCDT_CHANGE_EN BIT_0
-//page: 0 Offset: 0x78 End
-
-
-// TPI Video Mode Data
-//====================
-
-#define TPI_PIX_CLK_LSB						(0x00)
-#define TPI_PIX_CLK_MSB						(0x01)
-
-#define TPI_VERT_FREQ_LSB					(0x02)
-#define TPI_VERT_FREQ_MSB					(0x03)
-
-#define TPI_TOTAL_PIX_LSB					(0x04)
-#define TPI_TOTAL_PIX_MSB					(0x05)
-
-#define TPI_TOTAL_LINES_LSB					(0x06)
-#define TPI_TOTAL_LINES_MSB					(0x07)
-
-// Pixel Repetition Data
-//======================
-
-#define TPI_PIX_REPETITION					(0x08)
-
-// TPI AVI Input and Output Format Data
-//=====================================
-
-/// AVI Input Format Data ================================================= ///
-
-#define TPI_INPUT_FORMAT_REG				(0x09)
-
-//Finish this...
-
-#define INPUT_COLOR_SPACE_MASK				(BIT_1 | BIT_0)
-#define INPUT_COLOR_SPACE_RGB				(_ZERO)
-#define INPUT_COLOR_SPACE_YCBCR444			(BIT_0)
-#define INPUT_COLOR_SPACE_YCBCR422			(BIT_1)
-#define INPUT_COLOR_SPACE_BLACK_MODE		(BIT_1 | BIT_0)
-
-/// AVI Output Format Data ================================================ ///
-
-#define TPI_OUTPUT_FORMAT_REG				(0x0A)
-
-#define TPI_YC_Input_Mode					(0x0B)
-
-// TPI AVI InfoFrame Data
-//======================= 
-
-#define TPI_AVI_BYTE_0						(0x0C)
-#define TPI_AVI_BYTE_1						(0x0D)
-#define TPI_AVI_BYTE_2						(0x0E)
-#define TPI_AVI_BYTE_3						(0x0F)
-#define TPI_AVI_BYTE_4						(0x10)
-#define TPI_AVI_BYTE_5						(0x11)
-
-#define TPI_AUDIO_BYTE_0					(0xBF)
-
-#define TPI_END_TOP_BAR_LSB					(0x12)
-#define TPI_END_TOP_BAR_MSB					(0x13)
-
-#define TPI_START_BTM_BAR_LSB				(0x14)
-#define TPI_START_BTM_BAR_MSB				(0x15)
-
-#define TPI_END_LEFT_BAR_LSB				(0x16)
-#define TPI_END_LEFT_BAR_MSB				(0x17)
-
-#define TPI_END_RIGHT_BAR_LSB				(0x18)
-#define TPI_END_RIGHT_BAR_MSB				(0x19)
-
-// Colorimetry
-//============
-#define SET_EX_COLORIMETRY	0x0C	// Set TPI_AVI_BYTE_2 to extended colorimetry and use 
-									//TPI_AVI_BYTE_3
-
-// ===================================================== //
-
-#define TPI_SYSTEM_CONTROL_DATA_REG			(0x1A)
-
-#define LINK_INTEGRITY_MODE_MASK			(BIT_6)
-#define LINK_INTEGRITY_STATIC				(_ZERO)
-#define LINK_INTEGRITY_DYNAMIC				(BIT_6)
-
-#define TMDS_OUTPUT_CONTROL_MASK			(BIT_4)
-#define TMDS_OUTPUT_CONTROL_ACTIVE			(_ZERO)
-#define TMDS_OUTPUT_CONTROL_POWER_DOWN		(BIT_4)
-
-#define AV_MUTE_MASK						(BIT_3)
-#define AV_MUTE_NORMAL						(_ZERO)
-#define AV_MUTE_MUTED						(BIT_3)
-
-#define DDC_BUS_REQUEST_MASK				(BIT_2)
-#define DDC_BUS_REQUEST_NOT_USING			(_ZERO)
-#define DDC_BUS_REQUEST_REQUESTED			(BIT_2)
-
-#define DDC_BUS_GRANT_MASK					(BIT_1)
-#define DDC_BUS_GRANT_NOT_AVAILABLE			(_ZERO)
-#define DDC_BUS_GRANT_GRANTED				(BIT_1)
-
-#define OUTPUT_MODE_MASK					(BIT_0)
-#define OUTPUT_MODE_DVI						(_ZERO)
-#define OUTPUT_MODE_HDMI					(BIT_0)
-
-
-// TPI Identification Registers
-//=============================
-
-#define TPI_DEVICE_ID						(0x1B)
-#define TPI_DEVICE_REV_ID					(0x1C)
-
-#define TPI_RESERVED2						(0x1D)
-
-// ===================================================== //
-
-#define TPI_DEVICE_POWER_STATE_CTRL_REG		(0x1E)
-
-#define CTRL_PIN_CONTROL_MASK				(BIT_4)
-#define CTRL_PIN_TRISTATE					(_ZERO)
-#define CTRL_PIN_DRIVEN_TX_BRIDGE			(0x10)
-
-#define TX_POWER_STATE_MASK					(BIT_1 | BIT_0)
-#define TX_POWER_STATE_D0					(_ZERO)
-#define TX_POWER_STATE_D1					(BIT_0)
-#define TX_POWER_STATE_D2					(BIT_1)
-#define TX_POWER_STATE_D3					(BIT_1 | BIT_0)
-
-// Configuration of I2S Interface
-//===============================
-
-#define TPI_I2S_EN							(0x1F)
-#define TPI_I2S_IN_CFG						(0x20)
-
-// Available only when TPI 0x26[7:6]=10 to select I2S input
-//=========================================================
-#define TPI_I2S_CHST_0						(0x21)
-#define TPI_I2S_CHST_1						(0x22)
-#define TPI_I2S_CHST_2						(0x23)
-#define TPI_I2S_CHST_3						(0x24)
-#define TPI_I2S_CHST_4						(0x25)
-
-
-// Available only when 0x26[7:6]=01
-//=================================
-#define TPI_SPDIF_HEADER					(0x24)
-#define TPI_AUDIO_HANDLING					(0x25)
-
-
-// Audio Configuration Regiaters
-//==============================
-#define TPI_AUDIO_INTERFACE_REG				(0x26)
-
-// Finish this...
-
-#define AUDIO_MUTE_MASK						(BIT_4)
-#define AUDIO_MUTE_NORMAL					(_ZERO)
-#define AUDIO_MUTE_MUTED					(BIT_4)
-
-
-
-
-
-
-#define TPI_AUDIO_SAMPLE_CTRL				(0x27)
-
-#define TPI_SPEAKER_CFG						(0xC7)
-#define TPI_CHANNEL_COUNT					(0xC4)
-
-/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///
-
-/*\
-| | HDCP Implementation
-| |
-| | HDCP link security logic is implemented in certain transmitters; unique
-| |   keys are embedded in each chip as part of the solution. The security 
-| |   scheme is fully automatic and handled completely by the hardware.
-\*/
-
-/// HDCP Query Data Register ============================================== ///
-
-#define TPI_HDCP_QUERY_DATA_REG				(0x29)
-
-#define EXTENDED_LINK_PROTECTION_MASK		(BIT_7)
-#define EXTENDED_LINK_PROTECTION_NONE		(_ZERO)
-#define EXTENDED_LINK_PROTECTION_SECURE		(BIT_7)
-
-#define LOCAL_LINK_PROTECTION_MASK			(BIT_6)
-#define LOCAL_LINK_PROTECTION_NONE			(_ZERO)
-#define LOCAL_LINK_PROTECTION_SECURE		(BIT_6)
-
-#define LINK_STATUS_MASK					(BIT_5 | BIT_4)
-#define LINK_STATUS_NORMAL					(_ZERO)
-#define LINK_STATUS_LINK_LOST				(BIT_4)
-#define LINK_STATUS_RENEGOTIATION_REQ		(BIT_5)
-#define LINK_STATUS_LINK_SUSPENDED			(BIT_5 | BIT_4)
-
-#define HDCP_REPEATER_MASK					(BIT_3)
-#define HDCP_REPEATER_NO					(_ZERO)
-#define HDCP_REPEATER_YES					(BIT_3)
-
-#define CONNECTOR_TYPE_MASK					(BIT_2 | BIT_0)
-#define CONNECTOR_TYPE_DVI					(_ZERO)
-#define CONNECTOR_TYPE_RSVD					(BIT_0)
-#define CONNECTOR_TYPE_HDMI					(BIT_2)
-#define CONNECTOR_TYPE_FUTURE				(BIT_2 | BIT_0)
-
-#define PROTECTION_TYPE_MASK				(BIT_1)
-#define PROTECTION_TYPE_NONE				(_ZERO)
-#define PROTECTION_TYPE_HDCP				(BIT_1)
-
-/// HDCP Control Data Register ============================================ ///
-
-#define TPI_HDCP_CONTROL_DATA_REG			(0x2A)
-
-#define PROTECTION_LEVEL_MASK				(BIT_0)
-#define PROTECTION_LEVEL_MIN				(0x00)
-#define PROTECTION_LEVEL_MAX				(0x01)
-
-/// HDCP BKSV Registers =================================================== ///
-
-#define TPI_BKSV_1_REG						(0x2B)
-#define TPI_BKSV_2_REG						(0x2C)
-#define TPI_BKSV_3_REG						(0x2D)
-#define TPI_BKSV_4_REG						(0x2E)
-#define TPI_BKSV_5_REG						(0x2F)
-
-/// HDCP Revision Data Register =========================================== ///
-
-#define TPI_HDCP_REVISION_DATA_REG			(0x30)
-
-#define HDCP_MAJOR_REVISION_MASK			(BIT_7 | BIT_6 | BIT_5 | BIT_4)
-#define HDCP_MAJOR_REVISION_VALUE			(0x10)
-
-#define HDCP_MINOR_REVISION_MASK			(BIT_3 | BIT_2 | BIT_1 | BIT_0)
-#define HDCP_MINOR_REVISION_VALUE			(0x02)
-
-/// HDCP KSV and V' Value Data Register =================================== ///
-
-#define TPI_V_PRIME_SELECTOR_REG			(0x31)
-
-/// V' Value Readback Registers =========================================== ///
-
-#define TPI_V_PRIME_7_0_REG					(0x32)
-#define TPI_V_PRIME_15_9_REG				(0x33)
-#define TPI_V_PRIME_23_16_REG				(0x34)
-#define TPI_V_PRIME_31_24_REG				(0x35)
-
-/// HDCP AKSV Registers =================================================== ///
-
-#define TPI_AKSV_1_REG						(0x36)
-#define TPI_AKSV_2_REG						(0x37)
-#define TPI_AKSV_3_REG						(0x38)
-#define TPI_AKSV_4_REG						(0x39)
-#define TPI_AKSV_5_REG						(0x3A)
-
-/*\
-| | Interrupt Service
-| |
-| | TPI can be configured to generate an interrupt to the host to notify it of
-| |   various events. The host can either poll for activity or use an interrupt
-| |   handler routine. TPI generates on a single interrupt (INT) to the host.
-\*/
-
-/// Interrupt Enable Register ============================================= ///
-
-#define TPI_INTERRUPT_ENABLE_REG			(0x3C)
-
-#define HDCP_AUTH_STATUS_CHANGE_EN_MASK		(BIT_7)
-#define HDCP_AUTH_STATUS_CHANGE_DISABLE		(0x00)
-#define HDCP_AUTH_STATUS_CHANGE_ENABLE		(0x80)
-
-#define HDCP_VPRIME_VALUE_READY_EN_MASK		(BIT_6)
-#define HDCP_VPRIME_VALUE_READY_DISABLE		(0x00)
-#define HDCP_VPRIME_VALUE_READY_ENABLE		(0x40)
-
-#define HDCP_SECURITY_CHANGE_EN_MASK		(BIT_5)
-#define HDCP_SECURITY_CHANGE_DISABLE		(0x00)
-#define HDCP_SECURITY_CHANGE_ENABLE			(0x20)
-
-#define AUDIO_ERROR_EVENT_EN_MASK			(BIT_4)
-#define AUDIO_ERROR_EVENT_DISABLE			(0x00)
-#define AUDIO_ERROR_EVENT_ENABLE			(0x10)
-
-#define CPI_EVENT_NO_RX_SENSE_MASK			(BIT_3)
-#define CPI_EVENT_NO_RX_SENSE_DISABLE		(0x00)
-#define CPI_EVENT_NO_RX_SENSE_ENABLE		(0x08)
-
-#define RECEIVER_SENSE_EVENT_EN_MASK		(BIT_1)
-#define RECEIVER_SENSE_EVENT_DISABLE		(0x00)
-#define RECEIVER_SENSE_EVENT_ENABLE			(0x02)
-
-#define HOT_PLUG_EVENT_EN_MASK				(BIT_0)
-#define HOT_PLUG_EVENT_DISABLE				(0x00)
-#define HOT_PLUG_EVENT_ENABLE				(0x01)
-
-/// Interrupt Status Register ============================================= ///
-
-#define TPI_INTERRUPT_STATUS_REG			(0x3D)
-
-#define HDCP_AUTH_STATUS_CHANGE_EVENT_MASK	(BIT_7)
-#define HDCP_AUTH_STATUS_CHANGE_EVENT_NO	(0x00)
-#define HDCP_AUTH_STATUS_CHANGE_EVENT_YES	(0x80)
-
-#define HDCP_VPRIME_VALUE_READY_EVENT_MASK	(BIT_6)
-#define HDCP_VPRIME_VALUE_READY_EVENT_NO	(0x00)
-#define HDCP_VPRIME_VALUE_READY_EVENT_YES	(0x40)
-
-#define HDCP_SECURITY_CHANGE_EVENT_MASK		(BIT_5)
-#define HDCP_SECURITY_CHANGE_EVENT_NO		(0x00)
-#define HDCP_SECURITY_CHANGE_EVENT_YES		(0x20)
-
-#define AUDIO_ERROR_EVENT_MASK				(BIT_4)
-#define AUDIO_ERROR_EVENT_NO				(0x00)
-#define AUDIO_ERROR_EVENT_YES				(0x10)
-
-#define CPI_EVENT_MASK						(BIT_3)
-#define CPI_EVENT_NO						(0x00)
-#define CPI_EVENT_YES						(0x08)
-#define RX_SENSE_MASK						(BIT_3)		// This bit is dual purpose depending on the value of 0x3C[3]
-#define RX_SENSE_NOT_ATTACHED				(0x00)
-#define RX_SENSE_ATTACHED					(0x08)
-
-#define HOT_PLUG_PIN_STATE_MASK				(BIT_2)
-#define HOT_PLUG_PIN_STATE_LOW				(0x00)
-#define HOT_PLUG_PIN_STATE_HIGH				(0x04)
-
-#define RECEIVER_SENSE_EVENT_MASK			(BIT_1)
-#define RECEIVER_SENSE_EVENT_NO				(0x00)
-#define RECEIVER_SENSE_EVENT_YES			(0x02)
-
-#define HOT_PLUG_EVENT_MASK					(BIT_0)
-#define HOT_PLUG_EVENT_NO					(0x00)
-#define HOT_PLUG_EVENT_YES					(0x01)
-
-/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///
-
-// Sync Register Configuration and Sync Monitoring Registers
-//==========================================================
-
-#define TPI_SYNC_GEN_CTRL					(0x60)
-#define TPI_SYNC_POLAR_DETECT				(0x61)
-
-// Explicit Sync DE Generator Registers (TPI 0x60[7]=0)
-//=====================================================
-
-#define TPI_DE_DLY							(0x62)
-#define TPI_DE_CTRL							(0x63)
-#define TPI_DE_TOP							(0x64)
-
-#define TPI_RESERVED4						(0x65)
-
-#define TPI_DE_CNT_7_0						(0x66)
-#define TPI_DE_CNT_11_8						(0x67)
-
-#define TPI_DE_LIN_7_0						(0x68)
-#define TPI_DE_LIN_10_8						(0x69)
-
-#define TPI_DE_H_RES_7_0					(0x6A)
-#define TPI_DE_H_RES_10_8					(0x6B)
-
-#define TPI_DE_V_RES_7_0					(0x6C)
-#define TPI_DE_V_RES_10_8					(0x6D)
-
-// Embedded Sync Register Set (TPI 0x60[7]=1)
-//===========================================
-
-#define TPI_HBIT_TO_HSYNC_7_0				(0x62)
-#define TPI_HBIT_TO_HSYNC_9_8				(0x63)
-#define TPI_FIELD_2_OFFSET_7_0				(0x64)
-#define TPI_FIELD_2_OFFSET_11_8				(0x65)
-#define TPI_HWIDTH_7_0						(0x66)
-#define TPI_HWIDTH_8_9						(0x67)
-#define TPI_VBIT_TO_VSYNC					(0x68)
-#define TPI_VWIDTH							(0x69)
-
-// TPI Enable Register
-//====================
-
-#define TPI_ENABLE							(0xC7)
-
-// Misc InfoFrames
-//================
-#define MISC_INFO_FRAMES_CTRL				(0xBF)
-#define MISC_INFO_FRAMES_TYPE				(0xC0)
-#define MISC_INFO_FRAMES_VER				(0xC1)
-#define MISC_INFO_FRAMES_LEN				(0xC2)
-#define MISC_INFO_FRAMES_CHKSUM				(0xC3)
-
-
-
-
-typedef struct 
-{
-    //bool_t		interruptDriven;	// Remember what app told us about interrupt availability.
-    //uint8_t		pollIntervalMs;		// Remember what app set the polling frequency as.
-
-	byte		mscState;			// Internal MSC engine's states.
-
-	byte		status_0;			// Received status from peer is stored here
-	byte		status_1;			// Received status from peer is stored here
-
-	bool		mhlConnectionEvent;
-	byte		mhlConnected;
-
-	// mscMsgArrived == true when a MSC MSG arrives, false when it has been picked up
-	bool		mscMsgArrived;
-	byte		mscMsgSubCommand;
-	byte		mscMsgData;
-
-	// Remember FEATURE FLAG of the peer to reject app commands if unsupported
-	byte		mscFeatureFlag;
-
-	// Remember last command, offset that was sent. Mostly for READ_DEVCAP command
-	byte		mscLastCommand;
-	byte		mscLastOffset;
-
-	// Remember last MSC_MSG command (RCPE particularly)
-
-	byte		mscMsgLastCommand;
-	byte		mscMsgLastData;
-	byte		mscSaveRcpKeyCode;
-
-  
-
-
-
-//  uint8_t 	mscData[ 16 ]; 		// What we got back as message data
-
-} mhlTx_config_t;
-
-enum
-{
-	MSC_STATE_IDLE		= 0x00,		// Until MHL is connected, do nothing
-	MSC_STATE_BEGIN		= 0x01,		// Start of MSC engine to read devcap of the peer
-	MSC_STATE_POW_DONE	= 0x02,		// Just read devcap[2]. Next do the feature flags
-	MSC_STATE_RCP_READY = 0x03		// Feature flags done. Ready to take in RCP.
-};
-
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+/*===========================================================================
+                   FUNCTION DEFINITIONS
+===========================================================================*/
+#include "Common_Def.h"
+
+
+#define RGND_OPEN 0x00
+#define RGND_2K 0x01
+#define RGND_1K 0x02
+#define RGND_SHOT 0x03
+
+
+
+//page: 0 Offset: 0x78 Start
+#define PVT_HTBT_FAIL_EN BIT_7
+#define RGND_RDY_EN BIT_6
+#define VBUS_LOW_EN BIT_5
+#define CBUS_LKOUT_EN BIT_4
+#define USB_EST_EN BIT_3
+#define MHL_EST_EN BIT_2
+#define RPWR5V_CHANGE_EN BIT_1
+#define SCDT_CHANGE_EN BIT_0
+//page: 0 Offset: 0x78 End
+
+
+// TPI Video Mode Data
+//====================
+
+#define TPI_PIX_CLK_LSB						(0x00)
+#define TPI_PIX_CLK_MSB						(0x01)
+
+#define TPI_VERT_FREQ_LSB					(0x02)
+#define TPI_VERT_FREQ_MSB					(0x03)
+
+#define TPI_TOTAL_PIX_LSB					(0x04)
+#define TPI_TOTAL_PIX_MSB					(0x05)
+
+#define TPI_TOTAL_LINES_LSB					(0x06)
+#define TPI_TOTAL_LINES_MSB					(0x07)
+
+// Pixel Repetition Data
+//======================
+
+#define TPI_PIX_REPETITION					(0x08)
+
+// TPI AVI Input and Output Format Data
+//=====================================
+
+/// AVI Input Format Data ================================================= ///
+
+#define TPI_INPUT_FORMAT_REG				(0x09)
+
+//Finish this...
+
+#define INPUT_COLOR_SPACE_MASK				(BIT_1 | BIT_0)
+#define INPUT_COLOR_SPACE_RGB				(_ZERO)
+#define INPUT_COLOR_SPACE_YCBCR444			(BIT_0)
+#define INPUT_COLOR_SPACE_YCBCR422			(BIT_1)
+#define INPUT_COLOR_SPACE_BLACK_MODE		(BIT_1 | BIT_0)
+
+/// AVI Output Format Data ================================================ ///
+
+#define TPI_OUTPUT_FORMAT_REG				(0x0A)
+
+#define TPI_YC_Input_Mode					(0x0B)
+
+// TPI AVI InfoFrame Data
+//======================= 
+
+#define TPI_AVI_BYTE_0						(0x0C)
+#define TPI_AVI_BYTE_1						(0x0D)
+#define TPI_AVI_BYTE_2						(0x0E)
+#define TPI_AVI_BYTE_3						(0x0F)
+#define TPI_AVI_BYTE_4						(0x10)
+#define TPI_AVI_BYTE_5						(0x11)
+
+#define TPI_AUDIO_BYTE_0					(0xBF)
+
+#define TPI_END_TOP_BAR_LSB					(0x12)
+#define TPI_END_TOP_BAR_MSB					(0x13)
+
+#define TPI_START_BTM_BAR_LSB				(0x14)
+#define TPI_START_BTM_BAR_MSB				(0x15)
+
+#define TPI_END_LEFT_BAR_LSB				(0x16)
+#define TPI_END_LEFT_BAR_MSB				(0x17)
+
+#define TPI_END_RIGHT_BAR_LSB				(0x18)
+#define TPI_END_RIGHT_BAR_MSB				(0x19)
+
+// Colorimetry
+//============
+#define SET_EX_COLORIMETRY	0x0C	// Set TPI_AVI_BYTE_2 to extended colorimetry and use 
+									//TPI_AVI_BYTE_3
+
+// ===================================================== //
+
+#define TPI_SYSTEM_CONTROL_DATA_REG			(0x1A)
+
+#define LINK_INTEGRITY_MODE_MASK			(BIT_6)
+#define LINK_INTEGRITY_STATIC				(_ZERO)
+#define LINK_INTEGRITY_DYNAMIC				(BIT_6)
+
+#define TMDS_OUTPUT_CONTROL_MASK			(BIT_4)
+#define TMDS_OUTPUT_CONTROL_ACTIVE			(_ZERO)
+#define TMDS_OUTPUT_CONTROL_POWER_DOWN		(BIT_4)
+
+#define AV_MUTE_MASK						(BIT_3)
+#define AV_MUTE_NORMAL						(_ZERO)
+#define AV_MUTE_MUTED						(BIT_3)
+
+#define DDC_BUS_REQUEST_MASK				(BIT_2)
+#define DDC_BUS_REQUEST_NOT_USING			(_ZERO)
+#define DDC_BUS_REQUEST_REQUESTED			(BIT_2)
+
+#define DDC_BUS_GRANT_MASK					(BIT_1)
+#define DDC_BUS_GRANT_NOT_AVAILABLE			(_ZERO)
+#define DDC_BUS_GRANT_GRANTED				(BIT_1)
+
+#define OUTPUT_MODE_MASK					(BIT_0)
+#define OUTPUT_MODE_DVI						(_ZERO)
+#define OUTPUT_MODE_HDMI					(BIT_0)
+
+
+// TPI Identification Registers
+//=============================
+
+#define TPI_DEVICE_ID						(0x1B)
+#define TPI_DEVICE_REV_ID					(0x1C)
+
+#define TPI_RESERVED2						(0x1D)
+
+// ===================================================== //
+
+#define TPI_DEVICE_POWER_STATE_CTRL_REG		(0x1E)
+
+#define CTRL_PIN_CONTROL_MASK				(BIT_4)
+#define CTRL_PIN_TRISTATE					(_ZERO)
+#define CTRL_PIN_DRIVEN_TX_BRIDGE			(0x10)
+
+#define TX_POWER_STATE_MASK					(BIT_1 | BIT_0)
+#define TX_POWER_STATE_D0					(_ZERO)
+#define TX_POWER_STATE_D1					(BIT_0)
+#define TX_POWER_STATE_D2					(BIT_1)
+#define TX_POWER_STATE_D3					(BIT_1 | BIT_0)
+
+// Configuration of I2S Interface
+//===============================
+
+#define TPI_I2S_EN							(0x1F)
+#define TPI_I2S_IN_CFG						(0x20)
+
+// Available only when TPI 0x26[7:6]=10 to select I2S input
+//=========================================================
+#define TPI_I2S_CHST_0						(0x21)
+#define TPI_I2S_CHST_1						(0x22)
+#define TPI_I2S_CHST_2						(0x23)
+#define TPI_I2S_CHST_3						(0x24)
+#define TPI_I2S_CHST_4						(0x25)
+
+
+// Available only when 0x26[7:6]=01
+//=================================
+#define TPI_SPDIF_HEADER					(0x24)
+#define TPI_AUDIO_HANDLING					(0x25)
+
+
+// Audio Configuration Regiaters
+//==============================
+#define TPI_AUDIO_INTERFACE_REG				(0x26)
+
+// Finish this...
+
+#define AUDIO_MUTE_MASK						(BIT_4)
+#define AUDIO_MUTE_NORMAL					(_ZERO)
+#define AUDIO_MUTE_MUTED					(BIT_4)
+
+
+
+
+
+
+#define TPI_AUDIO_SAMPLE_CTRL				(0x27)
+
+#define TPI_SPEAKER_CFG						(0xC7)
+#define TPI_CHANNEL_COUNT					(0xC4)
+
+/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///
+
+/*\
+| | HDCP Implementation
+| |
+| | HDCP link security logic is implemented in certain transmitters; unique
+| |   keys are embedded in each chip as part of the solution. The security 
+| |   scheme is fully automatic and handled completely by the hardware.
+\*/
+
+/// HDCP Query Data Register ============================================== ///
+
+#define TPI_HDCP_QUERY_DATA_REG				(0x29)
+
+#define EXTENDED_LINK_PROTECTION_MASK		(BIT_7)
+#define EXTENDED_LINK_PROTECTION_NONE		(_ZERO)
+#define EXTENDED_LINK_PROTECTION_SECURE		(BIT_7)
+
+#define LOCAL_LINK_PROTECTION_MASK			(BIT_6)
+#define LOCAL_LINK_PROTECTION_NONE			(_ZERO)
+#define LOCAL_LINK_PROTECTION_SECURE		(BIT_6)
+
+#define LINK_STATUS_MASK					(BIT_5 | BIT_4)
+#define LINK_STATUS_NORMAL					(_ZERO)
+#define LINK_STATUS_LINK_LOST				(BIT_4)
+#define LINK_STATUS_RENEGOTIATION_REQ		(BIT_5)
+#define LINK_STATUS_LINK_SUSPENDED			(BIT_5 | BIT_4)
+
+#define HDCP_REPEATER_MASK					(BIT_3)
+#define HDCP_REPEATER_NO					(_ZERO)
+#define HDCP_REPEATER_YES					(BIT_3)
+
+#define CONNECTOR_TYPE_MASK					(BIT_2 | BIT_0)
+#define CONNECTOR_TYPE_DVI					(_ZERO)
+#define CONNECTOR_TYPE_RSVD					(BIT_0)
+#define CONNECTOR_TYPE_HDMI					(BIT_2)
+#define CONNECTOR_TYPE_FUTURE				(BIT_2 | BIT_0)
+
+#define PROTECTION_TYPE_MASK				(BIT_1)
+#define PROTECTION_TYPE_NONE				(_ZERO)
+#define PROTECTION_TYPE_HDCP				(BIT_1)
+
+/// HDCP Control Data Register ============================================ ///
+
+#define TPI_HDCP_CONTROL_DATA_REG			(0x2A)
+
+#define PROTECTION_LEVEL_MASK				(BIT_0)
+#define PROTECTION_LEVEL_MIN				(0x00)
+#define PROTECTION_LEVEL_MAX				(0x01)
+
+/// HDCP BKSV Registers =================================================== ///
+
+#define TPI_BKSV_1_REG						(0x2B)
+#define TPI_BKSV_2_REG						(0x2C)
+#define TPI_BKSV_3_REG						(0x2D)
+#define TPI_BKSV_4_REG						(0x2E)
+#define TPI_BKSV_5_REG						(0x2F)
+
+/// HDCP Revision Data Register =========================================== ///
+
+#define TPI_HDCP_REVISION_DATA_REG			(0x30)
+
+#define HDCP_MAJOR_REVISION_MASK			(BIT_7 | BIT_6 | BIT_5 | BIT_4)
+#define HDCP_MAJOR_REVISION_VALUE			(0x10)
+
+#define HDCP_MINOR_REVISION_MASK			(BIT_3 | BIT_2 | BIT_1 | BIT_0)
+#define HDCP_MINOR_REVISION_VALUE			(0x02)
+
+/// HDCP KSV and V' Value Data Register =================================== ///
+
+#define TPI_V_PRIME_SELECTOR_REG			(0x31)
+
+/// V' Value Readback Registers =========================================== ///
+
+#define TPI_V_PRIME_7_0_REG					(0x32)
+#define TPI_V_PRIME_15_9_REG				(0x33)
+#define TPI_V_PRIME_23_16_REG				(0x34)
+#define TPI_V_PRIME_31_24_REG				(0x35)
+
+/// HDCP AKSV Registers =================================================== ///
+
+#define TPI_AKSV_1_REG						(0x36)
+#define TPI_AKSV_2_REG						(0x37)
+#define TPI_AKSV_3_REG						(0x38)
+#define TPI_AKSV_4_REG						(0x39)
+#define TPI_AKSV_5_REG						(0x3A)
+
+/*\
+| | Interrupt Service
+| |
+| | TPI can be configured to generate an interrupt to the host to notify it of
+| |   various events. The host can either poll for activity or use an interrupt
+| |   handler routine. TPI generates on a single interrupt (INT) to the host.
+\*/
+
+/// Interrupt Enable Register ============================================= ///
+
+#define TPI_INTERRUPT_ENABLE_REG			(0x3C)
+
+#define HDCP_AUTH_STATUS_CHANGE_EN_MASK		(BIT_7)
+#define HDCP_AUTH_STATUS_CHANGE_DISABLE		(0x00)
+#define HDCP_AUTH_STATUS_CHANGE_ENABLE		(0x80)
+
+#define HDCP_VPRIME_VALUE_READY_EN_MASK		(BIT_6)
+#define HDCP_VPRIME_VALUE_READY_DISABLE		(0x00)
+#define HDCP_VPRIME_VALUE_READY_ENABLE		(0x40)
+
+#define HDCP_SECURITY_CHANGE_EN_MASK		(BIT_5)
+#define HDCP_SECURITY_CHANGE_DISABLE		(0x00)
+#define HDCP_SECURITY_CHANGE_ENABLE			(0x20)
+
+#define AUDIO_ERROR_EVENT_EN_MASK			(BIT_4)
+#define AUDIO_ERROR_EVENT_DISABLE			(0x00)
+#define AUDIO_ERROR_EVENT_ENABLE			(0x10)
+
+#define CPI_EVENT_NO_RX_SENSE_MASK			(BIT_3)
+#define CPI_EVENT_NO_RX_SENSE_DISABLE		(0x00)
+#define CPI_EVENT_NO_RX_SENSE_ENABLE		(0x08)
+
+#define RECEIVER_SENSE_EVENT_EN_MASK		(BIT_1)
+#define RECEIVER_SENSE_EVENT_DISABLE		(0x00)
+#define RECEIVER_SENSE_EVENT_ENABLE			(0x02)
+
+#define HOT_PLUG_EVENT_EN_MASK				(BIT_0)
+#define HOT_PLUG_EVENT_DISABLE				(0x00)
+#define HOT_PLUG_EVENT_ENABLE				(0x01)
+
+/// Interrupt Status Register ============================================= ///
+
+#define TPI_INTERRUPT_STATUS_REG			(0x3D)
+
+#define HDCP_AUTH_STATUS_CHANGE_EVENT_MASK	(BIT_7)
+#define HDCP_AUTH_STATUS_CHANGE_EVENT_NO	(0x00)
+#define HDCP_AUTH_STATUS_CHANGE_EVENT_YES	(0x80)
+
+#define HDCP_VPRIME_VALUE_READY_EVENT_MASK	(BIT_6)
+#define HDCP_VPRIME_VALUE_READY_EVENT_NO	(0x00)
+#define HDCP_VPRIME_VALUE_READY_EVENT_YES	(0x40)
+
+#define HDCP_SECURITY_CHANGE_EVENT_MASK		(BIT_5)
+#define HDCP_SECURITY_CHANGE_EVENT_NO		(0x00)
+#define HDCP_SECURITY_CHANGE_EVENT_YES		(0x20)
+
+#define AUDIO_ERROR_EVENT_MASK				(BIT_4)
+#define AUDIO_ERROR_EVENT_NO				(0x00)
+#define AUDIO_ERROR_EVENT_YES				(0x10)
+
+#define CPI_EVENT_MASK						(BIT_3)
+#define CPI_EVENT_NO						(0x00)
+#define CPI_EVENT_YES						(0x08)
+#define RX_SENSE_MASK						(BIT_3)		// This bit is dual purpose depending on the value of 0x3C[3]
+#define RX_SENSE_NOT_ATTACHED				(0x00)
+#define RX_SENSE_ATTACHED					(0x08)
+
+#define HOT_PLUG_PIN_STATE_MASK				(BIT_2)
+#define HOT_PLUG_PIN_STATE_LOW				(0x00)
+#define HOT_PLUG_PIN_STATE_HIGH				(0x04)
+
+#define RECEIVER_SENSE_EVENT_MASK			(BIT_1)
+#define RECEIVER_SENSE_EVENT_NO				(0x00)
+#define RECEIVER_SENSE_EVENT_YES			(0x02)
+
+#define HOT_PLUG_EVENT_MASK					(BIT_0)
+#define HOT_PLUG_EVENT_NO					(0x00)
+#define HOT_PLUG_EVENT_YES					(0x01)
+
+/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///
+
+// Sync Register Configuration and Sync Monitoring Registers
+//==========================================================
+
+#define TPI_SYNC_GEN_CTRL					(0x60)
+#define TPI_SYNC_POLAR_DETECT				(0x61)
+
+// Explicit Sync DE Generator Registers (TPI 0x60[7]=0)
+//=====================================================
+
+#define TPI_DE_DLY							(0x62)
+#define TPI_DE_CTRL							(0x63)
+#define TPI_DE_TOP							(0x64)
+
+#define TPI_RESERVED4						(0x65)
+
+#define TPI_DE_CNT_7_0						(0x66)
+#define TPI_DE_CNT_11_8						(0x67)
+
+#define TPI_DE_LIN_7_0						(0x68)
+#define TPI_DE_LIN_10_8						(0x69)
+
+#define TPI_DE_H_RES_7_0					(0x6A)
+#define TPI_DE_H_RES_10_8					(0x6B)
+
+#define TPI_DE_V_RES_7_0					(0x6C)
+#define TPI_DE_V_RES_10_8					(0x6D)
+
+// Embedded Sync Register Set (TPI 0x60[7]=1)
+//===========================================
+
+#define TPI_HBIT_TO_HSYNC_7_0				(0x62)
+#define TPI_HBIT_TO_HSYNC_9_8				(0x63)
+#define TPI_FIELD_2_OFFSET_7_0				(0x64)
+#define TPI_FIELD_2_OFFSET_11_8				(0x65)
+#define TPI_HWIDTH_7_0						(0x66)
+#define TPI_HWIDTH_8_9						(0x67)
+#define TPI_VBIT_TO_VSYNC					(0x68)
+#define TPI_VWIDTH							(0x69)
+
+// TPI Enable Register
+//====================
+
+#define TPI_ENABLE							(0xC7)
+
+// Misc InfoFrames
+//================
+#define MISC_INFO_FRAMES_CTRL				(0xBF)
+#define MISC_INFO_FRAMES_TYPE				(0xC0)
+#define MISC_INFO_FRAMES_VER				(0xC1)
+#define MISC_INFO_FRAMES_LEN				(0xC2)
+#define MISC_INFO_FRAMES_CHKSUM				(0xC3)
+
+
+
+
+typedef struct 
+{
+    //bool_t		interruptDriven;	// Remember what app told us about interrupt availability.
+    //uint8_t		pollIntervalMs;		// Remember what app set the polling frequency as.
+
+	byte		mscState;			// Internal MSC engine's states.
+
+	byte		status_0;			// Received status from peer is stored here
+	byte		status_1;			// Received status from peer is stored here
+
+	bool		mhlConnectionEvent;
+	byte		mhlConnected;
+
+	// mscMsgArrived == true when a MSC MSG arrives, false when it has been picked up
+	bool		mscMsgArrived;
+	byte		mscMsgSubCommand;
+	byte		mscMsgData;
+
+	// Remember FEATURE FLAG of the peer to reject app commands if unsupported
+	byte		mscFeatureFlag;
+
+	// Remember last command, offset that was sent. Mostly for READ_DEVCAP command
+	byte		mscLastCommand;
+	byte		mscLastOffset;
+
+	// Remember last MSC_MSG command (RCPE particularly)
+
+	byte		mscMsgLastCommand;
+	byte		mscMsgLastData;
+	byte		mscSaveRcpKeyCode;
+
+  
+
+
+
+//  uint8_t 	mscData[ 16 ]; 		// What we got back as message data
+
+} mhlTx_config_t;
+
+enum
+{
+	MSC_STATE_IDLE		= 0x00,		// Until MHL is connected, do nothing
+	MSC_STATE_BEGIN		= 0x01,		// Start of MSC engine to read devcap of the peer
+	MSC_STATE_POW_DONE	= 0x02,		// Just read devcap[2]. Next do the feature flags
+	MSC_STATE_RCP_READY = 0x03		// Feature flags done. Ready to take in RCP.
+};
+
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/si_RegioCbus.c news/kernel/drivers/media/video/samsung/mhl_v1/si_RegioCbus.c
--- kernel/drivers/media/video/samsung/mhl_v1/si_RegioCbus.c	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/si_RegioCbus.c	2011-06-17 19:41:22.000000000 +0900
@@ -1,48 +1,70 @@
-//***************************************************************************
-//!file     si_regioCbus.c
-//!brief    CBUS register I/O function wrappers.
-//
-// No part of this work may be reproduced, modified, distributed,
-// transmitted, transcribed, or translated into any language or computer
-// format, in any form or by any means without written permission of
-// Silicon Image, Inc., 1060 East Arques Avenue, Sunnyvale, California 94085
-//
-// Copyright 2009, Silicon Image, Inc.  All rights reserved.
-//***************************************************************************/
-
-#include <linux/types.h>
-
-#include "SiI9234_I2C_master.h"
-#include "SiI9234_I2C_slave_add.h"
-
-
-static byte l_cbusPortOffsets [ MHD_MAX_CHANNELS ] = { 0x00 };
-
-//------------------------------------------------------------------------------
-// Function:    SiIRegioCbusRead
-// Description: Read a one byte CBUS register with port offset.
-//              The register address parameter is translated into an I2C slave
-//              address and offset. The I2C slave address and offset are used
-//              to perform an I2C read operation.
-//------------------------------------------------------------------------------
-
-
-byte SiIRegioCbusRead ( word regAddr, byte channel )
-{
-    return(I2C_ReadByte(SA_TX_CBUS_Primary + l_cbusPortOffsets[channel], regAddr));
-}
-
-//------------------------------------------------------------------------------
-// Function:    SiIRegioCbusWrite
-// Description: Write a one byte CBUS register with port offset.
-//              The register address parameter is translated into an I2C
-//              slave address and offset. The I2C slave address and offset
-//              are used to perform an I2C write operation.
-//------------------------------------------------------------------------------
-
-void SiIRegioCbusWrite ( word regAddr, byte channel, byte value )
-{
-
-    I2C_WriteByte(SA_TX_CBUS_Primary + l_cbusPortOffsets[channel], regAddr, value);
-}
-
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+
+#include <linux/types.h>
+
+#include "SiI9234_I2C_master.h"
+#include "SiI9234_I2C_slave_add.h"
+
+
+static byte l_cbusPortOffsets [ MHD_MAX_CHANNELS ] = { 0x00 };
+
+//------------------------------------------------------------------------------
+// Function:    SiIRegioCbusRead
+// Description: Read a one byte CBUS register with port offset.
+//              The register address parameter is translated into an I2C slave
+//              address and offset. The I2C slave address and offset are used
+//              to perform an I2C read operation.
+//------------------------------------------------------------------------------
+
+
+byte SiIRegioCbusRead ( word regAddr, byte channel )
+{
+    return(I2C_ReadByte(SA_TX_CBUS_Primary + l_cbusPortOffsets[channel], regAddr));
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiIRegioCbusWrite
+// Description: Write a one byte CBUS register with port offset.
+//              The register address parameter is translated into an I2C
+//              slave address and offset. The I2C slave address and offset
+//              are used to perform an I2C write operation.
+//------------------------------------------------------------------------------
+
+void SiIRegioCbusWrite ( word regAddr, byte channel, byte value )
+{
+
+    I2C_WriteByte(SA_TX_CBUS_Primary + l_cbusPortOffsets[channel], regAddr, value);
+}
+
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/si_RegioCbus.h news/kernel/drivers/media/video/samsung/mhl_v1/si_RegioCbus.h
--- kernel/drivers/media/video/samsung/mhl_v1/si_RegioCbus.h	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/si_RegioCbus.h	2011-06-17 19:41:22.000000000 +0900
@@ -1,26 +1,48 @@
-//***************************************************************************
-//!file     si_RegioCbus.h
-//!brief    CBUS register I/O function wrappers.
-//
-// No part of this work may be reproduced, modified, distributed,
-// transmitted, transcribed, or translated into any language or computer
-// format, in any form or by any means without written permission of
-// Silicon Image, Inc., 1060 East Arques Avenue, Sunnyvale, California 94085
-//
-// Copyright 2009, Silicon Image, Inc.  All rights reserved.
-//***************************************************************************/
-
-#ifndef __SI_REGIO_H__
-#define __SI_REGIO_H__
-
-#include <linux/types.h>
-
-#include "Common_Def.h"
-
-
-
-byte SiIRegioCbusRead ( word regAddr, byte channel );
-void SiIRegioCbusWrite ( word regAddr, byte channel, byte value );
-
-#endif // __SI_REGIO_H__
-
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+
+#ifndef __SI_REGIO_H__
+#define __SI_REGIO_H__
+
+#include <linux/types.h>
+
+#include "Common_Def.h"
+
+
+
+byte SiIRegioCbusRead ( word regAddr, byte channel );
+void SiIRegioCbusWrite ( word regAddr, byte channel, byte value );
+
+#endif // __SI_REGIO_H__
+
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/si_apiCbus.c news/kernel/drivers/media/video/samsung/mhl_v1/si_apiCbus.c
--- kernel/drivers/media/video/samsung/mhl_v1/si_apiCbus.c	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/si_apiCbus.c	2011-06-17 19:41:22.000000000 +0900
@@ -1,1044 +1,1066 @@
-//***************************************************************************
-//!file     si_apiCbus.c
-//!brief    CBUS API
-//
-// No part of this work may be reproduced, modified, distributed,
-// transmitted, transcribed, or translated into any language or computer
-// format, in any form or by any means without written permission of
-// Silicon Image, Inc., 1060 East Arques Avenue, Sunnyvale, California 94085
-//
-// Copyright 2007-2009, Silicon Image, Inc.  All rights reserved.
-//***************************************************************************/
-
-
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/i2c.h>
-#include <linux/gpio.h>
-#include <plat/pm.h>
-#include <asm/irq.h>
-#include <linux/delay.h>
-#include <plat/gpio-cfg.h>
-#include <mach/regs-gpio.h>
-#include <mach/regs-clock.h>
-
-#include <linux/syscalls.h> 
-#include <linux/fcntl.h> 
-#include <asm/uaccess.h> 
-#include <linux/types.h>
-
-
-#include "Common_Def.h"
-#include "si_apiCbus.h"
-#include "si_RegioCbus.h"
-#include "si_cbusDefs.h"
-
-
-#define MHD_DEVICE_CATEGORY             (MHD_DEV_CAT_SOURCE)
-#define	MHD_LOGICAL_DEVICE_MAP			(MHD_DEV_LD_AUDIO | MHD_DEV_LD_VIDEO | MHD_DEV_LD_MEDIA | MHD_DEV_LD_GUI )
-
-#define CONFIG_CHECK_DDC_ABORT		0
-
-#define CBUS_FW_INTR_POLL_MILLISECS     50      // wait this to issue next status poll i2c read
-
-
-//------------------------------------------------------------------------------
-//  Global data
-//------------------------------------------------------------------------------
-static byte msc_return_cmd;
-static byte msc_return_value;
-
-static cbusChannelState_t l_cbus[MHD_MAX_CHANNELS];
-Bool dev_cap_regs_ready_bit;
-
-//------------------------------------------------------------------------------
-// Function:    SI_CbusRequestStatus 
-// Description: Return the status of the message currently in process, if any.
-// Parameters:  channel - CBUS channel to check
-// Returns:     CBUS_REQ_IDLE, CBUS_REQ_PENDING, CBUS_REQ_SENT, or CBUS_REQ_RECEIVED
-//------------------------------------------------------------------------------
-
-byte SI_CbusRequestStatus ( byte channel )
-{
-	return( l_cbus[ channel].request[ l_cbus[ channel].activeIndex ].reqStatus );
-}
-
-//------------------------------------------------------------------------------
-// Function:    SI_CbusRequestSetIdle
-// Description: Set the active request to the specified state 
-// Parameters:  channel - CBUS channel to set
-//------------------------------------------------------------------------------
-
-void SI_CbusRequestSetIdle ( byte channel, byte newState )
-{
-	l_cbus[ channel].request[ l_cbus[ channel].activeIndex ].reqStatus = newState;
-}
-
-//------------------------------------------------------------------------------
-// Function:    SI_CbusRequestData 
-// Description: Return a pointer to the currently active request structure
-// Parameters:  channel - CBUS channel.
-// Returns:     Pointer to a cbus_req_t structure.
-//------------------------------------------------------------------------------
-
-cbus_req_t *SI_CbusRequestData ( byte channel )
-{
-	return( &l_cbus[ channel].request[ l_cbus[ channel].activeIndex ] );
-}
-
-//------------------------------------------------------------------------------
-// Function:    SI_CbusChannelConnected
-// Description: Return the CBUS channel connected status for this channel.
-// Returns:     TRUE if connected. 
-//              FALSE if disconnected.
-//------------------------------------------------------------------------------
-
-Bool SI_CbusChannelConnected (byte channel)
-{
-	return( l_cbus[ channel].connected );
-}
-
-////////////////////////////////////////////////////////////////////////////////
-//
-// FUNCTION         :   cbus_display_registers
-//
-// PURPOSE          :   For debugging purposes, show salient register on UART
-//
-// INPUT PARAMETERS :   startFrom	= First register to show
-//						howmany		= number of registers to show.
-//									This will be rounded to next multiple of 4.
-//
-// OUTPUT PARAMETERS:   None.
-//
-// RETURNED VALUES  :   None
-//
-// GLOBALS USED     :
-//
-////////////////////////////////////////////////////////////////////////////////
-void cbus_display_registers(int startfrom, int howmany)
-{
-	int	regnum, regval, i;
-	int end_at;
-
-	end_at = startfrom + howmany;
-
-	for(regnum = startfrom; regnum <= end_at;)
-	{
-		for (i = 0 ; i <= 7; i++, regnum++)
-		{
-			regval = SiIRegioCbusRead(regnum, 0);
-		}
-	}
-}
-
-//------------------------------------------------------------------------------
-// Function:    CBusProcessConnectionChange
-// Description: Process a connection change interrupt
-// Returns:     
-//------------------------------------------------------------------------------
-
-static byte CBusProcessConnectionChange ( int channel )
-{
-	channel = 0;
-
-	return( ERROR_CBUS_TIMEOUT );
-}
-
-//------------------------------------------------------------------------------
-// Function:    CBusProcessFailureInterrupts
-// Description: Check for and process any failure interrupts.
-// Returns:     SUCCESS or ERROR_CBUS_ABORT
-//------------------------------------------------------------------------------
-
-static byte CBusProcessFailureInterrupts ( byte channel, byte intStatus, byte inResult )
-{
-
-	byte result          = inResult;
-	byte mscAbortReason  = STATUS_SUCCESS;
-	byte ddcAbortReason  = STATUS_SUCCESS;
-
-	/* At this point, we only need to look at the abort interrupts. */
-
-	intStatus &=  /*BIT_DDC_ABORT |*/ BIT_MSC_ABORT | BIT_MSC_XFR_ABORT;
-
-	if ( intStatus )
-	{
-		result = ERROR_CBUS_ABORT;		// No Retry will help
-
-		/* If transfer abort or MSC abort, clear the abort reason register. */
-
-		if( intStatus & BIT_CONNECT_CHG )
-		{
-			printk("CBUS Connection Change Detected\n");
-		}
-		if( intStatus & BIT_DDC_ABORT )
-		{
-			ddcAbortReason = SiIRegioCbusRead( REG_DDC_ABORT_REASON, channel );
-			printk("CBUS DDC ABORT happened, reason:: %02X\n", (int)(ddcAbortReason));
-		}
-
-		if ( intStatus & BIT_MSC_XFR_ABORT )
-		{
-			mscAbortReason = SiIRegioCbusRead( REG_PRI_XFR_ABORT_REASON, channel );
-
-			printk( "CBUS:: MSC Transfer ABORTED. Clearing 0x0D\n");
-			SiIRegioCbusWrite( REG_PRI_XFR_ABORT_REASON, channel, 0xFF );
-		}
-		if ( intStatus & BIT_MSC_ABORT )
-		{
-			printk( "CBUS:: MSC Peer sent an ABORT. Clearing 0x0E\n");
-			SiIRegioCbusWrite( REG_CBUS_PRI_FWR_ABORT_REASON, channel, 0xFF );
-		}
-
-		// Now display the abort reason.
-
-		if ( mscAbortReason != 0 )
-		{
-			printk( "CBUS:: Reason for ABORT is ....0x%02X = ", (int)mscAbortReason );
-
-			if ( mscAbortReason & CBUSABORT_BIT_REQ_MAXFAIL)
-			{
-				printk("Requestor MAXFAIL - retry threshold exceeded\n");
-			}
-			if ( mscAbortReason & CBUSABORT_BIT_PROTOCOL_ERROR)
-			{
-				printk ("Protocol Error\n");
-			}
-			if ( mscAbortReason & CBUSABORT_BIT_REQ_TIMEOUT)
-			{
-				printk ("Requestor translation layer timeout\n");
-			}
-			if ( mscAbortReason & CBUSABORT_BIT_PEER_ABORTED)
-			{
-				printk ("Peer sent an abort\n");
-			}
-			if ( mscAbortReason & CBUSABORT_BIT_UNDEFINED_OPCODE)
-			{
-				printk ("Undefined opcode\n");
-			}
-		}
-	}
-
-	/* Clear any failure interrupt that we received.    */
-	SiIRegioCbusWrite( REG_CBUS_INTR_STATUS, channel, intStatus );
-
-	return( result );
-}
-
-//------------------------------------------------------------------------------
-// Function:    CBusProcessSubCommand
-// Description: Process a sub-command (RCP) or sub-command response (RCPK).
-//              Modifies channel state as necessary.
-// Parameters:  channel - CBUS channel that received the command.
-// Returns:     SUCCESS or CBUS_SOFTWARE_ERRORS_t
-//              If SUCCESS, command data is returned in l_cbus[channel].msgData[i]
-//------------------------------------------------------------------------------
-
-static byte CBusProcessSubCommand ( int channel, byte vs_cmd, byte vs_data )
-{
-	/* Save RCP message data in the channel request structure to be returned    */
-	/* to the upper level.                                                      */
-
-	l_cbus[channel].request[l_cbus[channel].activeIndex].command = vs_cmd;
-	l_cbus[channel].request[l_cbus[channel].activeIndex].offsetData = vs_data;
-
-	/* Parse it a little before telling the upper level about it.   */
-
-	switch (vs_cmd) {
-	case MHD_MSC_MSG_RCP:
-	/* Received a Remote Control Protocol message.  Signal that */
-	/* it has been received if we are in the right state,       */
-	/* otherwise, it is a bogus message.  Don't send RCPK now   */
-	/* because the upper layer must validate the command.       */
-		printk ("CBUS:: Received <-- MHD_MSC_MSG_RCP::"
-				" cbus state = %02X\n",
-				(int)(l_cbus[ channel].state));
-		switch (l_cbus[channel].state) {
-		case CBUS_IDLE:
-		case CBUS_SENT:
-			l_cbus[channel].request[l_cbus[channel].activeIndex ].reqStatus = CBUS_REQ_RECEIVED;
-			l_cbus[ channel].state = CBUS_RECEIVED;
-			break;
-		default:
-			l_cbus[ channel].state = CBUS_IDLE;
-			break;
-		}
-
-		break;
-	case MHD_MSC_MSG_RCPK:
-		printk ("CBUS:: Received <-- MHD_MSC_MSG_RCPK\n");
-		break;
-	case MHD_MSC_MSG_RCPE:
-		printk ("CBUS:: Received <-- MHD_MSC_MSG_RCPE\n");
-		break;
-	case MHD_MSC_MSG_RAP:
-		printk ("CBUS:: Received <-- MHD_MSC_MSG_RAP::"
-			" cbus state = %02X\n",
-			(int)(l_cbus[ channel].state));
-
-		switch ( l_cbus[ channel].state ) {
-		case CBUS_IDLE:
-		case CBUS_SENT:
-			l_cbus[ channel].request[ l_cbus[ channel].activeIndex ].reqStatus = CBUS_REQ_RECEIVED;
-			l_cbus[ channel].state = CBUS_RECEIVED;
-			break;
-		default:
-			l_cbus[ channel].state = CBUS_IDLE;
-			break;
-		}
-		break;
-	case MHD_MSC_MSG_RAPK:
-		printk ("CBUS:: Received <-- MHD_MSC_MSG_RAPK\n");
-		break;
-
-#if MSC_TESTER
-	case MHD_MSC_MSG_NEW_TESTER:
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_NEW_TESTER_REPLY, 0x00);
-		break;
-	case MHD_MSC_MSG_NEW_TESTER_REPLY:
-		msc_return_cmd = vs_cmd;
-		break;
-	case MHD_MSC_MSG_STATE_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_0, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_STATE_CHANGE_REPLY, 0x00);
-		break;
-	case MHD_MSC_MSG_DEVCAP0_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_0, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_0, channel);
-		break;
-	case MHD_MSC_MSG_DEVCAP1_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_1, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_1, channel);
-		break;
-	case MHD_MSC_MSG_DEVCAP2_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_2, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_2, channel);
-		break;
-	case MHD_MSC_MSG_DEVCAP3_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_3, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_3, channel);
-		break;
-	case MHD_MSC_MSG_DEVCAP4_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_4, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_4, channel);
-		break;
-	case MHD_MSC_MSG_DEVCAP5_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_5, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_5, channel);
-		break;
-	case MHD_MSC_MSG_DEVCAP6_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_6, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_6, channel);
-		break;
-
-	case MHD_MSC_MSG_DEVCAP7_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_7, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_7, channel);
-		break;
-	case MHD_MSC_MSG_DEVCAP8_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_8, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_8, channel);
-		break;
-	case MHD_MSC_MSG_DEVCAP9_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_9, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_9, channel);
-		break;		
-	case MHD_MSC_MSG_DEVCAP10_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_A, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_A, channel);
-		break;		
-	case MHD_MSC_MSG_DEVCAP11_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_B, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_B, channel);
-		break;
-	case MHD_MSC_MSG_DEVCAP12_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_C, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_C, channel);
-		break;
-	case MHD_MSC_MSG_DEVCAP13_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_D, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_D, channel);
-		break;
-	case MHD_MSC_MSG_DEVCAP14_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_E, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_E, channel);
-		break;
-	case MHD_MSC_MSG_DEVCAP15_CHANGE:
-		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_F, channel, vs_data );
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_F, channel);
-		break;
-	case MHD_MSC_MSG_SET_INT0_CHECK:
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_SET_INT_REPLY, SiIRegioCbusRead( REG_CBUS_SET_INT_0, channel );
-		break;
-	case MHD_MSC_MSG_SET_INT1_CHECK:
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_SET_INT_REPLY, SiIRegioCbusRead( REG_CBUS_SET_INT_1, channel );
-		break;
-	case MHD_MSC_MSG_SET_INT2_CHECK:
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_SET_INT_REPLY, SiIRegioCbusRead( REG_CBUS_SET_INT_2, channel );
-		break;
-	case MHD_MSC_MSG_SET_INT3_CHECK:
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_SET_INT_REPLY, SiIRegioCbusRead( REG_CBUS_SET_INT_3, channel );
-		break;
-	case MHD_MSC_MSG_WRITE_STAT0_CHECK:
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_WRITE_STAT_REPLY, SiIRegioCbusRead( REG_CBUS_WRITE_STAT_0, channel );
-		break;
-	case MHD_MSC_MSG_WRITE_STAT1_CHECK:
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_WRITE_STAT_REPLY, SiIRegioCbusRead( REG_CBUS_WRITE_STAT_1, channel );
-		break;
-	case MHD_MSC_MSG_WRITE_STAT2_CHECK:
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_WRITE_STAT_REPLY, SiIRegioCbusRead( REG_CBUS_WRITE_STAT_2, channel );
-		break;
-	case MHD_MSC_MSG_WRITE_STAT3_CHECK:
-		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_WRITE_STAT_REPLY, SiIRegioCbusRead( REG_CBUS_WRITE_STAT_3, channel );
-		break;
-	case MHD_MSC_MSG_STATE_CHANGE_REPLY:
-		msc_return_cmd = vs_cmd;
-		break;
-	case MHD_MSC_MSG_DEVCAP_CHANGE_REPLY:
-		msc_return_cmd = vs_cmd;
-		break;	
-	case MHD_MSC_MSG_SET_INT_REPLY:
-		msc_return_value = vs_data;
-		msc_return_cmd = vs_cmd;
-		break;
-	case MHD_MSC_MSG_WRITE_STAT_REPLY:
-		msc_return_value = vs_data;
-		msc_return_cmd = vs_cmd;
-		break;
-#endif
-	default:
-		break;
-	}
-
-	printk ("CBUS:: MSG_MSC CMD:  0x%02X\n", (int)vs_cmd );
-	printk ("CBUS:: MSG_MSC Data: 0x%02X\n\n", (int)vs_data );
-
-	return( STATUS_SUCCESS );
-}
-
-#if MSC_TESTER
-void SI_CbusMscResetReturnCmd()
-{
-	msc_return_cmd = 0;
-}
-
-void SI_CbusMscResetReturnValue()
-{
-	msc_return_value = 0;
-}
-
-byte	SI_CbusMscReturnCmd()
-{
-	return msc_return_cmd;
-}
-
-byte	SI_CbusMscReturnValue()
-{
-	return msc_return_value;
-}
-#endif // MSC_TESTER
-
-
-//------------------------------------------------------------------------------
-// Function:    CBusWriteCommand
-// Description: Write the specified Sideband Channel command to the CBUS.
-//              Command can be a MSC_MSG command (RCP/MCW/RAP), or another command 
-//              such as READ_DEVCAP, GET_VENDOR_ID, SET_HPD, CLR_HPD, etc.
-//
-// Parameters:  channel - CBUS channel to write
-//              pReq    - Pointer to a cbus_req_t structure containing the 
-//                        command to write
-// Returns:     TRUE    - successful write
-//              FALSE   - write failed
-//------------------------------------------------------------------------------
-
-static Bool CBusWriteCommand ( int channel, cbus_req_t *pReq  )
-{
-	byte i, startbit;
-	Bool  success = TRUE;
-
-	printk ("CBUS:: Sending MSC command %02X, %02X, %02X\n", (int)pReq->command, (int)pReq->msgData[0], (int)pReq->msgData[1]);
-
-	/****************************************************************************************/
-	/* Setup for the command - write appropriate registers and determine the correct        */
-	/*                         start bit.                                                   */
-	/****************************************************************************************/
-
-	// Set the offset and outgoing data byte right away
-	SiIRegioCbusWrite( REG_CBUS_PRI_ADDR_CMD, channel, pReq->offsetData); 	// set offset
-	SiIRegioCbusWrite( REG_CBUS_PRI_WR_DATA_1ST, channel, pReq->msgData[0] );
-
-	startbit = 0x00;
-	switch ( pReq->command )
-	{
-		case MHD_SET_INT:	// Set one interrupt register = 0x60
-			SiIRegioCbusWrite( REG_CBUS_PRI_ADDR_CMD, channel, pReq->offsetData + 0x20 ); 	// set offset
-			startbit = MSC_START_BIT_WRITE_REG;
-			break;
-
-		case MHD_WRITE_STAT:	// Write one status register = 0x60 | 0x80
-			SiIRegioCbusWrite( REG_CBUS_PRI_ADDR_CMD, channel, pReq->offsetData + 0x30 ); 	// set offset
-			startbit = MSC_START_BIT_WRITE_REG;
-			break;
-
-		case MHD_READ_DEVCAP:	// Read one device capability register = 0x61
-			startbit = MSC_START_BIT_READ_REG;
-			break;
-
-		case MHD_GET_STATE:			// 0x62 - Used for heartbeat
-		case MHD_GET_VENDOR_ID:		// 0x63 - for vendor id	
-		case MHD_SET_HPD:			// 0x64	- Set Hot Plug Detect in follower
-		case MHD_CLR_HPD:			// 0x65	- Clear Hot Plug Detect in follower
-		case MHD_GET_SC1_ERRORCODE:		// 0x69	- Get channel 1 command error code
-		case MHD_GET_DDC_ERRORCODE:		// 0x6A	- Get DDC channel command error code.
-		case MHD_GET_MSC_ERRORCODE:		// 0x6B	- Get MSC command error code.
-		case MHD_GET_SC3_ERRORCODE:		// 0x6D	- Get channel 3 command error code.
-			SiIRegioCbusWrite( REG_CBUS_PRI_ADDR_CMD, channel, pReq->command );
-			startbit = MSC_START_BIT_MSC_CMD;
-			break;
-
-		case MHD_MSC_MSG:
-			SiIRegioCbusWrite( REG_CBUS_PRI_WR_DATA_2ND, channel, pReq->msgData[1] );
-			SiIRegioCbusWrite( REG_CBUS_PRI_ADDR_CMD, channel, pReq->command );
-			startbit = MSC_START_BIT_VS_CMD;
-			break;
-
-		case MHD_WRITE_BURST:
-			SiIRegioCbusWrite( REG_CBUS_PRI_ADDR_CMD, channel, pReq->offsetData + 0x40 );
-			SiIRegioCbusWrite( REG_MSC_WRITE_BURST_LEN, channel, pReq->length -1 );
-			printk ("CBUS:: pReq->length: 0x%02X\n\n", (int)pReq->length );
-
-			// Now copy all bytes from array to local scratchpad
-
-			for ( i = 0; i < pReq->length; i++ )
-			{
-				SiIRegioCbusWrite( REG_CBUS_SCRATCHPAD_0 + i, channel, pReq->msgData[i] );
-			}
-			startbit = MSC_START_BIT_WRITE_BURST;
-			break;
-
-		default:
-			success = FALSE;
-			break;
-	}
-
-	/****************************************************************************************/
-	/* Trigger the CBUS command transfer using the determined start bit.                    */
-	/****************************************************************************************/
-
-	if( success )
-	{
-		SiIRegioCbusWrite( REG_CBUS_PRI_START, channel, startbit );
-	}
-
-	return( success );
-}
-
-//------------------------------------------------------------------------------
-// Function:    CBusConmmandGetNextInQueue
-// Description: find out the next command in the queue to be sent
-// Parameters:  channel - CBUS channel that received the command.
-// Returns:     the index of the next command
-//------------------------------------------------------------------------------
-
-static byte CBusConmmandGetNextInQueue( byte channel )
-{
-	byte   result = STATUS_SUCCESS;
-
-	byte nextIndex = (l_cbus[ channel].activeIndex == (CBUS_MAX_COMMAND_QUEUE - 1)) ? 
-		0 : (l_cbus[ channel].activeIndex + 1)	;
-
-
-	while ( l_cbus[ channel].request[ nextIndex].reqStatus != CBUS_REQ_PENDING )
-	{
-		if ( nextIndex == l_cbus[ channel].activeIndex )   //searched whole queue, no pending 
-			return 0;	
-
-		nextIndex = ( nextIndex == (CBUS_MAX_COMMAND_QUEUE - 1)) ? 
-			0 : (nextIndex + 1);
-	}
-
-	printk("channel:%x nextIndex:%x \n",(int)channel,(int)nextIndex);
-
-	if ( CBusWriteCommand( channel, &l_cbus[ channel].request[ nextIndex] ) )
-	{
-		l_cbus[ channel].request[ nextIndex].reqStatus = CBUS_REQ_SENT;
-		l_cbus[ channel].activeIndex = nextIndex;						
-		l_cbus[ channel].state = CBUS_SENT;					
-	}
-	else
-	{
-		printk ( "CBUS:: CBusWriteCommand failed\n" );
-		result = ERROR_WRITE_FAILED;
-	}
-
-	return result;
-
-}
-
-//------------------------------------------------------------------------------
-// Function:    CBusResetToIdle
-// Description: Set the specified channel state to IDLE. Clears any messages that
-//              are in progress or queued.  Usually used if a channel connection 
-//              changed or the channel heartbeat has been lost.
-// Parameters:  channel - CBUS channel to reset
-//------------------------------------------------------------------------------
-
-static void CBusResetToIdle ( byte channel )
-{
-	byte queueIndex;
-
-	l_cbus[ channel].state = CBUS_IDLE;
-
-	for ( queueIndex = 0; queueIndex < CBUS_MAX_COMMAND_QUEUE; queueIndex++ )
-	{
-		l_cbus[ channel].request[ queueIndex].reqStatus = CBUS_REQ_IDLE;
-	}
-}
-
-//------------------------------------------------------------------------------
-// Function:    CBusCheckInterruptStatus
-// Description: If any interrupts on the specified channel are set, process them.
-// Parameters:  channel - CBUS channel to check
-// Returns:     SUCCESS or CBUS_SOFTWARE_ERRORS_t error code.
-//------------------------------------------------------------------------------
-
-static byte CBusCheckInterruptStatus ( byte channel )
-{
-	byte 	intStatus, result;
-	byte     vs_cmd, vs_data;
-	byte 	writeBurstLen 	= 0;
-
-	/* Read CBUS interrupt status.  */
-	intStatus = SiIRegioCbusRead( REG_CBUS_INTR_STATUS, channel );
-	if( intStatus & BIT_MSC_MSG_RCV )
-	{
-		printk("( intStatus & BIT_MSC_MSG_RCV )\n");
-		vs_cmd  = SiIRegioCbusRead( REG_CBUS_PRI_VS_CMD, channel );
-		vs_data = SiIRegioCbusRead( REG_CBUS_PRI_VS_DATA, channel );
-	}
-	SiIRegioCbusWrite( REG_CBUS_INTR_STATUS, channel, intStatus );
-
-	/* Check for interrupts.  */
-
-	result = STATUS_SUCCESS;
-	intStatus &= (~BIT_HEARTBEAT_TIMEOUT);	 //don't check heartbeat
-	if( intStatus != 0 )
-	{
-		if( intStatus & BIT_CONNECT_CHG )
-		{
-			printk("( intStatus & BIT_CONNECT_CHG )\n");
-			/* The connection change interrupt has been received.   */
-			result = CBusProcessConnectionChange( channel );
-			SiIRegioCbusWrite( REG_CBUS_BUS_STATUS, channel, BIT_CONNECT_CHG );
-		}
-
-		if( intStatus & BIT_MSC_XFR_DONE )
-		{
-			printk("( intStatus & BIT_MSC_XFR_DONE )\n");
-			/* A previous MSC sub-command has been acknowledged by the responder.   */
-			/* Does not include MSC MSG commands.                                   */
-
-			l_cbus[ channel].state = CBUS_XFR_DONE;
-
-			/* Save any response data in the channel request structure to be returned    */
-			/* to the upper level.                                                      */
-
-			msc_return_cmd = l_cbus[ channel].request[ l_cbus[ channel].activeIndex ].msgData[0] = 
-				SiIRegioCbusRead( REG_CBUS_PRI_RD_DATA_1ST, channel );
-			msc_return_value = l_cbus[ channel].request[ l_cbus[ channel].activeIndex ].msgData[1] = 
-				SiIRegioCbusRead( REG_CBUS_PRI_RD_DATA_2ND, channel );
-
-			printk ( "\nCBUS:: Transfer Done \n" );
-			printk ("Response data Received:: %02X\n\n", (int)l_cbus[ channel].request[l_cbus[channel].activeIndex].msgData[0]);
-
-			result = STATUS_SUCCESS;
-
-			// Check if we received NACK from Peer
-			writeBurstLen = SiIRegioCbusRead( REG_MSC_WRITE_BURST_LEN, channel );
-			if( writeBurstLen & MSC_REQUESTOR_DONE_NACK )
-			{
-				result = ERROR_NACK_FROM_PEER;
-				printk( "NACK received!!! :: %02X\n", (int)writeBurstLen) ;
-			}
-			result = CBusProcessFailureInterrupts( channel, intStatus, result );
-		}
-
-		if( intStatus & BIT_MSC_MSG_RCV )
-		{
-			printk("( intStatus & BIT_MSC_MSG_RCV )\n");
-			/* Receiving a sub-command, either an actual command or */
-			/* the response to a command we sent.                   */
-			result = CBusProcessSubCommand( channel, vs_cmd, vs_data );
-		}
-	}
-	return( result );
-}
-#if MSC_TESTER
-
-//------------------------------------------------------------------------------
-// Function:    SI_CbusHeartBeat
-// Description:  Enable/Disable Heartbeat
-//------------------------------------------------------------------------------
-
-void SI_CbusHeartBeat ( byte channel, byte enable)
-{
-	byte  value;
-	value = SiIRegioCbusRead( REG_MSC_HEARTBEAT_CONTROL, channel);
-	SiIRegioCbusWrite( REG_MSC_HEARTBEAT_CONTROL, channel, enable ? (value | MSC_HEARTBEAT_ENABLE) : ( value & 0x7F) );
-}
-#endif // MSC_TESTER
-
-//------------------------------------------------------------------------------
-// Function:    SI_CbusMscMsgSubCmdSend
-// Description: Send MSC_MSG (RCP) message to the specified CBUS channel (port)
-//
-// Parameters:  channel     - CBUS channel
-//              vsCommand   - MSC_MSG cmd (RCP, RCPK or RCPE)
-//              cmdData     - MSC_MSG data
-// Returns:     TRUE        - successful queue/write
-//              FALSE       - write and/or queue failed
-//------------------------------------------------------------------------------
-
-Bool SI_CbusMscMsgSubCmdSend ( byte channel, byte vsCommand, byte cmdData )
-{
-	cbus_req_t	req;
-
-	//
-	// Send MSC_MSG command (Vendor Specific command)
-	//
-	req.command     = MHD_MSC_MSG;
-	req.msgData[0]  = vsCommand; 
-	req.msgData[1]  = cmdData; 
-	return( SI_CbusWriteCommand( channel, &req  ));
-}
-
-//------------------------------------------------------------------------------
-// Function:    SI_CbusRcpMessageAck
-// Description: Send RCP_K (acknowledge) message to the specified CBUS channel 
-//              and set the request status to idle.
-//
-// Parameters:  channel     - CBUS channel
-// Returns:     TRUE        - successful queue/write
-//              FALSE       - write and/or queue failed
-//------------------------------------------------------------------------------
-
-Bool SI_CbusRcpMessageAck ( byte channel, byte cmdStatus, byte keyCode )
-{
-
-	SI_CbusRequestSetIdle( channel, CBUS_REQ_IDLE );
-	if(cmdStatus != MHD_MSC_MSG_NO_ERROR)
-	{
-		SI_CbusMscMsgSubCmdSend( channel, MHD_MSC_MSG_RCPE, cmdStatus );
-	}
-	return( SI_CbusMscMsgSubCmdSend( channel, MHD_MSC_MSG_RCPK, keyCode ));
-}
-
-
-//------------------------------------------------------------------------------
-// Function:    SI_CbusRapMessageAck
-// Description: Send RAPK (acknowledge) message to the specified CBUS channel 
-//              and set the request status to idle.
-//
-// Parameters:  channel     - CBUS channel
-// Returns:     TRUE        - successful queue/write
-//              FALSE       - write and/or queue failed
-//------------------------------------------------------------------------------
-
-Bool SI_CbusRapMessageAck ( byte channel, byte cmdStatus )
-{
-	printk("SI_CbusRapMessageAck:%x \n",(int)cmdStatus);  
-	SI_CbusRequestSetIdle( channel, CBUS_REQ_IDLE );
-	return( SI_CbusMscMsgSubCmdSend( channel, MHD_MSC_MSG_RAPK, cmdStatus ));
-}
-
-//------------------------------------------------------------------------------
-// Function:    SI_CbusSendDcapRdyMsg
-// Description: Send a msg to peer informing the devive capability registers are
-//				ready to be read.
-// Parameters:  channel to check
-// Returns:     TRUE    - success
-//              FALSE   - failure
-//------------------------------------------------------------------------------
-Bool SI_CbusSendDcapRdyMsg ( byte channel )
-{
-	//cbus_req_t *pReq; // SIMG old code 
-	cbus_req_t pReq;  //daniel 20101101
-	Bool result = TRUE;
-
-	if( l_cbus[ channel].connected ) 
-	{
-		printk( "SI_CbusSendDcapRdyMsg Called!!\n");
-		//send a msg to peer that the device capability registers are ready to be read.
-		//set DCAP_RDY bit 
-		pReq.command = MHD_WRITE_STAT;
-		pReq.offsetData = 0x00;
-		pReq.msgData[0] = BIT_0;
-		//result = SI_CbusWriteCommand(0, pReq); // SIMG old code 
-		result = SI_CbusWriteCommand(0, &pReq);
-
-		//set DCAP_CHG bit
-		pReq.command = MHD_SET_INT;
-		pReq.offsetData = 0x00;
-		pReq.msgData[0] = BIT_0;
-		//result = SI_CbusWriteCommand(0, pReq); // SIMG old code 
-		result = SI_CbusWriteCommand(0, &pReq);
-
-		dev_cap_regs_ready_bit = TRUE;
-	}
-
-	return result;
-}
-
-
-//------------------------------------------------------------------------------
-// Function:    SI_CbusHandler
-// Description: Check the state of any current CBUS message on specified channel.
-//              Handle responses or failures and send any pending message if 
-//              channel is IDLE.
-// Parameters:  channel - CBUS channel to check, must be in range, NOT 0xFF
-// Returns:     SUCCESS or one of CBUS_SOFTWARE_ERRORS_t
-//------------------------------------------------------------------------------
-
-byte SI_CbusHandler ( byte channel )
-{
-	byte result = STATUS_SUCCESS;
-
-	/* Check the channel interrupt status to see if anybody is  */
-	/* talking to us. If they are, talk back.                   */
-
-	result = CBusCheckInterruptStatus( channel );
-
-	/* Don't bother with the rest if the heart is gone. */
-
-	if ( (result == ERROR_NO_HEARTBEAT) || (result == ERROR_NACK_FROM_PEER) )
-	{
-		printk("SI_CbusHandler:: CBusCheckInterruptStatus returned -->> %02X\n", (int)result);
-		return( result );
-	}
-
-	/* Update the channel state machine as necessary.   */
-
-	switch ( l_cbus[ channel].state )
-	{
-		case CBUS_IDLE:
-			result = CBusConmmandGetNextInQueue( channel );				
-			break;
-
-		case CBUS_SENT:
-			break;
-
-		case CBUS_XFR_DONE:
-			l_cbus[ channel].state      = CBUS_IDLE;
-
-			/* We may be waiting for a response message, but the    */
-			/* request queue is idle.                               */
-			l_cbus[ channel].request[ l_cbus[channel].activeIndex].reqStatus = CBUS_REQ_IDLE;
-			break;
-
-		case CBUS_WAIT_RESPONSE:
-			break;
-
-		case CBUS_RECEIVED:
-			// printk(MSG_ALWAYS, ("SI_CbusHandler:: l_cbus[ channel].state -->> %02X\n", (int)(l_cbus[ channel].state));
-			// printk(MSG_ALWAYS, ("result -->> %02X\n", (int)(result));
-
-			/* Either command or response data has been received.   */
-
-			break;
-
-		default:
-			/* Not a valid state, reset to IDLE and get out with failure. */
-
-			l_cbus[ channel].state = CBUS_IDLE;
-			result = ERROR_INVALID;
-			break;
-	}
-
-	return( result );
-}
-
-//------------------------------------------------------------------------------
-// Function:    SI_CbusWriteCommand
-// Description: Place a command in the CBUS message queue.  If queue was empty,
-//              send the new command immediately.
-//
-// Parameters:  channel - CBUS channel to write
-//              pReq    - Pointer to a cbus_req_t structure containing the 
-//                        command to write
-// Returns:     TRUE    - successful queue/write
-//              FALSE   - write and/or queue failed
-//------------------------------------------------------------------------------
-
-Bool SI_CbusWriteCommand ( byte channel, cbus_req_t *pReq  )
-{
-	byte queueIndex;
-	Bool  success = FALSE;
-
-	if ( l_cbus[ channel].connected )
-	{
-		printk("CBUS Write command\n");
-		/* Copy the request to the queue.   */
-
-		//printk ( "SI_CbusWriteCommand:: Channel State: %02X\n", (int)l_cbus[ channel].state );
-		for ( queueIndex = 0; queueIndex < CBUS_MAX_COMMAND_QUEUE; queueIndex++ )
-		{
-			if ( l_cbus[ channel].request[ queueIndex].reqStatus == CBUS_REQ_IDLE )
-			{
-				/* Found an idle queue entry, copy the request and set to pending.  */
-
-				memcpy( &l_cbus[ channel].request[ queueIndex], pReq, sizeof( cbus_req_t ));
-				l_cbus[ channel].request[ queueIndex].reqStatus = CBUS_REQ_PENDING;
-				success = TRUE;
-				break;
-			}
-		}
-
-		/* If successful at putting the request into the queue, decide  */
-		/* whether it can be sent now or later.                         */
-		printk("state:%x \n",(int)l_cbus[ channel].state);
-		printk("channel:%x queueIndex:%x \n",(int)channel,(int)queueIndex);
-		printk ("CBUS:: Sending MSC command %02X, %02X, %02X\n", (int)pReq->command, (int)pReq->msgData[0], (int)pReq->msgData[1]);
-		if ( success )
-		{
-			switch ( l_cbus[ channel].state )
-			{
-				case CBUS_IDLE:
-				case CBUS_RECEIVED:	   
-					success = CBusConmmandGetNextInQueue( channel );				
-					break;
-				case CBUS_WAIT_RESPONSE:
-				case CBUS_SENT:
-				case CBUS_XFR_DONE:
-
-					/* Another command is in progress, the Handler loop will    */
-					/* send the new command when the bus is free.               */
-
-					//printk ( "CBUS:: Channel State: %02X\n", (int)l_cbus[ channel].state );
-					break;
-
-				default:
-
-					/* Illegal values return to IDLE state.     */
-
-					printk ( "CBUS:: Channel State: %02X (illegal)\n", (int)l_cbus[ channel].state );
-					l_cbus[ channel].state = CBUS_IDLE;
-					l_cbus[ channel].request[ queueIndex].reqStatus = CBUS_REQ_IDLE;
-					success = FALSE;
-					break;
-			}
-		}
-		else
-		{
-			printk( "CBUS:: Queue full - Request0: %02X Request1: %02X\n",
-					(int)l_cbus[ channel].request[ 0].reqStatus,
-					(int)l_cbus[ channel].request[ 1].reqStatus);
-		}
-	}
-
-	return( success );
-}
-
-//------------------------------------------------------------------------------
-// Function:    SI_CbusUpdateBusStatus
-// Description: Check the BUS status interrupt register for this channel and
-//              update the channel data as needed.
-//              channel.
-// Parameters:  channel to check
-// Returns:     TRUE    - connected
-//              FALSE   - not connected
-//
-//  Note: This function should be called periodically to update the bus status
-//
-//------------------------------------------------------------------------------
-
-Bool SI_CbusUpdateBusStatus ( byte channel )
-{
-	byte busStatus;
-
-	busStatus = SiIRegioCbusRead( REG_CBUS_BUS_STATUS, channel );
-
-	printk("CBUS status:%x \n",(int)busStatus);
-
-	l_cbus[ channel].connected = (busStatus & BIT_BUS_CONNECTED) != 0;
-
-	printk("CBUS connected:%x \n",(int)l_cbus[ channel].connected);
-	/* Clear the interrupt register bits.   */
-
-	SiIRegioCbusWrite( REG_CBUS_BUS_STATUS, channel, busStatus );
-
-	return( l_cbus[ channel].connected );
-}
-
-//------------------------------------------------------------------------------
-// Function:    SI_CbusInitialize
-// Description: Attempts to intialize the CBUS. If register reads return 0xFF,
-//              it declares error in initialization.
-//              Initializes discovery enabling registers and anything needed in
-//              config register, interrupt masks.
-// Returns:     TRUE if no problem
-//------------------------------------------------------------------------------
-
-Bool SI_CbusInitialize ( void )
-{
-	byte     channel;
-	int	result = STATUS_SUCCESS;
-	int	port = 0;
-	word	devcap_reg;
-	int 		regval;
-
-	memset( &l_cbus, 0, sizeof( l_cbus ));
-	dev_cap_regs_ready_bit = FALSE;
-
-	/* Determine the Port Switch input ports that are selected for MHD  */
-	/* operation and initialize the port to channel decode array.       */
-
-	channel = 0;
-
-	//
-	// Setup local DEVCAP registers for read by the peer
-	//
-	devcap_reg = REG_CBUS_DEVICE_CAP_0;
-	SiIRegioCbusWrite(devcap_reg++, channel, MHD_DEV_ACTIVE);
-	SiIRegioCbusWrite(devcap_reg++, channel, MHD_VERSION);
-	SiIRegioCbusWrite(devcap_reg++, channel, MHD_DEVICE_CATEGORY);
-	SiIRegioCbusWrite(devcap_reg++, channel, 0);  						
-	SiIRegioCbusWrite(devcap_reg++, channel, 0);						
-	SiIRegioCbusWrite(devcap_reg++, channel, MHD_DEV_VID_LINK_SUPPRGB444);
-	SiIRegioCbusWrite(devcap_reg++, channel, MHD_DEV_AUD_LINK_2CH);
-	SiIRegioCbusWrite(devcap_reg++, channel, 0);										// not for source
-	SiIRegioCbusWrite(devcap_reg++, channel, MHD_LOGICAL_DEVICE_MAP);
-	SiIRegioCbusWrite(devcap_reg++, channel, 0);										// not for source
-	SiIRegioCbusWrite(devcap_reg++, channel, MHD_RCP_SUPPORT | MHD_RAP_SUPPORT);		// feature flag
-	SiIRegioCbusWrite(devcap_reg++, channel, 0);
-	SiIRegioCbusWrite(devcap_reg++, channel, 0);										// reserved
-	SiIRegioCbusWrite(devcap_reg++, channel, MHD_SCRATCHPAD_SIZE);
-	SiIRegioCbusWrite(devcap_reg++, channel, MHD_INTERRUPT_SIZE);
-	SiIRegioCbusWrite(devcap_reg++, channel, 0);										//reserved
-
-	if(SiIRegioCbusRead(REG_CBUS_SUPPORT, channel) == 0xff)
-	{
-		// Display all registers for debugging. Only at initialization.
-		printk( "cbus initialization failed\n");
-		cbus_display_registers(0, 0x30);
-		return ERROR_INIT;
-	}
-
-	SiIRegioCbusWrite(REG_CBUS_INTR_ENABLE, channel, (BIT_CONNECT_CHG | BIT_MSC_MSG_RCV | BIT_MSC_XFR_DONE	| BIT_MSC_XFR_ABORT | BIT_MSC_ABORT | BIT_HEARTBEAT_TIMEOUT ));
-	regval = SiIRegioCbusRead(REG_CBUS_LINK_CONTROL_2, channel);
-	regval = (regval | 0x0C);
-	SiIRegioCbusWrite(REG_CBUS_LINK_CONTROL_2, channel, regval);
-
-	// Clear legacy bit on Wolverine TX.
-	regval = SiIRegioCbusRead( REG_MSC_TIMEOUT_LIMIT, channel );
-	SiIRegioCbusWrite( REG_MSC_TIMEOUT_LIMIT, channel, (regval & MSC_TIMEOUT_LIMIT_MSB_MASK));
-
-	// Set NMax to 1
-	SiIRegioCbusWrite( REG_CBUS_LINK_CONTROL_1, channel, 0x01);
-
-	printk( "cbus_initialize. Poll interval = %d ms. CBUS Connected = %d\n", (int)CBUS_FW_INTR_POLL_MILLISECS, (int)SI_CbusChannelConnected(channel));
-
-	return result;
-}
-
-
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <plat/pm.h>
+#include <asm/irq.h>
+#include <linux/delay.h>
+#include <plat/gpio-cfg.h>
+#include <mach/regs-gpio.h>
+#include <mach/regs-clock.h>
+
+#include <linux/syscalls.h> 
+#include <linux/fcntl.h> 
+#include <asm/uaccess.h> 
+#include <linux/types.h>
+
+
+#include "Common_Def.h"
+#include "si_apiCbus.h"
+#include "si_RegioCbus.h"
+#include "si_cbusDefs.h"
+
+
+#define MHD_DEVICE_CATEGORY             (MHD_DEV_CAT_SOURCE)
+#define	MHD_LOGICAL_DEVICE_MAP			(MHD_DEV_LD_AUDIO | MHD_DEV_LD_VIDEO | MHD_DEV_LD_MEDIA | MHD_DEV_LD_GUI )
+
+#define CONFIG_CHECK_DDC_ABORT		0
+
+#define CBUS_FW_INTR_POLL_MILLISECS     50      // wait this to issue next status poll i2c read
+
+
+//------------------------------------------------------------------------------
+//  Global data
+//------------------------------------------------------------------------------
+static byte msc_return_cmd;
+static byte msc_return_value;
+
+static cbusChannelState_t l_cbus[MHD_MAX_CHANNELS];
+Bool dev_cap_regs_ready_bit;
+
+//------------------------------------------------------------------------------
+// Function:    SI_CbusRequestStatus 
+// Description: Return the status of the message currently in process, if any.
+// Parameters:  channel - CBUS channel to check
+// Returns:     CBUS_REQ_IDLE, CBUS_REQ_PENDING, CBUS_REQ_SENT, or CBUS_REQ_RECEIVED
+//------------------------------------------------------------------------------
+
+byte SI_CbusRequestStatus ( byte channel )
+{
+	return( l_cbus[ channel].request[ l_cbus[ channel].activeIndex ].reqStatus );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SI_CbusRequestSetIdle
+// Description: Set the active request to the specified state 
+// Parameters:  channel - CBUS channel to set
+//------------------------------------------------------------------------------
+
+void SI_CbusRequestSetIdle ( byte channel, byte newState )
+{
+	l_cbus[ channel].request[ l_cbus[ channel].activeIndex ].reqStatus = newState;
+}
+
+//------------------------------------------------------------------------------
+// Function:    SI_CbusRequestData 
+// Description: Return a pointer to the currently active request structure
+// Parameters:  channel - CBUS channel.
+// Returns:     Pointer to a cbus_req_t structure.
+//------------------------------------------------------------------------------
+
+cbus_req_t *SI_CbusRequestData ( byte channel )
+{
+	return( &l_cbus[ channel].request[ l_cbus[ channel].activeIndex ] );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SI_CbusChannelConnected
+// Description: Return the CBUS channel connected status for this channel.
+// Returns:     TRUE if connected. 
+//              FALSE if disconnected.
+//------------------------------------------------------------------------------
+
+Bool SI_CbusChannelConnected (byte channel)
+{
+	return( l_cbus[ channel].connected );
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION         :   cbus_display_registers
+//
+// PURPOSE          :   For debugging purposes, show salient register on UART
+//
+// INPUT PARAMETERS :   startFrom	= First register to show
+//						howmany		= number of registers to show.
+//									This will be rounded to next multiple of 4.
+//
+// OUTPUT PARAMETERS:   None.
+//
+// RETURNED VALUES  :   None
+//
+// GLOBALS USED     :
+//
+////////////////////////////////////////////////////////////////////////////////
+void cbus_display_registers(int startfrom, int howmany)
+{
+	int	regnum, regval, i;
+	int end_at;
+
+	end_at = startfrom + howmany;
+
+	for(regnum = startfrom; regnum <= end_at;)
+	{
+		for (i = 0 ; i <= 7; i++, regnum++)
+		{
+			regval = SiIRegioCbusRead(regnum, 0);
+		}
+	}
+}
+
+//------------------------------------------------------------------------------
+// Function:    CBusProcessConnectionChange
+// Description: Process a connection change interrupt
+// Returns:     
+//------------------------------------------------------------------------------
+
+static byte CBusProcessConnectionChange ( int channel )
+{
+	channel = 0;
+
+	return( ERROR_CBUS_TIMEOUT );
+}
+
+//------------------------------------------------------------------------------
+// Function:    CBusProcessFailureInterrupts
+// Description: Check for and process any failure interrupts.
+// Returns:     SUCCESS or ERROR_CBUS_ABORT
+//------------------------------------------------------------------------------
+
+static byte CBusProcessFailureInterrupts ( byte channel, byte intStatus, byte inResult )
+{
+
+	byte result          = inResult;
+	byte mscAbortReason  = STATUS_SUCCESS;
+	byte ddcAbortReason  = STATUS_SUCCESS;
+
+	/* At this point, we only need to look at the abort interrupts. */
+
+	intStatus &=  /*BIT_DDC_ABORT |*/ BIT_MSC_ABORT | BIT_MSC_XFR_ABORT;
+
+	if ( intStatus )
+	{
+		result = ERROR_CBUS_ABORT;		// No Retry will help
+
+		/* If transfer abort or MSC abort, clear the abort reason register. */
+
+		if( intStatus & BIT_CONNECT_CHG )
+		{
+			printk("CBUS Connection Change Detected\n");
+		}
+		if( intStatus & BIT_DDC_ABORT )
+		{
+			ddcAbortReason = SiIRegioCbusRead( REG_DDC_ABORT_REASON, channel );
+			printk("CBUS DDC ABORT happened, reason:: %02X\n", (int)(ddcAbortReason));
+		}
+
+		if ( intStatus & BIT_MSC_XFR_ABORT )
+		{
+			mscAbortReason = SiIRegioCbusRead( REG_PRI_XFR_ABORT_REASON, channel );
+
+			printk( "CBUS:: MSC Transfer ABORTED. Clearing 0x0D\n");
+			SiIRegioCbusWrite( REG_PRI_XFR_ABORT_REASON, channel, 0xFF );
+		}
+		if ( intStatus & BIT_MSC_ABORT )
+		{
+			printk( "CBUS:: MSC Peer sent an ABORT. Clearing 0x0E\n");
+			SiIRegioCbusWrite( REG_CBUS_PRI_FWR_ABORT_REASON, channel, 0xFF );
+		}
+
+		// Now display the abort reason.
+
+		if ( mscAbortReason != 0 )
+		{
+			printk( "CBUS:: Reason for ABORT is ....0x%02X = ", (int)mscAbortReason );
+
+			if ( mscAbortReason & CBUSABORT_BIT_REQ_MAXFAIL)
+			{
+				printk("Requestor MAXFAIL - retry threshold exceeded\n");
+			}
+			if ( mscAbortReason & CBUSABORT_BIT_PROTOCOL_ERROR)
+			{
+				printk ("Protocol Error\n");
+			}
+			if ( mscAbortReason & CBUSABORT_BIT_REQ_TIMEOUT)
+			{
+				printk ("Requestor translation layer timeout\n");
+			}
+			if ( mscAbortReason & CBUSABORT_BIT_PEER_ABORTED)
+			{
+				printk ("Peer sent an abort\n");
+			}
+			if ( mscAbortReason & CBUSABORT_BIT_UNDEFINED_OPCODE)
+			{
+				printk ("Undefined opcode\n");
+			}
+		}
+	}
+
+	/* Clear any failure interrupt that we received.    */
+	SiIRegioCbusWrite( REG_CBUS_INTR_STATUS, channel, intStatus );
+
+	return( result );
+}
+
+//------------------------------------------------------------------------------
+// Function:    CBusProcessSubCommand
+// Description: Process a sub-command (RCP) or sub-command response (RCPK).
+//              Modifies channel state as necessary.
+// Parameters:  channel - CBUS channel that received the command.
+// Returns:     SUCCESS or CBUS_SOFTWARE_ERRORS_t
+//              If SUCCESS, command data is returned in l_cbus[channel].msgData[i]
+//------------------------------------------------------------------------------
+
+static byte CBusProcessSubCommand ( int channel, byte vs_cmd, byte vs_data )
+{
+	/* Save RCP message data in the channel request structure to be returned    */
+	/* to the upper level.                                                      */
+
+	l_cbus[channel].request[l_cbus[channel].activeIndex].command = vs_cmd;
+	l_cbus[channel].request[l_cbus[channel].activeIndex].offsetData = vs_data;
+
+	/* Parse it a little before telling the upper level about it.   */
+
+	switch (vs_cmd) {
+	case MHD_MSC_MSG_RCP:
+	/* Received a Remote Control Protocol message.  Signal that */
+	/* it has been received if we are in the right state,       */
+	/* otherwise, it is a bogus message.  Don't send RCPK now   */
+	/* because the upper layer must validate the command.       */
+		printk ("CBUS:: Received <-- MHD_MSC_MSG_RCP::"
+				" cbus state = %02X\n",
+				(int)(l_cbus[ channel].state));
+		switch (l_cbus[channel].state) {
+		case CBUS_IDLE:
+		case CBUS_SENT:
+			l_cbus[channel].request[l_cbus[channel].activeIndex ].reqStatus = CBUS_REQ_RECEIVED;
+			l_cbus[ channel].state = CBUS_RECEIVED;
+			break;
+		default:
+			l_cbus[ channel].state = CBUS_IDLE;
+			break;
+		}
+
+		break;
+	case MHD_MSC_MSG_RCPK:
+		printk ("CBUS:: Received <-- MHD_MSC_MSG_RCPK\n");
+		break;
+	case MHD_MSC_MSG_RCPE:
+		printk ("CBUS:: Received <-- MHD_MSC_MSG_RCPE\n");
+		break;
+	case MHD_MSC_MSG_RAP:
+		printk ("CBUS:: Received <-- MHD_MSC_MSG_RAP::"
+			" cbus state = %02X\n",
+			(int)(l_cbus[ channel].state));
+
+		switch ( l_cbus[ channel].state ) {
+		case CBUS_IDLE:
+		case CBUS_SENT:
+			l_cbus[ channel].request[ l_cbus[ channel].activeIndex ].reqStatus = CBUS_REQ_RECEIVED;
+			l_cbus[ channel].state = CBUS_RECEIVED;
+			break;
+		default:
+			l_cbus[ channel].state = CBUS_IDLE;
+			break;
+		}
+		break;
+	case MHD_MSC_MSG_RAPK:
+		printk ("CBUS:: Received <-- MHD_MSC_MSG_RAPK\n");
+		break;
+
+#if MSC_TESTER
+	case MHD_MSC_MSG_NEW_TESTER:
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_NEW_TESTER_REPLY, 0x00);
+		break;
+	case MHD_MSC_MSG_NEW_TESTER_REPLY:
+		msc_return_cmd = vs_cmd;
+		break;
+	case MHD_MSC_MSG_STATE_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_0, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_STATE_CHANGE_REPLY, 0x00);
+		break;
+	case MHD_MSC_MSG_DEVCAP0_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_0, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_0, channel);
+		break;
+	case MHD_MSC_MSG_DEVCAP1_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_1, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_1, channel);
+		break;
+	case MHD_MSC_MSG_DEVCAP2_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_2, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_2, channel);
+		break;
+	case MHD_MSC_MSG_DEVCAP3_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_3, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_3, channel);
+		break;
+	case MHD_MSC_MSG_DEVCAP4_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_4, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_4, channel);
+		break;
+	case MHD_MSC_MSG_DEVCAP5_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_5, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_5, channel);
+		break;
+	case MHD_MSC_MSG_DEVCAP6_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_6, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_6, channel);
+		break;
+
+	case MHD_MSC_MSG_DEVCAP7_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_7, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_7, channel);
+		break;
+	case MHD_MSC_MSG_DEVCAP8_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_8, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_8, channel);
+		break;
+	case MHD_MSC_MSG_DEVCAP9_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_9, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_9, channel);
+		break;		
+	case MHD_MSC_MSG_DEVCAP10_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_A, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_A, channel);
+		break;		
+	case MHD_MSC_MSG_DEVCAP11_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_B, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_B, channel);
+		break;
+	case MHD_MSC_MSG_DEVCAP12_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_C, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_C, channel);
+		break;
+	case MHD_MSC_MSG_DEVCAP13_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_D, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_D, channel);
+		break;
+	case MHD_MSC_MSG_DEVCAP14_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_E, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_E, channel);
+		break;
+	case MHD_MSC_MSG_DEVCAP15_CHANGE:
+		SiIRegioCbusWrite( REG_CBUS_DEVICE_CAP_F, channel, vs_data );
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_DEVCAP_CHANGE_REPLY, SiIRegioCbusRead( REG_CBUS_DEVICE_CAP_F, channel);
+		break;
+	case MHD_MSC_MSG_SET_INT0_CHECK:
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_SET_INT_REPLY, SiIRegioCbusRead( REG_CBUS_SET_INT_0, channel );
+		break;
+	case MHD_MSC_MSG_SET_INT1_CHECK:
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_SET_INT_REPLY, SiIRegioCbusRead( REG_CBUS_SET_INT_1, channel );
+		break;
+	case MHD_MSC_MSG_SET_INT2_CHECK:
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_SET_INT_REPLY, SiIRegioCbusRead( REG_CBUS_SET_INT_2, channel );
+		break;
+	case MHD_MSC_MSG_SET_INT3_CHECK:
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_SET_INT_REPLY, SiIRegioCbusRead( REG_CBUS_SET_INT_3, channel );
+		break;
+	case MHD_MSC_MSG_WRITE_STAT0_CHECK:
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_WRITE_STAT_REPLY, SiIRegioCbusRead( REG_CBUS_WRITE_STAT_0, channel );
+		break;
+	case MHD_MSC_MSG_WRITE_STAT1_CHECK:
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_WRITE_STAT_REPLY, SiIRegioCbusRead( REG_CBUS_WRITE_STAT_1, channel );
+		break;
+	case MHD_MSC_MSG_WRITE_STAT2_CHECK:
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_WRITE_STAT_REPLY, SiIRegioCbusRead( REG_CBUS_WRITE_STAT_2, channel );
+		break;
+	case MHD_MSC_MSG_WRITE_STAT3_CHECK:
+		SI_CbusMscMsgSubCmdSend(channel, MHD_MSC_MSG_WRITE_STAT_REPLY, SiIRegioCbusRead( REG_CBUS_WRITE_STAT_3, channel );
+		break;
+	case MHD_MSC_MSG_STATE_CHANGE_REPLY:
+		msc_return_cmd = vs_cmd;
+		break;
+	case MHD_MSC_MSG_DEVCAP_CHANGE_REPLY:
+		msc_return_cmd = vs_cmd;
+		break;	
+	case MHD_MSC_MSG_SET_INT_REPLY:
+		msc_return_value = vs_data;
+		msc_return_cmd = vs_cmd;
+		break;
+	case MHD_MSC_MSG_WRITE_STAT_REPLY:
+		msc_return_value = vs_data;
+		msc_return_cmd = vs_cmd;
+		break;
+#endif
+	default:
+		break;
+	}
+
+	printk ("CBUS:: MSG_MSC CMD:  0x%02X\n", (int)vs_cmd );
+	printk ("CBUS:: MSG_MSC Data: 0x%02X\n\n", (int)vs_data );
+
+	return( STATUS_SUCCESS );
+}
+
+#if MSC_TESTER
+void SI_CbusMscResetReturnCmd()
+{
+	msc_return_cmd = 0;
+}
+
+void SI_CbusMscResetReturnValue()
+{
+	msc_return_value = 0;
+}
+
+byte	SI_CbusMscReturnCmd()
+{
+	return msc_return_cmd;
+}
+
+byte	SI_CbusMscReturnValue()
+{
+	return msc_return_value;
+}
+#endif // MSC_TESTER
+
+
+//------------------------------------------------------------------------------
+// Function:    CBusWriteCommand
+// Description: Write the specified Sideband Channel command to the CBUS.
+//              Command can be a MSC_MSG command (RCP/MCW/RAP), or another command 
+//              such as READ_DEVCAP, GET_VENDOR_ID, SET_HPD, CLR_HPD, etc.
+//
+// Parameters:  channel - CBUS channel to write
+//              pReq    - Pointer to a cbus_req_t structure containing the 
+//                        command to write
+// Returns:     TRUE    - successful write
+//              FALSE   - write failed
+//------------------------------------------------------------------------------
+
+static Bool CBusWriteCommand ( int channel, cbus_req_t *pReq  )
+{
+	byte i, startbit;
+	Bool  success = TRUE;
+
+	printk ("CBUS:: Sending MSC command %02X, %02X, %02X\n", (int)pReq->command, (int)pReq->msgData[0], (int)pReq->msgData[1]);
+
+	/****************************************************************************************/
+	/* Setup for the command - write appropriate registers and determine the correct        */
+	/*                         start bit.                                                   */
+	/****************************************************************************************/
+
+	// Set the offset and outgoing data byte right away
+	SiIRegioCbusWrite( REG_CBUS_PRI_ADDR_CMD, channel, pReq->offsetData); 	// set offset
+	SiIRegioCbusWrite( REG_CBUS_PRI_WR_DATA_1ST, channel, pReq->msgData[0] );
+
+	startbit = 0x00;
+	switch ( pReq->command )
+	{
+		case MHD_SET_INT:	// Set one interrupt register = 0x60
+			SiIRegioCbusWrite( REG_CBUS_PRI_ADDR_CMD, channel, pReq->offsetData + 0x20 ); 	// set offset
+			startbit = MSC_START_BIT_WRITE_REG;
+			break;
+
+		case MHD_WRITE_STAT:	// Write one status register = 0x60 | 0x80
+			SiIRegioCbusWrite( REG_CBUS_PRI_ADDR_CMD, channel, pReq->offsetData + 0x30 ); 	// set offset
+			startbit = MSC_START_BIT_WRITE_REG;
+			break;
+
+		case MHD_READ_DEVCAP:	// Read one device capability register = 0x61
+			startbit = MSC_START_BIT_READ_REG;
+			break;
+
+		case MHD_GET_STATE:			// 0x62 - Used for heartbeat
+		case MHD_GET_VENDOR_ID:		// 0x63 - for vendor id	
+		case MHD_SET_HPD:			// 0x64	- Set Hot Plug Detect in follower
+		case MHD_CLR_HPD:			// 0x65	- Clear Hot Plug Detect in follower
+		case MHD_GET_SC1_ERRORCODE:		// 0x69	- Get channel 1 command error code
+		case MHD_GET_DDC_ERRORCODE:		// 0x6A	- Get DDC channel command error code.
+		case MHD_GET_MSC_ERRORCODE:		// 0x6B	- Get MSC command error code.
+		case MHD_GET_SC3_ERRORCODE:		// 0x6D	- Get channel 3 command error code.
+			SiIRegioCbusWrite( REG_CBUS_PRI_ADDR_CMD, channel, pReq->command );
+			startbit = MSC_START_BIT_MSC_CMD;
+			break;
+
+		case MHD_MSC_MSG:
+			SiIRegioCbusWrite( REG_CBUS_PRI_WR_DATA_2ND, channel, pReq->msgData[1] );
+			SiIRegioCbusWrite( REG_CBUS_PRI_ADDR_CMD, channel, pReq->command );
+			startbit = MSC_START_BIT_VS_CMD;
+			break;
+
+		case MHD_WRITE_BURST:
+			SiIRegioCbusWrite( REG_CBUS_PRI_ADDR_CMD, channel, pReq->offsetData + 0x40 );
+			SiIRegioCbusWrite( REG_MSC_WRITE_BURST_LEN, channel, pReq->length -1 );
+			printk ("CBUS:: pReq->length: 0x%02X\n\n", (int)pReq->length );
+
+			// Now copy all bytes from array to local scratchpad
+
+			for ( i = 0; i < pReq->length; i++ )
+			{
+				SiIRegioCbusWrite( REG_CBUS_SCRATCHPAD_0 + i, channel, pReq->msgData[i] );
+			}
+			startbit = MSC_START_BIT_WRITE_BURST;
+			break;
+
+		default:
+			success = FALSE;
+			break;
+	}
+
+	/****************************************************************************************/
+	/* Trigger the CBUS command transfer using the determined start bit.                    */
+	/****************************************************************************************/
+
+	if( success )
+	{
+		SiIRegioCbusWrite( REG_CBUS_PRI_START, channel, startbit );
+	}
+
+	return( success );
+}
+
+//------------------------------------------------------------------------------
+// Function:    CBusConmmandGetNextInQueue
+// Description: find out the next command in the queue to be sent
+// Parameters:  channel - CBUS channel that received the command.
+// Returns:     the index of the next command
+//------------------------------------------------------------------------------
+
+static byte CBusConmmandGetNextInQueue( byte channel )
+{
+	byte   result = STATUS_SUCCESS;
+
+	byte nextIndex = (l_cbus[ channel].activeIndex == (CBUS_MAX_COMMAND_QUEUE - 1)) ? 
+		0 : (l_cbus[ channel].activeIndex + 1)	;
+
+
+	while ( l_cbus[ channel].request[ nextIndex].reqStatus != CBUS_REQ_PENDING )
+	{
+		if ( nextIndex == l_cbus[ channel].activeIndex )   //searched whole queue, no pending 
+			return 0;	
+
+		nextIndex = ( nextIndex == (CBUS_MAX_COMMAND_QUEUE - 1)) ? 
+			0 : (nextIndex + 1);
+	}
+
+	printk("channel:%x nextIndex:%x \n",(int)channel,(int)nextIndex);
+
+	if ( CBusWriteCommand( channel, &l_cbus[ channel].request[ nextIndex] ) )
+	{
+		l_cbus[ channel].request[ nextIndex].reqStatus = CBUS_REQ_SENT;
+		l_cbus[ channel].activeIndex = nextIndex;						
+		l_cbus[ channel].state = CBUS_SENT;					
+	}
+	else
+	{
+		printk ( "CBUS:: CBusWriteCommand failed\n" );
+		result = ERROR_WRITE_FAILED;
+	}
+
+	return result;
+
+}
+
+//------------------------------------------------------------------------------
+// Function:    CBusResetToIdle
+// Description: Set the specified channel state to IDLE. Clears any messages that
+//              are in progress or queued.  Usually used if a channel connection 
+//              changed or the channel heartbeat has been lost.
+// Parameters:  channel - CBUS channel to reset
+//------------------------------------------------------------------------------
+
+static void CBusResetToIdle ( byte channel )
+{
+	byte queueIndex;
+
+	l_cbus[ channel].state = CBUS_IDLE;
+
+	for ( queueIndex = 0; queueIndex < CBUS_MAX_COMMAND_QUEUE; queueIndex++ )
+	{
+		l_cbus[ channel].request[ queueIndex].reqStatus = CBUS_REQ_IDLE;
+	}
+}
+
+//------------------------------------------------------------------------------
+// Function:    CBusCheckInterruptStatus
+// Description: If any interrupts on the specified channel are set, process them.
+// Parameters:  channel - CBUS channel to check
+// Returns:     SUCCESS or CBUS_SOFTWARE_ERRORS_t error code.
+//------------------------------------------------------------------------------
+
+static byte CBusCheckInterruptStatus ( byte channel )
+{
+	byte 	intStatus, result;
+	byte     vs_cmd, vs_data;
+	byte 	writeBurstLen 	= 0;
+
+	/* Read CBUS interrupt status.  */
+	intStatus = SiIRegioCbusRead( REG_CBUS_INTR_STATUS, channel );
+	if( intStatus & BIT_MSC_MSG_RCV )
+	{
+		printk("( intStatus & BIT_MSC_MSG_RCV )\n");
+		vs_cmd  = SiIRegioCbusRead( REG_CBUS_PRI_VS_CMD, channel );
+		vs_data = SiIRegioCbusRead( REG_CBUS_PRI_VS_DATA, channel );
+	}
+	SiIRegioCbusWrite( REG_CBUS_INTR_STATUS, channel, intStatus );
+
+	/* Check for interrupts.  */
+
+	result = STATUS_SUCCESS;
+	intStatus &= (~BIT_HEARTBEAT_TIMEOUT);	 //don't check heartbeat
+	if( intStatus != 0 )
+	{
+		if( intStatus & BIT_CONNECT_CHG )
+		{
+			printk("( intStatus & BIT_CONNECT_CHG )\n");
+			/* The connection change interrupt has been received.   */
+			result = CBusProcessConnectionChange( channel );
+			SiIRegioCbusWrite( REG_CBUS_BUS_STATUS, channel, BIT_CONNECT_CHG );
+		}
+
+		if( intStatus & BIT_MSC_XFR_DONE )
+		{
+			printk("( intStatus & BIT_MSC_XFR_DONE )\n");
+			/* A previous MSC sub-command has been acknowledged by the responder.   */
+			/* Does not include MSC MSG commands.                                   */
+
+			l_cbus[ channel].state = CBUS_XFR_DONE;
+
+			/* Save any response data in the channel request structure to be returned    */
+			/* to the upper level.                                                      */
+
+			msc_return_cmd = l_cbus[ channel].request[ l_cbus[ channel].activeIndex ].msgData[0] = 
+				SiIRegioCbusRead( REG_CBUS_PRI_RD_DATA_1ST, channel );
+			msc_return_value = l_cbus[ channel].request[ l_cbus[ channel].activeIndex ].msgData[1] = 
+				SiIRegioCbusRead( REG_CBUS_PRI_RD_DATA_2ND, channel );
+
+			printk ( "\nCBUS:: Transfer Done \n" );
+			printk ("Response data Received:: %02X\n\n", (int)l_cbus[ channel].request[l_cbus[channel].activeIndex].msgData[0]);
+
+			result = STATUS_SUCCESS;
+
+			// Check if we received NACK from Peer
+			writeBurstLen = SiIRegioCbusRead( REG_MSC_WRITE_BURST_LEN, channel );
+			if( writeBurstLen & MSC_REQUESTOR_DONE_NACK )
+			{
+				result = ERROR_NACK_FROM_PEER;
+				printk( "NACK received!!! :: %02X\n", (int)writeBurstLen) ;
+			}
+			result = CBusProcessFailureInterrupts( channel, intStatus, result );
+		}
+
+		if( intStatus & BIT_MSC_MSG_RCV )
+		{
+			printk("( intStatus & BIT_MSC_MSG_RCV )\n");
+			/* Receiving a sub-command, either an actual command or */
+			/* the response to a command we sent.                   */
+			result = CBusProcessSubCommand( channel, vs_cmd, vs_data );
+		}
+	}
+	return( result );
+}
+#if MSC_TESTER
+
+//------------------------------------------------------------------------------
+// Function:    SI_CbusHeartBeat
+// Description:  Enable/Disable Heartbeat
+//------------------------------------------------------------------------------
+
+void SI_CbusHeartBeat ( byte channel, byte enable)
+{
+	byte  value;
+	value = SiIRegioCbusRead( REG_MSC_HEARTBEAT_CONTROL, channel);
+	SiIRegioCbusWrite( REG_MSC_HEARTBEAT_CONTROL, channel, enable ? (value | MSC_HEARTBEAT_ENABLE) : ( value & 0x7F) );
+}
+#endif // MSC_TESTER
+
+//------------------------------------------------------------------------------
+// Function:    SI_CbusMscMsgSubCmdSend
+// Description: Send MSC_MSG (RCP) message to the specified CBUS channel (port)
+//
+// Parameters:  channel     - CBUS channel
+//              vsCommand   - MSC_MSG cmd (RCP, RCPK or RCPE)
+//              cmdData     - MSC_MSG data
+// Returns:     TRUE        - successful queue/write
+//              FALSE       - write and/or queue failed
+//------------------------------------------------------------------------------
+
+Bool SI_CbusMscMsgSubCmdSend ( byte channel, byte vsCommand, byte cmdData )
+{
+	cbus_req_t	req;
+
+	//
+	// Send MSC_MSG command (Vendor Specific command)
+	//
+	req.command     = MHD_MSC_MSG;
+	req.msgData[0]  = vsCommand; 
+	req.msgData[1]  = cmdData; 
+	return( SI_CbusWriteCommand( channel, &req  ));
+}
+
+//------------------------------------------------------------------------------
+// Function:    SI_CbusRcpMessageAck
+// Description: Send RCP_K (acknowledge) message to the specified CBUS channel 
+//              and set the request status to idle.
+//
+// Parameters:  channel     - CBUS channel
+// Returns:     TRUE        - successful queue/write
+//              FALSE       - write and/or queue failed
+//------------------------------------------------------------------------------
+
+Bool SI_CbusRcpMessageAck ( byte channel, byte cmdStatus, byte keyCode )
+{
+
+	SI_CbusRequestSetIdle( channel, CBUS_REQ_IDLE );
+	if(cmdStatus != MHD_MSC_MSG_NO_ERROR)
+	{
+		SI_CbusMscMsgSubCmdSend( channel, MHD_MSC_MSG_RCPE, cmdStatus );
+	}
+	return( SI_CbusMscMsgSubCmdSend( channel, MHD_MSC_MSG_RCPK, keyCode ));
+}
+
+
+//------------------------------------------------------------------------------
+// Function:    SI_CbusRapMessageAck
+// Description: Send RAPK (acknowledge) message to the specified CBUS channel 
+//              and set the request status to idle.
+//
+// Parameters:  channel     - CBUS channel
+// Returns:     TRUE        - successful queue/write
+//              FALSE       - write and/or queue failed
+//------------------------------------------------------------------------------
+
+Bool SI_CbusRapMessageAck ( byte channel, byte cmdStatus )
+{
+	printk("SI_CbusRapMessageAck:%x \n",(int)cmdStatus);  
+	SI_CbusRequestSetIdle( channel, CBUS_REQ_IDLE );
+	return( SI_CbusMscMsgSubCmdSend( channel, MHD_MSC_MSG_RAPK, cmdStatus ));
+}
+
+//------------------------------------------------------------------------------
+// Function:    SI_CbusSendDcapRdyMsg
+// Description: Send a msg to peer informing the devive capability registers are
+//				ready to be read.
+// Parameters:  channel to check
+// Returns:     TRUE    - success
+//              FALSE   - failure
+//------------------------------------------------------------------------------
+Bool SI_CbusSendDcapRdyMsg ( byte channel )
+{
+	//cbus_req_t *pReq; // SIMG old code 
+	cbus_req_t pReq;  //daniel 20101101
+	Bool result = TRUE;
+
+	if( l_cbus[ channel].connected ) 
+	{
+		printk( "SI_CbusSendDcapRdyMsg Called!!\n");
+		//send a msg to peer that the device capability registers are ready to be read.
+		//set DCAP_RDY bit 
+		pReq.command = MHD_WRITE_STAT;
+		pReq.offsetData = 0x00;
+		pReq.msgData[0] = BIT_0;
+		//result = SI_CbusWriteCommand(0, pReq); // SIMG old code 
+		result = SI_CbusWriteCommand(0, &pReq);
+
+		//set DCAP_CHG bit
+		pReq.command = MHD_SET_INT;
+		pReq.offsetData = 0x00;
+		pReq.msgData[0] = BIT_0;
+		//result = SI_CbusWriteCommand(0, pReq); // SIMG old code 
+		result = SI_CbusWriteCommand(0, &pReq);
+
+		dev_cap_regs_ready_bit = TRUE;
+	}
+
+	return result;
+}
+
+
+//------------------------------------------------------------------------------
+// Function:    SI_CbusHandler
+// Description: Check the state of any current CBUS message on specified channel.
+//              Handle responses or failures and send any pending message if 
+//              channel is IDLE.
+// Parameters:  channel - CBUS channel to check, must be in range, NOT 0xFF
+// Returns:     SUCCESS or one of CBUS_SOFTWARE_ERRORS_t
+//------------------------------------------------------------------------------
+
+byte SI_CbusHandler ( byte channel )
+{
+	byte result = STATUS_SUCCESS;
+
+	/* Check the channel interrupt status to see if anybody is  */
+	/* talking to us. If they are, talk back.                   */
+
+	result = CBusCheckInterruptStatus( channel );
+
+	/* Don't bother with the rest if the heart is gone. */
+
+	if ( (result == ERROR_NO_HEARTBEAT) || (result == ERROR_NACK_FROM_PEER) )
+	{
+		printk("SI_CbusHandler:: CBusCheckInterruptStatus returned -->> %02X\n", (int)result);
+		return( result );
+	}
+
+	/* Update the channel state machine as necessary.   */
+
+	switch ( l_cbus[ channel].state )
+	{
+		case CBUS_IDLE:
+			result = CBusConmmandGetNextInQueue( channel );				
+			break;
+
+		case CBUS_SENT:
+			break;
+
+		case CBUS_XFR_DONE:
+			l_cbus[ channel].state      = CBUS_IDLE;
+
+			/* We may be waiting for a response message, but the    */
+			/* request queue is idle.                               */
+			l_cbus[ channel].request[ l_cbus[channel].activeIndex].reqStatus = CBUS_REQ_IDLE;
+			break;
+
+		case CBUS_WAIT_RESPONSE:
+			break;
+
+		case CBUS_RECEIVED:
+			// printk(MSG_ALWAYS, ("SI_CbusHandler:: l_cbus[ channel].state -->> %02X\n", (int)(l_cbus[ channel].state));
+			// printk(MSG_ALWAYS, ("result -->> %02X\n", (int)(result));
+
+			/* Either command or response data has been received.   */
+
+			break;
+
+		default:
+			/* Not a valid state, reset to IDLE and get out with failure. */
+
+			l_cbus[ channel].state = CBUS_IDLE;
+			result = ERROR_INVALID;
+			break;
+	}
+
+	return( result );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SI_CbusWriteCommand
+// Description: Place a command in the CBUS message queue.  If queue was empty,
+//              send the new command immediately.
+//
+// Parameters:  channel - CBUS channel to write
+//              pReq    - Pointer to a cbus_req_t structure containing the 
+//                        command to write
+// Returns:     TRUE    - successful queue/write
+//              FALSE   - write and/or queue failed
+//------------------------------------------------------------------------------
+
+Bool SI_CbusWriteCommand ( byte channel, cbus_req_t *pReq  )
+{
+	byte queueIndex;
+	Bool  success = FALSE;
+
+	if ( l_cbus[ channel].connected )
+	{
+		printk("CBUS Write command\n");
+		/* Copy the request to the queue.   */
+
+		//printk ( "SI_CbusWriteCommand:: Channel State: %02X\n", (int)l_cbus[ channel].state );
+		for ( queueIndex = 0; queueIndex < CBUS_MAX_COMMAND_QUEUE; queueIndex++ )
+		{
+			if ( l_cbus[ channel].request[ queueIndex].reqStatus == CBUS_REQ_IDLE )
+			{
+				/* Found an idle queue entry, copy the request and set to pending.  */
+
+				memcpy( &l_cbus[ channel].request[ queueIndex], pReq, sizeof( cbus_req_t ));
+				l_cbus[ channel].request[ queueIndex].reqStatus = CBUS_REQ_PENDING;
+				success = TRUE;
+				break;
+			}
+		}
+
+		/* If successful at putting the request into the queue, decide  */
+		/* whether it can be sent now or later.                         */
+		printk("state:%x \n",(int)l_cbus[ channel].state);
+		printk("channel:%x queueIndex:%x \n",(int)channel,(int)queueIndex);
+		printk ("CBUS:: Sending MSC command %02X, %02X, %02X\n", (int)pReq->command, (int)pReq->msgData[0], (int)pReq->msgData[1]);
+		if ( success )
+		{
+			switch ( l_cbus[ channel].state )
+			{
+				case CBUS_IDLE:
+				case CBUS_RECEIVED:	   
+					success = CBusConmmandGetNextInQueue( channel );				
+					break;
+				case CBUS_WAIT_RESPONSE:
+				case CBUS_SENT:
+				case CBUS_XFR_DONE:
+
+					/* Another command is in progress, the Handler loop will    */
+					/* send the new command when the bus is free.               */
+
+					//printk ( "CBUS:: Channel State: %02X\n", (int)l_cbus[ channel].state );
+					break;
+
+				default:
+
+					/* Illegal values return to IDLE state.     */
+
+					printk ( "CBUS:: Channel State: %02X (illegal)\n", (int)l_cbus[ channel].state );
+					l_cbus[ channel].state = CBUS_IDLE;
+					l_cbus[ channel].request[ queueIndex].reqStatus = CBUS_REQ_IDLE;
+					success = FALSE;
+					break;
+			}
+		}
+		else
+		{
+			printk( "CBUS:: Queue full - Request0: %02X Request1: %02X\n",
+					(int)l_cbus[ channel].request[ 0].reqStatus,
+					(int)l_cbus[ channel].request[ 1].reqStatus);
+		}
+	}
+
+	return( success );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SI_CbusUpdateBusStatus
+// Description: Check the BUS status interrupt register for this channel and
+//              update the channel data as needed.
+//              channel.
+// Parameters:  channel to check
+// Returns:     TRUE    - connected
+//              FALSE   - not connected
+//
+//  Note: This function should be called periodically to update the bus status
+//
+//------------------------------------------------------------------------------
+
+Bool SI_CbusUpdateBusStatus ( byte channel )
+{
+	byte busStatus;
+
+	busStatus = SiIRegioCbusRead( REG_CBUS_BUS_STATUS, channel );
+
+	printk("CBUS status:%x \n",(int)busStatus);
+
+	l_cbus[ channel].connected = (busStatus & BIT_BUS_CONNECTED) != 0;
+
+	printk("CBUS connected:%x \n",(int)l_cbus[ channel].connected);
+	/* Clear the interrupt register bits.   */
+
+	SiIRegioCbusWrite( REG_CBUS_BUS_STATUS, channel, busStatus );
+
+	return( l_cbus[ channel].connected );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SI_CbusInitialize
+// Description: Attempts to intialize the CBUS. If register reads return 0xFF,
+//              it declares error in initialization.
+//              Initializes discovery enabling registers and anything needed in
+//              config register, interrupt masks.
+// Returns:     TRUE if no problem
+//------------------------------------------------------------------------------
+
+Bool SI_CbusInitialize ( void )
+{
+	byte     channel;
+	int	result = STATUS_SUCCESS;
+	int	port = 0;
+	word	devcap_reg;
+	int 		regval;
+
+	memset( &l_cbus, 0, sizeof( l_cbus ));
+	dev_cap_regs_ready_bit = FALSE;
+
+	/* Determine the Port Switch input ports that are selected for MHD  */
+	/* operation and initialize the port to channel decode array.       */
+
+	channel = 0;
+
+	//
+	// Setup local DEVCAP registers for read by the peer
+	//
+	devcap_reg = REG_CBUS_DEVICE_CAP_0;
+	SiIRegioCbusWrite(devcap_reg++, channel, MHD_DEV_ACTIVE);
+	SiIRegioCbusWrite(devcap_reg++, channel, MHD_VERSION);
+	SiIRegioCbusWrite(devcap_reg++, channel, MHD_DEVICE_CATEGORY);
+	SiIRegioCbusWrite(devcap_reg++, channel, 0);  						
+	SiIRegioCbusWrite(devcap_reg++, channel, 0);						
+	SiIRegioCbusWrite(devcap_reg++, channel, MHD_DEV_VID_LINK_SUPPRGB444);
+	SiIRegioCbusWrite(devcap_reg++, channel, MHD_DEV_AUD_LINK_2CH);
+	SiIRegioCbusWrite(devcap_reg++, channel, 0);										// not for source
+	SiIRegioCbusWrite(devcap_reg++, channel, MHD_LOGICAL_DEVICE_MAP);
+	SiIRegioCbusWrite(devcap_reg++, channel, 0);										// not for source
+	SiIRegioCbusWrite(devcap_reg++, channel, MHD_RCP_SUPPORT | MHD_RAP_SUPPORT);		// feature flag
+	SiIRegioCbusWrite(devcap_reg++, channel, 0);
+	SiIRegioCbusWrite(devcap_reg++, channel, 0);										// reserved
+	SiIRegioCbusWrite(devcap_reg++, channel, MHD_SCRATCHPAD_SIZE);
+	SiIRegioCbusWrite(devcap_reg++, channel, MHD_INTERRUPT_SIZE);
+	SiIRegioCbusWrite(devcap_reg++, channel, 0);										//reserved
+
+	if(SiIRegioCbusRead(REG_CBUS_SUPPORT, channel) == 0xff)
+	{
+		// Display all registers for debugging. Only at initialization.
+		printk( "cbus initialization failed\n");
+		cbus_display_registers(0, 0x30);
+		return ERROR_INIT;
+	}
+
+	SiIRegioCbusWrite(REG_CBUS_INTR_ENABLE, channel, (BIT_CONNECT_CHG | BIT_MSC_MSG_RCV | BIT_MSC_XFR_DONE	| BIT_MSC_XFR_ABORT | BIT_MSC_ABORT | BIT_HEARTBEAT_TIMEOUT ));
+	regval = SiIRegioCbusRead(REG_CBUS_LINK_CONTROL_2, channel);
+	regval = (regval | 0x0C);
+	SiIRegioCbusWrite(REG_CBUS_LINK_CONTROL_2, channel, regval);
+
+	// Clear legacy bit on Wolverine TX.
+	regval = SiIRegioCbusRead( REG_MSC_TIMEOUT_LIMIT, channel );
+	SiIRegioCbusWrite( REG_MSC_TIMEOUT_LIMIT, channel, (regval & MSC_TIMEOUT_LIMIT_MSB_MASK));
+
+	// Set NMax to 1
+	SiIRegioCbusWrite( REG_CBUS_LINK_CONTROL_1, channel, 0x01);
+
+	printk( "cbus_initialize. Poll interval = %d ms. CBUS Connected = %d\n", (int)CBUS_FW_INTR_POLL_MILLISECS, (int)SI_CbusChannelConnected(channel));
+
+	return result;
+}
+
+
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/si_apiCbus.h news/kernel/drivers/media/video/samsung/mhl_v1/si_apiCbus.h
--- kernel/drivers/media/video/samsung/mhl_v1/si_apiCbus.h	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/si_apiCbus.h	2011-06-17 19:41:22.000000000 +0900
@@ -1,335 +1,356 @@
-//***************************************************************************
-//!file     si_apiCbus.h
-//!brief    CBUS API
-//
-// No part of this work may be reproduced, modified, distributed,
-// transmitted, transcribed, or translated into any language or computer
-// format, in any form or by any means without written permission of
-// Silicon Image, Inc., 1060 East Arques Avenue, Sunnyvale, California 94085
-//
-// Copyright 2007-2009, Silicon Image, Inc.  All rights reserved.
-//***************************************************************************/
-
-#ifndef __SI_APICBUS_H__
-#define __SI_APICBUS_H__
-
-
-#include "Common_Def.h"
-#include "si_RegioCbus.h"
-#include "si_cbus_regs.h"
-#include "si_cbusDefs.h"
-
-//------------------------------------------------------------------------------
-// API Manifest Constants
-//------------------------------------------------------------------------------
-
-#define CBUS_NOCHANNEL      0xFF
-#define CBUS_NOPORT         0xFF
-
-enum
-{
-    MHD_MSC_MSG_RCP             = 0x10,     // RCP sub-command
-    MHD_MSC_MSG_RCPK            = 0x11,     // RCP Acknowledge sub-command
-    MHD_MSC_MSG_RCPE            = 0x12,     // RCP Error sub-command
-    MHD_MSC_MSG_RAP             = 0x20,     // Mode Change Warning sub-command
-    MHD_MSC_MSG_RAPK            = 0x21     // MCW Acknowledge sub-command
-};
-
-enum
-{
-	MHD_MSC_MSG_NEW_TESTER	             	= 0x80,
-	MHD_MSC_MSG_NEW_TESTER_REPLY			= 0x81,
-
-  MHD_MSC_MSG_STATE_CHANGE             	= 0x90,
-  MHD_MSC_MSG_STATE_CHANGE_REPLY			= 0x91,
- 
-	MHD_MSC_MSG_DEVCAP0_CHANGE            	= 0xA0,   
-	MHD_MSC_MSG_DEVCAP1_CHANGE            	= 0xA1,    
-	MHD_MSC_MSG_DEVCAP2_CHANGE            	= 0xA2,    
-	MHD_MSC_MSG_DEVCAP3_CHANGE            	= 0xA3,    
-	MHD_MSC_MSG_DEVCAP4_CHANGE            	= 0xA4,    
-	MHD_MSC_MSG_DEVCAP5_CHANGE            	= 0xA5,    
-	MHD_MSC_MSG_DEVCAP6_CHANGE            	= 0xA6,   
-	MHD_MSC_MSG_DEVCAP7_CHANGE            	= 0xA7,   
-	MHD_MSC_MSG_DEVCAP8_CHANGE            	= 0xA8,   
-	MHD_MSC_MSG_DEVCAP9_CHANGE            	= 0xA9,   
-	MHD_MSC_MSG_DEVCAP10_CHANGE            	= 0xAA,    
-	MHD_MSC_MSG_DEVCAP11_CHANGE            	= 0xAB,    
-	MHD_MSC_MSG_DEVCAP12_CHANGE            	= 0xAC,  
-	MHD_MSC_MSG_DEVCAP13_CHANGE            	= 0xAD,   
-	MHD_MSC_MSG_DEVCAP14_CHANGE            	= 0xAE,    
-	MHD_MSC_MSG_DEVCAP15_CHANGE            	= 0xAF,
-    MHD_MSC_MSG_DEVCAP_CHANGE_REPLY			= 0xB0,
-
-	MHD_MSC_MSG_SET_INT0_CHECK				= 0xC0,
-	MHD_MSC_MSG_SET_INT1_CHECK				= 0xC1,
-	MHD_MSC_MSG_SET_INT2_CHECK				= 0xC2,
-	MHD_MSC_MSG_SET_INT3_CHECK				= 0xC3,
-	MHD_MSC_MSG_SET_INT_REPLY				= 0xC4,
-
-	MHD_MSC_MSG_WRITE_STAT0_CHECK			= 0xD0,
-	MHD_MSC_MSG_WRITE_STAT1_CHECK			= 0xD1,
-	MHD_MSC_MSG_WRITE_STAT2_CHECK			= 0xD2,
-	MHD_MSC_MSG_WRITE_STAT3_CHECK			= 0xD3,
-	MHD_MSC_MSG_WRITE_STAT_REPLY			= 0xD4
-};
-
-// RCPK/RCPE sub commands
-enum
-{
-    MHD_MSC_MSG_NO_ERROR        		= 0x00,     // RCP No Error
-    MHD_MSC_MSG_INEFFECTIVE_KEY_CODE  	= 0x01,     // The key code in the RCP sub-command is not recognized
-    MHD_MSC_MSG_RESPONDER_BUSY          = 0x02     // RCP Response busy
-};
-
-//RAPK sub commands
-enum
-{
-    MHD_MSC_MSG_RAP_NO_ERROR        		= 0x00,     // RAP No Error
-    MHD_MSC_MSG_RAP_UNRECOGNIZED_ACT_CODE  	= 0x01,     
-    MHD_MSC_MSG_RAP_UNSUPPORTED_ACT_CODE  	= 0x02,      			
-    MHD_MSC_MSG_RAP_RESPONDER_BUSY   		= 0x03     
-};
-
-enum
-{
-  MHD_RCP_CMD_SELECT          = 0x00,
-  MHD_RCP_CMD_UP              = 0x01,
-  MHD_RCP_CMD_DOWN            = 0x02,
-  MHD_RCP_CMD_LEFT            = 0x03,
-  MHD_RCP_CMD_RIGHT           = 0x04,
-  MHD_RCP_CMD_RIGHT_UP        = 0x05,
-  MHD_RCP_CMD_RIGHT_DOWN      = 0x06,
-  MHD_RCP_CMD_LEFT_UP         = 0x07,
-  MHD_RCP_CMD_LEFT_DOWN       = 0x08,
-  MHD_RCP_CMD_ROOT_MENU       = 0x09,
-  MHD_RCP_CMD_SETUP_MENU      = 0x0A,
-  MHD_RCP_CMD_CONTENTS_MENU   = 0x0B,
-  MHD_RCP_CMD_FAVORITE_MENU   = 0x0C,
-  MHD_RCP_CMD_EXIT            = 0x0D,
-	
-	//0x0E - 0x1F are reserved
-
-	MHD_RCP_CMD_NUM_0           = 0x20,
-  MHD_RCP_CMD_NUM_1           = 0x21,
-  MHD_RCP_CMD_NUM_2           = 0x22,
-  MHD_RCP_CMD_NUM_3           = 0x23,
-  MHD_RCP_CMD_NUM_4           = 0x24,
-  MHD_RCP_CMD_NUM_5           = 0x25,
-  MHD_RCP_CMD_NUM_6           = 0x26,
-  MHD_RCP_CMD_NUM_7           = 0x27,
-  MHD_RCP_CMD_NUM_8           = 0x28,
-  MHD_RCP_CMD_NUM_9           = 0x29,
-
-	MHD_RCP_CMD_DOT             = 0x2A,
-	MHD_RCP_CMD_ENTER           = 0x2B,
-	MHD_RCP_CMD_CLEAR           = 0x2C,
-
-	//0x2D - 0x2F are reserved
-
-  MHD_RCP_CMD_CH_UP           = 0x30,
-  MHD_RCP_CMD_CH_DOWN         = 0x31,
-  MHD_RCP_CMD_PRE_CH          = 0x32,
-  MHD_RCP_CMD_SOUND_SELECT    = 0x33,
-  MHD_RCP_CMD_INPUT_SELECT    = 0x34,
-  MHD_RCP_CMD_SHOW_INFO       = 0x35,
-  MHD_RCP_CMD_HELP            = 0x36,
-  MHD_RCP_CMD_PAGE_UP         = 0x37,
-  MHD_RCP_CMD_PAGE_DOWN       = 0x38,
-
-	//0x39 - 0x40 are reserved
-
-  MHD_RCP_CMD_VOL_UP	        = 0x41,
-  MHD_RCP_CMD_VOL_DOWN        = 0x42,
-  MHD_RCP_CMD_MUTE            = 0x43,
-  MHD_RCP_CMD_PLAY            = 0x44,
-  MHD_RCP_CMD_STOP            = 0x45,
-  MHD_RCP_CMD_PAUSE           = 0x46,
-  MHD_RCP_CMD_RECORD          = 0x47,
-  MHD_RCP_CMD_REWIND          = 0x48,
-  MHD_RCP_CMD_FAST_FWD        = 0x49,
-  MHD_RCP_CMD_EJECT           = 0x4A,
-  MHD_RCP_CMD_FWD             = 0x4B,
-  MHD_RCP_CMD_BKWD            = 0x4C,
-
-	//0x4D - 0x4F are reserved
-
-  MHD_RCP_CMD_ANGLE            = 0x50,
-  MHD_RCP_CMD_SUBPICTURE       = 0x51,
-
-//0x52 - 0x5F are reserved
-
-  MHD_RCP_CMD_PLAY_FUNC       = 0x60,
-  MHD_RCP_CMD_PAUSE_PLAY_FUNC = 0x61,
-  MHD_RCP_CMD_RECORD_FUNC     = 0x62,
-  MHD_RCP_CMD_PAUSE_REC_FUNC  = 0x63,
-  MHD_RCP_CMD_STOP_FUNC       = 0x64,
-MHD_RCP_CMD_MUTE_FUNC       = 0x65,
-  MHD_RCP_CMD_UN_MUTE_FUNC    = 0x66,
-  MHD_RCP_CMD_TUNE_FUNC       = 0x67,
-  MHD_RCP_CMD_MEDIA_FUNC      = 0x68,
-
-//0x69 - 0x70 are reserved
-
-  MHD_RCP_CMD_F1              = 0x71,
-  MHD_RCP_CMD_F2              = 0x72,
-  MHD_RCP_CMD_F3              = 0x73,
-  MHD_RCP_CMD_F4              = 0x74,
-  MHD_RCP_CMD_F5              = 0x75,
-
-//0x76 - 0x7D are reserved
-
-  MHD_RCP_CMD_VS              = 0x7E,
-  MHD_RCP_CMD_RSVD            = 0x7F
-
-};
-
-enum
-{
-  MHD_RAP_CMD_POLL         	= 0x00,
-  MHD_RAP_CMD_CHG_ACTIVE_PWR  = 0x10,
-  MHD_RAP_CMD_CHG_QUIET       = 0x11,
-  MHD_RAP_CMD_END             = 0x12
-};
-
-//
-// MHD spec related defines
-//
-enum
-{
-	MHD_ACK						= 0x33,	// Command or Data byte acknowledge
-	MHD_NACK					= 0x34,	// Command or Data byte not acknowledge
-	MHD_ABORT					= 0x35,	// Transaction abort
-	MHD_WRITE_STAT				= 0x60 | 0x80,	// Write one status register strip top bit
-	MHD_SET_INT					= 0x60,	// Write one interrupt register
-	MHD_READ_DEVCAP				= 0x61,	// Read one register
-	MHD_GET_STATE				= 0x62,	// Read CBUS revision level from follower
-	MHD_GET_VENDOR_ID			= 0x63,	// Read vendor ID value from follower.
-	MHD_SET_HPD					= 0x64,	// Set Hot Plug Detect in follower
-	MHD_CLR_HPD					= 0x65,	// Clear Hot Plug Detect in follower
-	MHD_SET_CAP_ID				= 0x66,	// Set Capture ID for downstream device.
-	MHD_GET_CAP_ID				= 0x67,	// Get Capture ID from downstream device.
-	MHD_MSC_MSG					= 0x68,	// VS command to send RCP sub-commands
-	MHD_GET_SC1_ERRORCODE		= 0x69,	// Get Vendor-Specific command error code.
-	MHD_GET_DDC_ERRORCODE		= 0x6A,	// Get DDC channel command error code.
-	MHD_GET_MSC_ERRORCODE		= 0x6B,	// Get MSC command error code.
-	MHD_WRITE_BURST				= 0x6C,	// Write 1-16 bytes to responder’s scratchpad.
-	MHD_GET_SC3_ERRORCODE		= 0x6D	// Get channel 3 command error code.
-};
-
-enum
-{
-  CBUS_TASK_IDLE,
-  CBUS_TASK_TRANSLATION_LAYER_DONE,
-  CBUS_TASK_WAIT_FOR_RESPONSE
-};
-
-//
-// CBUS module reports these error types
-//
-typedef enum
-{
-  STATUS_SUCCESS = 0,
-  ERROR_CBUS_CAN_RETRY,
-  ERROR_CBUS_ABORT,
-  ERROR_CBUS_TIMEOUT,
-  ERROR_CBUS_LINK_DOWN,
-  ERROR_INVALID,
-  ERROR_INIT,
-  ERROR_WRITE_FAILED,
-  ERROR_NACK_FROM_PEER,
-  ERROR_NO_HEARTBEAT
-
-} CBUS_SOFTWARE_ERRORS_t;
-
-typedef enum
-{
-  CBUS_IDLE           = 0,    // BUS idle
-  CBUS_SENT,                  // Command sent
-  CBUS_XFR_DONE,              // Translation layer complete
-  CBUS_WAIT_RESPONSE,         // Waiting for response
-  CBUS_RECEIVED              // Message received, verify and send ACK
-} CBUS_STATE_t;
-
-typedef enum
-{
-  CBUS_REQ_IDLE       = 0,
-  CBUS_REQ_PENDING,           // Request is waiting to be sent
-  CBUS_REQ_SENT,              // Request has been sent
-  CBUS_REQ_RECEIVED          // Request data has been received
-} CBUS_REQ_t;
-
-//------------------------------------------------------------------------------
-// API typedefs
-//------------------------------------------------------------------------------
-
-//
-// structure to hold command details from upper layer to CBUS module
-//
-typedef struct 
-{
-  byte reqStatus;                      // CBUS_IDLE, CBUS_PENDING
-  byte command;                        // VS_CMD or RCP opcode
-  byte offsetData;                     // Offset of register on CBUS or RCP data
-  byte length;                         // Only applicable to write burst. ignored otherwise.
-  byte msgData[16];   // Pointer to message data area.
-  unsigned char	*pdatabytes;			// pointer for write burst or read many bytes
-} cbus_req_t;
-
-
-
-#define CBUS_MAX_COMMAND_QUEUE      4
-
-typedef struct
-{
-  Bool  connected;      // True if a connected MHD port
-  byte state;          // State of command execution for this channel
-                          // IDLE, WAIT_RESPONSE
-  byte timeout;        // Timer for message response (must be able to indicate at least 3000ms).
-  byte activeIndex;    // Active queue entry.
-  cbus_req_t  request[ CBUS_MAX_COMMAND_QUEUE ];
-} cbusChannelState_t;
-
-//------------------------------------------------------------------------------
-// API Function Templates
-//------------------------------------------------------------------------------
-Bool SI_CbusInitialize( void );
-byte SI_CbusHandler( byte channel );
-
-#if MSC_TESTER
-void SI_CbusHeartBeat( byte chn, byte enable);
-#endif // MSC_TESTER
-
-    /* CBUS Request functions.      */
-byte SI_CbusRequestStatus( byte channel );
-void SI_CbusRequestSetIdle( byte channel, byte newState );
-cbus_req_t* SI_CbusRequestData( byte channel );
-
-    /* CBUS Channel functions.      */
-Bool SI_CbusChannelConnected( byte channel );
-
-    /* RCP Message send functions.  */
-
-Bool SI_CbusMscMsgSubCmdSend( byte channel, byte vsCommand, byte cmdData );
-Bool SI_CbusRcpMessageAck( byte channel, byte cmdStatus, byte keyCode );
-Bool SI_CbusRapMessageAck( byte channel, byte cmdStatus );
-Bool SI_CbusWriteCommand( byte channel, cbus_req_t *pReq );
-Bool SI_CbusUpdateBusStatus( byte channel );
-
-
-#if MSC_TESTER
-
-byte SI_CbusMscReturnCmd();
-byte SI_CbusMscReturnValue();
-void SI_CbusMscResetReturnCmd();
-void SI_CbusMscResetReturnValue();
-
-#endif //MSC_TESTER
-
-	/* looking at the registers */
-void cbus_display_registers(int startfrom, int howmany);
-Bool SI_CbusSendDcapRdyMsg ( byte channel );
-
-
-#endif  // __SI_APICBUS_H__
-
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed ¡°as is¡± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+#ifndef __SI_APICBUS_H__
+#define __SI_APICBUS_H__
+
+
+#include "Common_Def.h"
+#include "si_RegioCbus.h"
+#include "si_cbus_regs.h"
+#include "si_cbusDefs.h"
+
+//------------------------------------------------------------------------------
+// API Manifest Constants
+//------------------------------------------------------------------------------
+
+#define CBUS_NOCHANNEL      0xFF
+#define CBUS_NOPORT         0xFF
+
+enum
+{
+    MHD_MSC_MSG_RCP             = 0x10,     // RCP sub-command
+    MHD_MSC_MSG_RCPK            = 0x11,     // RCP Acknowledge sub-command
+    MHD_MSC_MSG_RCPE            = 0x12,     // RCP Error sub-command
+    MHD_MSC_MSG_RAP             = 0x20,     // Mode Change Warning sub-command
+    MHD_MSC_MSG_RAPK            = 0x21     // MCW Acknowledge sub-command
+};
+
+enum
+{
+	MHD_MSC_MSG_NEW_TESTER	             	= 0x80,
+	MHD_MSC_MSG_NEW_TESTER_REPLY			= 0x81,
+
+  MHD_MSC_MSG_STATE_CHANGE             	= 0x90,
+  MHD_MSC_MSG_STATE_CHANGE_REPLY			= 0x91,
+ 
+	MHD_MSC_MSG_DEVCAP0_CHANGE            	= 0xA0,   
+	MHD_MSC_MSG_DEVCAP1_CHANGE            	= 0xA1,    
+	MHD_MSC_MSG_DEVCAP2_CHANGE            	= 0xA2,    
+	MHD_MSC_MSG_DEVCAP3_CHANGE            	= 0xA3,    
+	MHD_MSC_MSG_DEVCAP4_CHANGE            	= 0xA4,    
+	MHD_MSC_MSG_DEVCAP5_CHANGE            	= 0xA5,    
+	MHD_MSC_MSG_DEVCAP6_CHANGE            	= 0xA6,   
+	MHD_MSC_MSG_DEVCAP7_CHANGE            	= 0xA7,   
+	MHD_MSC_MSG_DEVCAP8_CHANGE            	= 0xA8,   
+	MHD_MSC_MSG_DEVCAP9_CHANGE            	= 0xA9,   
+	MHD_MSC_MSG_DEVCAP10_CHANGE            	= 0xAA,    
+	MHD_MSC_MSG_DEVCAP11_CHANGE            	= 0xAB,    
+	MHD_MSC_MSG_DEVCAP12_CHANGE            	= 0xAC,  
+	MHD_MSC_MSG_DEVCAP13_CHANGE            	= 0xAD,   
+	MHD_MSC_MSG_DEVCAP14_CHANGE            	= 0xAE,    
+	MHD_MSC_MSG_DEVCAP15_CHANGE            	= 0xAF,
+    MHD_MSC_MSG_DEVCAP_CHANGE_REPLY			= 0xB0,
+
+	MHD_MSC_MSG_SET_INT0_CHECK				= 0xC0,
+	MHD_MSC_MSG_SET_INT1_CHECK				= 0xC1,
+	MHD_MSC_MSG_SET_INT2_CHECK				= 0xC2,
+	MHD_MSC_MSG_SET_INT3_CHECK				= 0xC3,
+	MHD_MSC_MSG_SET_INT_REPLY				= 0xC4,
+
+	MHD_MSC_MSG_WRITE_STAT0_CHECK			= 0xD0,
+	MHD_MSC_MSG_WRITE_STAT1_CHECK			= 0xD1,
+	MHD_MSC_MSG_WRITE_STAT2_CHECK			= 0xD2,
+	MHD_MSC_MSG_WRITE_STAT3_CHECK			= 0xD3,
+	MHD_MSC_MSG_WRITE_STAT_REPLY			= 0xD4
+};
+
+// RCPK/RCPE sub commands
+enum
+{
+    MHD_MSC_MSG_NO_ERROR        		= 0x00,     // RCP No Error
+    MHD_MSC_MSG_INEFFECTIVE_KEY_CODE  	= 0x01,     // The key code in the RCP sub-command is not recognized
+    MHD_MSC_MSG_RESPONDER_BUSY          = 0x02     // RCP Response busy
+};
+
+//RAPK sub commands
+enum
+{
+    MHD_MSC_MSG_RAP_NO_ERROR        		= 0x00,     // RAP No Error
+    MHD_MSC_MSG_RAP_UNRECOGNIZED_ACT_CODE  	= 0x01,     
+    MHD_MSC_MSG_RAP_UNSUPPORTED_ACT_CODE  	= 0x02,      			
+    MHD_MSC_MSG_RAP_RESPONDER_BUSY   		= 0x03     
+};
+
+enum
+{
+  MHD_RCP_CMD_SELECT          = 0x00,
+  MHD_RCP_CMD_UP              = 0x01,
+  MHD_RCP_CMD_DOWN            = 0x02,
+  MHD_RCP_CMD_LEFT            = 0x03,
+  MHD_RCP_CMD_RIGHT           = 0x04,
+  MHD_RCP_CMD_RIGHT_UP        = 0x05,
+  MHD_RCP_CMD_RIGHT_DOWN      = 0x06,
+  MHD_RCP_CMD_LEFT_UP         = 0x07,
+  MHD_RCP_CMD_LEFT_DOWN       = 0x08,
+  MHD_RCP_CMD_ROOT_MENU       = 0x09,
+  MHD_RCP_CMD_SETUP_MENU      = 0x0A,
+  MHD_RCP_CMD_CONTENTS_MENU   = 0x0B,
+  MHD_RCP_CMD_FAVORITE_MENU   = 0x0C,
+  MHD_RCP_CMD_EXIT            = 0x0D,
+	
+	//0x0E - 0x1F are reserved
+
+	MHD_RCP_CMD_NUM_0           = 0x20,
+  MHD_RCP_CMD_NUM_1           = 0x21,
+  MHD_RCP_CMD_NUM_2           = 0x22,
+  MHD_RCP_CMD_NUM_3           = 0x23,
+  MHD_RCP_CMD_NUM_4           = 0x24,
+  MHD_RCP_CMD_NUM_5           = 0x25,
+  MHD_RCP_CMD_NUM_6           = 0x26,
+  MHD_RCP_CMD_NUM_7           = 0x27,
+  MHD_RCP_CMD_NUM_8           = 0x28,
+  MHD_RCP_CMD_NUM_9           = 0x29,
+
+	MHD_RCP_CMD_DOT             = 0x2A,
+	MHD_RCP_CMD_ENTER           = 0x2B,
+	MHD_RCP_CMD_CLEAR           = 0x2C,
+
+	//0x2D - 0x2F are reserved
+
+  MHD_RCP_CMD_CH_UP           = 0x30,
+  MHD_RCP_CMD_CH_DOWN         = 0x31,
+  MHD_RCP_CMD_PRE_CH          = 0x32,
+  MHD_RCP_CMD_SOUND_SELECT    = 0x33,
+  MHD_RCP_CMD_INPUT_SELECT    = 0x34,
+  MHD_RCP_CMD_SHOW_INFO       = 0x35,
+  MHD_RCP_CMD_HELP            = 0x36,
+  MHD_RCP_CMD_PAGE_UP         = 0x37,
+  MHD_RCP_CMD_PAGE_DOWN       = 0x38,
+
+	//0x39 - 0x40 are reserved
+
+  MHD_RCP_CMD_VOL_UP	        = 0x41,
+  MHD_RCP_CMD_VOL_DOWN        = 0x42,
+  MHD_RCP_CMD_MUTE            = 0x43,
+  MHD_RCP_CMD_PLAY            = 0x44,
+  MHD_RCP_CMD_STOP            = 0x45,
+  MHD_RCP_CMD_PAUSE           = 0x46,
+  MHD_RCP_CMD_RECORD          = 0x47,
+  MHD_RCP_CMD_REWIND          = 0x48,
+  MHD_RCP_CMD_FAST_FWD        = 0x49,
+  MHD_RCP_CMD_EJECT           = 0x4A,
+  MHD_RCP_CMD_FWD             = 0x4B,
+  MHD_RCP_CMD_BKWD            = 0x4C,
+
+	//0x4D - 0x4F are reserved
+
+  MHD_RCP_CMD_ANGLE            = 0x50,
+  MHD_RCP_CMD_SUBPICTURE       = 0x51,
+
+//0x52 - 0x5F are reserved
+
+  MHD_RCP_CMD_PLAY_FUNC       = 0x60,
+  MHD_RCP_CMD_PAUSE_PLAY_FUNC = 0x61,
+  MHD_RCP_CMD_RECORD_FUNC     = 0x62,
+  MHD_RCP_CMD_PAUSE_REC_FUNC  = 0x63,
+  MHD_RCP_CMD_STOP_FUNC       = 0x64,
+MHD_RCP_CMD_MUTE_FUNC       = 0x65,
+  MHD_RCP_CMD_UN_MUTE_FUNC    = 0x66,
+  MHD_RCP_CMD_TUNE_FUNC       = 0x67,
+  MHD_RCP_CMD_MEDIA_FUNC      = 0x68,
+
+//0x69 - 0x70 are reserved
+
+  MHD_RCP_CMD_F1              = 0x71,
+  MHD_RCP_CMD_F2              = 0x72,
+  MHD_RCP_CMD_F3              = 0x73,
+  MHD_RCP_CMD_F4              = 0x74,
+  MHD_RCP_CMD_F5              = 0x75,
+
+//0x76 - 0x7D are reserved
+
+  MHD_RCP_CMD_VS              = 0x7E,
+  MHD_RCP_CMD_RSVD            = 0x7F
+
+};
+
+enum
+{
+  MHD_RAP_CMD_POLL         	= 0x00,
+  MHD_RAP_CMD_CHG_ACTIVE_PWR  = 0x10,
+  MHD_RAP_CMD_CHG_QUIET       = 0x11,
+  MHD_RAP_CMD_END             = 0x12
+};
+
+//
+// MHD spec related defines
+//
+enum
+{
+	MHD_ACK						= 0x33,	// Command or Data byte acknowledge
+	MHD_NACK					= 0x34,	// Command or Data byte not acknowledge
+	MHD_ABORT					= 0x35,	// Transaction abort
+	MHD_WRITE_STAT				= 0x60 | 0x80,	// Write one status register strip top bit
+	MHD_SET_INT					= 0x60,	// Write one interrupt register
+	MHD_READ_DEVCAP				= 0x61,	// Read one register
+	MHD_GET_STATE				= 0x62,	// Read CBUS revision level from follower
+	MHD_GET_VENDOR_ID			= 0x63,	// Read vendor ID value from follower.
+	MHD_SET_HPD					= 0x64,	// Set Hot Plug Detect in follower
+	MHD_CLR_HPD					= 0x65,	// Clear Hot Plug Detect in follower
+	MHD_SET_CAP_ID				= 0x66,	// Set Capture ID for downstream device.
+	MHD_GET_CAP_ID				= 0x67,	// Get Capture ID from downstream device.
+	MHD_MSC_MSG					= 0x68,	// VS command to send RCP sub-commands
+	MHD_GET_SC1_ERRORCODE		= 0x69,	// Get Vendor-Specific command error code.
+	MHD_GET_DDC_ERRORCODE		= 0x6A,	// Get DDC channel command error code.
+	MHD_GET_MSC_ERRORCODE		= 0x6B,	// Get MSC command error code.
+	MHD_WRITE_BURST				= 0x6C,	// Write 1-16 bytes to responder’s scratchpad.
+	MHD_GET_SC3_ERRORCODE		= 0x6D	// Get channel 3 command error code.
+};
+
+enum
+{
+  CBUS_TASK_IDLE,
+  CBUS_TASK_TRANSLATION_LAYER_DONE,
+  CBUS_TASK_WAIT_FOR_RESPONSE
+};
+
+//
+// CBUS module reports these error types
+//
+typedef enum
+{
+  STATUS_SUCCESS = 0,
+  ERROR_CBUS_CAN_RETRY,
+  ERROR_CBUS_ABORT,
+  ERROR_CBUS_TIMEOUT,
+  ERROR_CBUS_LINK_DOWN,
+  ERROR_INVALID,
+  ERROR_INIT,
+  ERROR_WRITE_FAILED,
+  ERROR_NACK_FROM_PEER,
+  ERROR_NO_HEARTBEAT
+
+} CBUS_SOFTWARE_ERRORS_t;
+
+typedef enum
+{
+  CBUS_IDLE           = 0,    // BUS idle
+  CBUS_SENT,                  // Command sent
+  CBUS_XFR_DONE,              // Translation layer complete
+  CBUS_WAIT_RESPONSE,         // Waiting for response
+  CBUS_RECEIVED              // Message received, verify and send ACK
+} CBUS_STATE_t;
+
+typedef enum
+{
+  CBUS_REQ_IDLE       = 0,
+  CBUS_REQ_PENDING,           // Request is waiting to be sent
+  CBUS_REQ_SENT,              // Request has been sent
+  CBUS_REQ_RECEIVED          // Request data has been received
+} CBUS_REQ_t;
+
+//------------------------------------------------------------------------------
+// API typedefs
+//------------------------------------------------------------------------------
+
+//
+// structure to hold command details from upper layer to CBUS module
+//
+typedef struct 
+{
+  byte reqStatus;                      // CBUS_IDLE, CBUS_PENDING
+  byte command;                        // VS_CMD or RCP opcode
+  byte offsetData;                     // Offset of register on CBUS or RCP data
+  byte length;                         // Only applicable to write burst. ignored otherwise.
+  byte msgData[16];   // Pointer to message data area.
+  unsigned char	*pdatabytes;			// pointer for write burst or read many bytes
+} cbus_req_t;
+
+
+
+#define CBUS_MAX_COMMAND_QUEUE      4
+
+typedef struct
+{
+  Bool  connected;      // True if a connected MHD port
+  byte state;          // State of command execution for this channel
+                          // IDLE, WAIT_RESPONSE
+  byte timeout;        // Timer for message response (must be able to indicate at least 3000ms).
+  byte activeIndex;    // Active queue entry.
+  cbus_req_t  request[ CBUS_MAX_COMMAND_QUEUE ];
+} cbusChannelState_t;
+
+//------------------------------------------------------------------------------
+// API Function Templates
+//------------------------------------------------------------------------------
+Bool SI_CbusInitialize( void );
+byte SI_CbusHandler( byte channel );
+
+#if MSC_TESTER
+void SI_CbusHeartBeat( byte chn, byte enable);
+#endif // MSC_TESTER
+
+    /* CBUS Request functions.      */
+byte SI_CbusRequestStatus( byte channel );
+void SI_CbusRequestSetIdle( byte channel, byte newState );
+cbus_req_t* SI_CbusRequestData( byte channel );
+
+    /* CBUS Channel functions.      */
+Bool SI_CbusChannelConnected( byte channel );
+
+    /* RCP Message send functions.  */
+
+Bool SI_CbusMscMsgSubCmdSend( byte channel, byte vsCommand, byte cmdData );
+Bool SI_CbusRcpMessageAck( byte channel, byte cmdStatus, byte keyCode );
+Bool SI_CbusRapMessageAck( byte channel, byte cmdStatus );
+Bool SI_CbusWriteCommand( byte channel, cbus_req_t *pReq );
+Bool SI_CbusUpdateBusStatus( byte channel );
+
+
+#if MSC_TESTER
+
+byte SI_CbusMscReturnCmd();
+byte SI_CbusMscReturnValue();
+void SI_CbusMscResetReturnCmd();
+void SI_CbusMscResetReturnValue();
+
+#endif //MSC_TESTER
+
+	/* looking at the registers */
+void cbus_display_registers(int startfrom, int howmany);
+Bool SI_CbusSendDcapRdyMsg ( byte channel );
+
+
+#endif  // __SI_APICBUS_H__
+
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/si_cbus.h news/kernel/drivers/media/video/samsung/mhl_v1/si_cbus.h
--- kernel/drivers/media/video/samsung/mhl_v1/si_cbus.h	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/si_cbus.h	2011-06-17 19:41:22.000000000 +0900
@@ -1,19 +1,40 @@
-//***************************************************************************
-//!file     si_cbus.h
-//!brief    si_apiCbus wrapper for multiple chip.
-//
-// No part of this work may be reproduced, modified, distributed,
-// transmitted, transcribed, or translated into any language or computer
-// format, in any form or by any means without written permission of
-// Silicon Image, Inc., 1060 East Arques Avenue, Sunnyvale, California 94085
-//
-// Copyright 2008-2009, Silicon Image, Inc.  All rights reserved.
-//***************************************************************************/
-
-#if	!defined(_CBUS_H)
-#define	_CBUS_H				
-
-extern void CpCbusHandler ( void );
-extern void CpCbusInitialize ( void );
-
-#endif  // _CBUS_H
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+#if	!defined(_CBUS_H)
+#define	_CBUS_H				
+
+extern void CpCbusHandler ( void );
+extern void CpCbusInitialize ( void );
+
+#endif  // _CBUS_H
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/si_cbusDefs.h news/kernel/drivers/media/video/samsung/mhl_v1/si_cbusDefs.h
--- kernel/drivers/media/video/samsung/mhl_v1/si_cbusDefs.h	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/si_cbusDefs.h	2011-06-17 19:41:22.000000000 +0900
@@ -1,160 +1,182 @@
-//***************************************************************************
-//!file     si_cbusDefs.c
-//!brief    CBUS API Definitions
-//
-// No part of this work may be reproduced, modified, distributed,
-// transmitted, transcribed, or translated into any language or computer
-// format, in any form or by any means without written permission of
-// Silicon Image, Inc., 1060 East Arques Avenue, Sunnyvale, California 94085
-//
-// Copyright 2007-2009, Silicon Image, Inc.  All rights reserved.
-//***************************************************************************/
-
-#ifndef __SI_CBUS_DEFS_H__
-#define	__SI_CBUS_DEFS_H__
-
-// Device Power State
-#define MHD_DEV_UNPOWERED		0x00
-#define MHD_DEV_INACTIVE		0x01
-#define MHD_DEV_QUIET			0x03
-#define MHD_DEV_ACTIVE			0x04
-
-// Version that this chip supports
-#define	MHD_VER_MAJOR		(0x01 << 4)	// bits 4..7
-#define	MHD_VER_MINOR		0x00		// bits 0..3
-#define MHD_VERSION						(MHD_VER_MAJOR | MHD_VER_MINOR)
-
-/*
-#define	CBUS_VER_MAJOR		(0x01 << 4)	// bits 4..7
-#define	CBUS_VER_MINOR		0x00		// bits 0..3
-#define		MHD_CBUS_VERSION				(CBUS_VER_MAJOR | CBUS_VER_MINOR)
-*/
-
-//Device Category
-#define	MHD_DEV_CAT_SOURCE					0x00
-#define	MHD_DEV_CAT_SINGLE_INPUT_SINK		0x01
-#define	MHD_DEV_CAT_MULTIPLE_INPUT_SINK		0x02
-#define	MHD_DEV_CAT_UNPOWERED_DONGLE		0x03
-#define	MHD_DEV_CAT_SELF_POWERED_DONGLE		0x04
-#define	MHD_DEV_CAT_HDCP_REPEATER			0x05
-#define	MHD_DEV_CAT_NON_DISPLAY_SINK		0x06
-#define	MHD_DEV_CAT_POWER_NEUTRAL_SINK		0x07
-#define	MHD_DEV_CAT_OTHER					0x80
-
-//Video Link Mode
-#define	MHD_DEV_VID_LINK_SUPPRGB444			0x01
-#define	MHD_DEV_VID_LINK_SUPPYCBCR444		0x02
-#define	MHD_DEV_VID_LINK_SUPPYCBCR422		0x04
-#define	MHD_DEV_VID_LINK_PPIXEL				0x08
-#define	MHD_DEV_VID_LINK_SUPP_ISLANDS		0x10
-
-//Audio Link Mode Support
-#define	MHD_DEV_AUD_LINK_2CH				0x01
-#define	MHD_DEV_AUD_LINK_8CH				0x02
-
-/*
-#define		MHD_POWER_SUPPLY_CAPACITY		16		// 160 mA current
-#define		MHD_POWER_SUPPLY_PROVIDED		16		// 160mA 0r 0 for Wolverine.
-#define		MHD_HDCP_STATUS					0		// Bits set dynamically
-*/
-
-// VIDEO TYPES
-#define		MHD_VT_GRAPHICS					0x00		
-#define		MHD_VT_PHOTO					0x02		
-#define		MHD_VT_CINEMA					0x04		
-#define		MHD_VT_GAMES					0x08		
-#define		MHD_SUPP_VT						0x80		
-
-//Logical Dev Map
-#define	MHD_DEV_LD_DISPLAY					(0x01 << 0)
-#define	MHD_DEV_LD_VIDEO					(0x01 << 1)
-#define	MHD_DEV_LD_AUDIO					(0x01 << 2)
-#define	MHD_DEV_LD_MEDIA					(0x01 << 3)
-#define	MHD_DEV_LD_TUNER					(0x01 << 4)
-#define	MHD_DEV_LD_RECORD					(0x01 << 5)
-#define	MHD_DEV_LD_SPEAKER					(0x01 << 6)
-#define	MHD_DEV_LD_GUI						(0x01 << 7)
-
-//Bandwidth
-#define	MHD_BANDWIDTH_LIMIT					22		// 225 MHz
-
-//Feature Support
-#define	MHD_RCP_SUPPORT						0x01
-#define	MHD_RAP_SUPPORT						0x02
-
-
-//#define		MHD_DEVCAP_SIZE				16
-#define		MHD_INTERRUPT_SIZE				4
-//#define		MHD_STATUS_SIZE				4
-#define		MHD_SCRATCHPAD_SIZE				16
-#define		MHD_MAX_BUFFER_SIZE				MHD_SCRATCHPAD_SIZE	// manually define highest number
-//------------------------------------------------------------------------------
-//
-// MHD Specs defined registers in device capability set
-//
-//
-typedef struct {
-	unsigned char	mhd_devcap_version;					// 0x00
-	unsigned char	mhd_devcap_cbus_version;			// 0x01
-	unsigned char	mhd_devcap_device_category;			// 0x02
-	unsigned char	mhd_devcap_power_supply_capacity;	// 0x03
-   	unsigned char	mhd_devcap_power_supply_provided;	// 0x04
-   	unsigned char	mhd_devcap_video_link_mode_support;	// 0x05
-   	unsigned char	mhd_devcap_audio_link_mode_support;	// 0x06
-   	unsigned char	mhd_devcap_hdcp_status;				// 0x07
-   	unsigned char	mhd_devcap_logical_device_map;		// 0x08
-   	unsigned char	mhd_devcap_link_bandwidth_limit;	// 0x09
-   	unsigned char	mhd_devcap_reserved_1;				// 0x0a
-   	unsigned char	mhd_devcap_reserved_2;				// 0x0b
-   	unsigned char	mhd_devcap_reserved_3;				// 0x0c
-   	unsigned char	mhd_devcap_scratchpad_size;			// 0x0d
-   	unsigned char	mhd_devcap_interrupt_size;			// 0x0e
-   	unsigned char	mhd_devcap_devcap_size;				// 0x0f
-
-} mhd_devcap_t;
-//------------------------------------------------------------------------------
-//
-// MHD Specs defined registers for interrupts
-//
-//
-typedef struct {
-
-	unsigned char	mhd_intr_0;		// 0x00
-	unsigned char	mhd_intr_1;		// 0x01
-	unsigned char	mhd_intr_2;		// 0x02
-	unsigned char	mhd_intr_3;		// 0x03
-
-} mhd_interrupt_t;
-//------------------------------------------------------------------------------
-//
-// MHD Specs defined registers for status
-//
-//
-typedef struct {
-
-	unsigned char	mhd_status_0;	// 0x00
-	unsigned char	mhd_status_1;	// 0x01
-	unsigned char	mhd_status_2;	// 0x02
-	unsigned char	mhd_status_3;	// 0x03
-
-} mhd_status_t;
-//------------------------------------------------------------------------------
-//
-// MHD Specs defined registers for local scratchpad registers
-//
-//
-typedef struct {
-
-	unsigned char	mhd_scratchpad[16];
-
-} mhd_scratchpad_t;
-//------------------------------------------------------------------------------
-
-/*Daniel added */
-#define SINK_DEV_TYPE 0x01
-#define SOURCE_DEV_TYPE 0x02
-#define Dongle_DEV_TYPE 0x03
-#define POW_EN_DEV_TYPE 0x10
-
-//------- END OF DEFINES -------------
-#endif	// __SI_CBUS_DEFS_H__
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+
+#ifndef __SI_CBUS_DEFS_H__
+#define	__SI_CBUS_DEFS_H__
+
+// Device Power State
+#define MHD_DEV_UNPOWERED		0x00
+#define MHD_DEV_INACTIVE		0x01
+#define MHD_DEV_QUIET			0x03
+#define MHD_DEV_ACTIVE			0x04
+
+// Version that this chip supports
+#define	MHD_VER_MAJOR		(0x01 << 4)	// bits 4..7
+#define	MHD_VER_MINOR		0x00		// bits 0..3
+#define MHD_VERSION						(MHD_VER_MAJOR | MHD_VER_MINOR)
+
+/*
+#define	CBUS_VER_MAJOR		(0x01 << 4)	// bits 4..7
+#define	CBUS_VER_MINOR		0x00		// bits 0..3
+#define		MHD_CBUS_VERSION				(CBUS_VER_MAJOR | CBUS_VER_MINOR)
+*/
+
+//Device Category
+#define	MHD_DEV_CAT_SOURCE					0x00
+#define	MHD_DEV_CAT_SINGLE_INPUT_SINK		0x01
+#define	MHD_DEV_CAT_MULTIPLE_INPUT_SINK		0x02
+#define	MHD_DEV_CAT_UNPOWERED_DONGLE		0x03
+#define	MHD_DEV_CAT_SELF_POWERED_DONGLE		0x04
+#define	MHD_DEV_CAT_HDCP_REPEATER			0x05
+#define	MHD_DEV_CAT_NON_DISPLAY_SINK		0x06
+#define	MHD_DEV_CAT_POWER_NEUTRAL_SINK		0x07
+#define	MHD_DEV_CAT_OTHER					0x80
+
+//Video Link Mode
+#define	MHD_DEV_VID_LINK_SUPPRGB444			0x01
+#define	MHD_DEV_VID_LINK_SUPPYCBCR444		0x02
+#define	MHD_DEV_VID_LINK_SUPPYCBCR422		0x04
+#define	MHD_DEV_VID_LINK_PPIXEL				0x08
+#define	MHD_DEV_VID_LINK_SUPP_ISLANDS		0x10
+
+//Audio Link Mode Support
+#define	MHD_DEV_AUD_LINK_2CH				0x01
+#define	MHD_DEV_AUD_LINK_8CH				0x02
+
+/*
+#define		MHD_POWER_SUPPLY_CAPACITY		16		// 160 mA current
+#define		MHD_POWER_SUPPLY_PROVIDED		16		// 160mA 0r 0 for Wolverine.
+#define		MHD_HDCP_STATUS					0		// Bits set dynamically
+*/
+
+// VIDEO TYPES
+#define		MHD_VT_GRAPHICS					0x00		
+#define		MHD_VT_PHOTO					0x02		
+#define		MHD_VT_CINEMA					0x04		
+#define		MHD_VT_GAMES					0x08		
+#define		MHD_SUPP_VT						0x80		
+
+//Logical Dev Map
+#define	MHD_DEV_LD_DISPLAY					(0x01 << 0)
+#define	MHD_DEV_LD_VIDEO					(0x01 << 1)
+#define	MHD_DEV_LD_AUDIO					(0x01 << 2)
+#define	MHD_DEV_LD_MEDIA					(0x01 << 3)
+#define	MHD_DEV_LD_TUNER					(0x01 << 4)
+#define	MHD_DEV_LD_RECORD					(0x01 << 5)
+#define	MHD_DEV_LD_SPEAKER					(0x01 << 6)
+#define	MHD_DEV_LD_GUI						(0x01 << 7)
+
+//Bandwidth
+#define	MHD_BANDWIDTH_LIMIT					22		// 225 MHz
+
+//Feature Support
+#define	MHD_RCP_SUPPORT						0x01
+#define	MHD_RAP_SUPPORT						0x02
+
+
+//#define		MHD_DEVCAP_SIZE				16
+#define		MHD_INTERRUPT_SIZE				4
+//#define		MHD_STATUS_SIZE				4
+#define		MHD_SCRATCHPAD_SIZE				16
+#define		MHD_MAX_BUFFER_SIZE				MHD_SCRATCHPAD_SIZE	// manually define highest number
+//------------------------------------------------------------------------------
+//
+// MHD Specs defined registers in device capability set
+//
+//
+typedef struct {
+	unsigned char	mhd_devcap_version;					// 0x00
+	unsigned char	mhd_devcap_cbus_version;			// 0x01
+	unsigned char	mhd_devcap_device_category;			// 0x02
+	unsigned char	mhd_devcap_power_supply_capacity;	// 0x03
+   	unsigned char	mhd_devcap_power_supply_provided;	// 0x04
+   	unsigned char	mhd_devcap_video_link_mode_support;	// 0x05
+   	unsigned char	mhd_devcap_audio_link_mode_support;	// 0x06
+   	unsigned char	mhd_devcap_hdcp_status;				// 0x07
+   	unsigned char	mhd_devcap_logical_device_map;		// 0x08
+   	unsigned char	mhd_devcap_link_bandwidth_limit;	// 0x09
+   	unsigned char	mhd_devcap_reserved_1;				// 0x0a
+   	unsigned char	mhd_devcap_reserved_2;				// 0x0b
+   	unsigned char	mhd_devcap_reserved_3;				// 0x0c
+   	unsigned char	mhd_devcap_scratchpad_size;			// 0x0d
+   	unsigned char	mhd_devcap_interrupt_size;			// 0x0e
+   	unsigned char	mhd_devcap_devcap_size;				// 0x0f
+
+} mhd_devcap_t;
+//------------------------------------------------------------------------------
+//
+// MHD Specs defined registers for interrupts
+//
+//
+typedef struct {
+
+	unsigned char	mhd_intr_0;		// 0x00
+	unsigned char	mhd_intr_1;		// 0x01
+	unsigned char	mhd_intr_2;		// 0x02
+	unsigned char	mhd_intr_3;		// 0x03
+
+} mhd_interrupt_t;
+//------------------------------------------------------------------------------
+//
+// MHD Specs defined registers for status
+//
+//
+typedef struct {
+
+	unsigned char	mhd_status_0;	// 0x00
+	unsigned char	mhd_status_1;	// 0x01
+	unsigned char	mhd_status_2;	// 0x02
+	unsigned char	mhd_status_3;	// 0x03
+
+} mhd_status_t;
+//------------------------------------------------------------------------------
+//
+// MHD Specs defined registers for local scratchpad registers
+//
+//
+typedef struct {
+
+	unsigned char	mhd_scratchpad[16];
+
+} mhd_scratchpad_t;
+//------------------------------------------------------------------------------
+
+/*Daniel added */
+#define SINK_DEV_TYPE 0x01
+#define SOURCE_DEV_TYPE 0x02
+#define Dongle_DEV_TYPE 0x03
+#define POW_EN_DEV_TYPE 0x10
+
+//------- END OF DEFINES -------------
+#endif	// __SI_CBUS_DEFS_H__
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/si_cbus_regs.h news/kernel/drivers/media/video/samsung/mhl_v1/si_cbus_regs.h
--- kernel/drivers/media/video/samsung/mhl_v1/si_cbus_regs.h	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/si_cbus_regs.h	2011-06-17 19:41:22.000000000 +0900
@@ -1,169 +1,191 @@
-//***************************************************************************
-//!file     si_cbus_regs.h
-//!brief    MHD/CBUS Registers Manifest Constants.
-//
-// No part of this work may be reproduced, modified, distributed,
-// transmitted, transcribed, or translated into any language or computer
-// format, in any form or by any means without written permission of
-// Silicon Image, Inc., 1060 East Arques Avenue, Sunnyvale, California 94085
-//
-// Copyright 2007-2009, Silicon Image, Inc.  All rights reserved.
-//***************************************************************************/
-#ifndef __SI_CBUS_REGS_H__
-#define __SI_CBUS_REGS_H__
-
-//------------------------------------------------------------------------------
-// NOTE: Register addresses are 16 bit values with page and offset combined.
-//
-// Examples:  0x005 = page 0, offset 0x05
-//            0x1B6 = page 1, offset 0xB6
-//------------------------------------------------------------------------------
-
-//------------------------------------------------------------------------------
-// CBUS 0 Registers in Page 12     (0xE6)
-//------------------------------------------------------------------------------
-
-#define	CBUSREG_MAX_REG					0xFF
-
-#define CBUS_PORT1_OFFSET               0x80
-
-#define	REG_CBUS_INTR_STATUS_2				0x05	//
-#define	REG_CBUS_INTR_ENABLE_2				0x06	//
-
-#define REG_CBUS_SUPPORT                0xC07
-#define	BIT_VS_ENABLE                       0x01    // Enable MSC_MSG
-#define	BIT_PING_ENABLE                     0x02    // Enable PING to test the presence
-
-#define REG_CBUS_INTR_STATUS            0xC08
-#define BIT_CONNECT_CHG                     0x01
-#define BIT_DDC_ABORT                       0x04    // Responder aborted DDC command at translation layer
-#define BIT_MSC_MSG_RCV                     0x08    // Responder sent a VS_MSG packet (response data or command.)
-#define BIT_MSC_XFR_DONE                    0x10    // Responder sent ACK packet (not VS_MSG)
-#define BIT_MSC_XFR_ABORT                   0x20    // Command send aborted on TX side?????
-#define BIT_MSC_ABORT                       0x40    // Responder aborted MSC command at translation layer
-#define BIT_HEARTBEAT_TIMEOUT               0x80    // Responder stopped sending 'alive' messages.
-
-#define REG_CBUS_INTR_ENABLE            0xC09
-
-#define REG_DDC_ABORT_REASON        	0xC0C
-#define REG_CBUS_BUS_STATUS             0xC0A
-#define BIT_BUS_CONNECTED                   0x01
-#define BIT_LA_VAL_CHG                      0x02
-
-#define REG_PRI_XFR_ABORT_REASON        0xC0D
-
-#define REG_CBUS_PRI_FWR_ABORT_REASON   0xC0E
-#define	CBUSABORT_BIT_REQ_MAXFAIL			(0x01 << 0)
-#define	CBUSABORT_BIT_PROTOCOL_ERROR		(0x01 << 1)
-#define	CBUSABORT_BIT_REQ_TIMEOUT			(0x01 << 2)
-#define	CBUSABORT_BIT_UNDEFINED_OPCODE		(0x01 << 3)
-#define	CBUSSTATUS_BIT_CONNECTED			(0x01 << 6)
-#define	CBUSABORT_BIT_PEER_ABORTED			(0x01 << 7)
-
-#define REG_CBUS_PRI_START              0xC12
-#define BIT_TRANSFER_PVT_CMD                0x01
-#define BIT_SEND_MSC_MSG                    0x02
-#define	MSC_START_BIT_MSC_CMD		        (0x01 << 0)
-#define	MSC_START_BIT_VS_CMD		        (0x01 << 1)
-#define	MSC_START_BIT_READ_REG		        (0x01 << 2)
-#define	MSC_START_BIT_WRITE_REG		        (0x01 << 3)
-#define	MSC_START_BIT_WRITE_BURST	        (0x01 << 4)
-
-#define REG_CBUS_PRI_ADDR_CMD           0xC13
-#define REG_CBUS_PRI_WR_DATA_1ST        0xC14
-#define REG_CBUS_PRI_WR_DATA_2ND        0xC15
-#define REG_CBUS_PRI_RD_DATA_1ST        0xC16
-#define REG_CBUS_PRI_RD_DATA_2ND        0xC17
-
-
-#define REG_CBUS_PRI_VS_CMD             0xC18
-#define REG_CBUS_PRI_VS_DATA            0xC19
-
-#define	REG_MSC_WRITE_BURST_LEN         0xC20       // only for WRITE_BURST
-#define	MSC_REQUESTOR_DONE_NACK         	(0x01 << 6)      
-
-#define	REG_CBUS_MSC_RETRY_INTERVAL			0x1A		// default is 16
-#define	REG_CBUS_DDC_FAIL_LIMIT				0x1C		// default is 5
-#define	REG_CBUS_MSC_FAIL_LIMIT				0x1D		// default is 5
-#define	REG_CBUS_MSC_INT2_STATUS        	0xC1E
-#define REG_CBUS_MSC_INT2_ENABLE             	0xC1F
-	#define	MSC_INT2_REQ_WRITE_MSC              (0x01 << 0)	// Write REG data written.
-	#define	MSC_INT2_HEARTBEAT_MAXFAIL          (0x01 << 1)	// Retry threshold exceeded for sending the Heartbeat
-
-#define	REG_MSC_WRITE_BURST_LEN         0xC20       // only for WRITE_BURST
-
-#define	REG_MSC_HEARTBEAT_CONTROL       0xC21       // Periodic heart beat. TX sends GET_REV_ID MSC command
-#define	MSC_HEARTBEAT_PERIOD_MASK		    0x0F	// bits 3..0
-#define	MSC_HEARTBEAT_FAIL_LIMIT_MASK	    0x70	// bits 6..4
-#define	MSC_HEARTBEAT_ENABLE			    0x80	// bit 7
-
-#define REG_MSC_TIMEOUT_LIMIT           0xC22
-#define	MSC_TIMEOUT_LIMIT_MSB_MASK	        (0x0F)	        // default is 1
-#define	MSC_LEGACY_BIT					    (0x01 << 7)	    // This should be cleared.
-
-#define	REG_CBUS_LINK_CONTROL_1				0xC30	// 
-#define	REG_CBUS_LINK_CONTROL_2				0xC31	// 
-#define	REG_CBUS_LINK_CONTROL_3				0xC32	// 
-#define	REG_CBUS_LINK_CONTROL_4				0xC33	// 
-#define	REG_CBUS_LINK_CONTROL_5				0xC34	// 
-#define	REG_CBUS_LINK_CONTROL_6				0xC35	// 
-#define	REG_CBUS_LINK_CONTROL_7				0xC36	// 
-#define REG_CBUS_LINK_STATUS_1          	0xC37
-#define REG_CBUS_LINK_STATUS_2          	0xC38
-#define	REG_CBUS_LINK_CONTROL_8				0xC39	// 
-#define	REG_CBUS_LINK_CONTROL_9				0xC3A	// 
-#define	REG_CBUS_LINK_CONTROL_10				0xC3B	// 
-#define	REG_CBUS_LINK_CONTROL_11				0xC3C	// 
-#define	REG_CBUS_LINK_CONTROL_12				0xC3D	// 
-
-
-#define REG_CBUS_LINK_CTRL9_0           0xC3A
-#define REG_CBUS_LINK_CTRL9_1           0xCBA
-
-#define	REG_CBUS_DRV_STRENGTH_0				0xC40	// 
-#define	REG_CBUS_DRV_STRENGTH_1				0xC41	// 
-#define	REG_CBUS_ACK_CONTROL				0xC42	// 
-#define	REG_CBUS_CAL_CONTROL				0xC43	// Calibration
-
-#define REG_CBUS_SCRATCHPAD_0           0xCC0
-#define REG_CBUS_DEVICE_CAP_0           0xC80
-#define REG_CBUS_DEVICE_CAP_1           0xC81
-#define REG_CBUS_DEVICE_CAP_2           0xC82
-#define REG_CBUS_DEVICE_CAP_3           0xC83
-#define REG_CBUS_DEVICE_CAP_4           0xC84
-#define REG_CBUS_DEVICE_CAP_5           0xC85
-#define REG_CBUS_DEVICE_CAP_6           0xC86
-#define REG_CBUS_DEVICE_CAP_7           0xC87
-#define REG_CBUS_DEVICE_CAP_8           0xC88
-#define REG_CBUS_DEVICE_CAP_9           0xC89
-#define REG_CBUS_DEVICE_CAP_A           0xC8A
-#define REG_CBUS_DEVICE_CAP_B           0xC8B
-#define REG_CBUS_DEVICE_CAP_C           0xC8C
-#define REG_CBUS_DEVICE_CAP_D           0xC8D
-#define REG_CBUS_DEVICE_CAP_E           0xC8E
-#define REG_CBUS_DEVICE_CAP_F           0xC8F
-#define REG_CBUS_SET_INT_0				0xCA0
-#define REG_CBUS_SET_INT_1				0xCA1
-#define REG_CBUS_SET_INT_2				0xCA2
-#define REG_CBUS_SET_INT_3				0xCA3
-#define REG_CBUS_WRITE_STAT_0        	0xCB0
-#define REG_CBUS_WRITE_STAT_1        	0xCB1
-#define REG_CBUS_WRITE_STAT_2        	0xCB2
-#define REG_CBUS_WRITE_STAT_3        	0xCB3
-
-//------------------------------------------------------------------------------
-// EDID Registers in Page 9     (0xE0)
-//------------------------------------------------------------------------------
-
-#define REG_CBUS_PORT_SEL_AUTO          0x9E6
-#define REG_CBUS_PORT_OVWR_MODE         0x9E7
-#define REG_CBUS_PORT_OVWR_VALUE        0x9E8
-
-#define REG_CBUS_DU_MODE        			0x9E1
-#define REG_CBUS_DU_MODE_DELAY				0x00
-#define REG_CBUS_DU_CNT_5					0x01
-#define REG_CBUS_DU_CNT_7					0x03
-#define REG_CBUS_DU_CNT_9					0x05
-#define REG_CBUS_DU_CNT_11					0x07
-#endif  // __SI_CBUS_REGS_H__
-
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+#ifndef __SI_CBUS_REGS_H__
+#define __SI_CBUS_REGS_H__
+
+//------------------------------------------------------------------------------
+// NOTE: Register addresses are 16 bit values with page and offset combined.
+//
+// Examples:  0x005 = page 0, offset 0x05
+//            0x1B6 = page 1, offset 0xB6
+//------------------------------------------------------------------------------
+
+//------------------------------------------------------------------------------
+// CBUS 0 Registers in Page 12     (0xE6)
+//------------------------------------------------------------------------------
+
+#define	CBUSREG_MAX_REG					0xFF
+
+#define CBUS_PORT1_OFFSET               0x80
+
+#define	REG_CBUS_INTR_STATUS_2				0x05	//
+#define	REG_CBUS_INTR_ENABLE_2				0x06	//
+
+#define REG_CBUS_SUPPORT                0xC07
+#define	BIT_VS_ENABLE                       0x01    // Enable MSC_MSG
+#define	BIT_PING_ENABLE                     0x02    // Enable PING to test the presence
+
+#define REG_CBUS_INTR_STATUS            0xC08
+#define BIT_CONNECT_CHG                     0x01
+#define BIT_DDC_ABORT                       0x04    // Responder aborted DDC command at translation layer
+#define BIT_MSC_MSG_RCV                     0x08    // Responder sent a VS_MSG packet (response data or command.)
+#define BIT_MSC_XFR_DONE                    0x10    // Responder sent ACK packet (not VS_MSG)
+#define BIT_MSC_XFR_ABORT                   0x20    // Command send aborted on TX side?????
+#define BIT_MSC_ABORT                       0x40    // Responder aborted MSC command at translation layer
+#define BIT_HEARTBEAT_TIMEOUT               0x80    // Responder stopped sending 'alive' messages.
+
+#define REG_CBUS_INTR_ENABLE            0xC09
+
+#define REG_DDC_ABORT_REASON        	0xC0C
+#define REG_CBUS_BUS_STATUS             0xC0A
+#define BIT_BUS_CONNECTED                   0x01
+#define BIT_LA_VAL_CHG                      0x02
+
+#define REG_PRI_XFR_ABORT_REASON        0xC0D
+
+#define REG_CBUS_PRI_FWR_ABORT_REASON   0xC0E
+#define	CBUSABORT_BIT_REQ_MAXFAIL			(0x01 << 0)
+#define	CBUSABORT_BIT_PROTOCOL_ERROR		(0x01 << 1)
+#define	CBUSABORT_BIT_REQ_TIMEOUT			(0x01 << 2)
+#define	CBUSABORT_BIT_UNDEFINED_OPCODE		(0x01 << 3)
+#define	CBUSSTATUS_BIT_CONNECTED			(0x01 << 6)
+#define	CBUSABORT_BIT_PEER_ABORTED			(0x01 << 7)
+
+#define REG_CBUS_PRI_START              0xC12
+#define BIT_TRANSFER_PVT_CMD                0x01
+#define BIT_SEND_MSC_MSG                    0x02
+#define	MSC_START_BIT_MSC_CMD		        (0x01 << 0)
+#define	MSC_START_BIT_VS_CMD		        (0x01 << 1)
+#define	MSC_START_BIT_READ_REG		        (0x01 << 2)
+#define	MSC_START_BIT_WRITE_REG		        (0x01 << 3)
+#define	MSC_START_BIT_WRITE_BURST	        (0x01 << 4)
+
+#define REG_CBUS_PRI_ADDR_CMD           0xC13
+#define REG_CBUS_PRI_WR_DATA_1ST        0xC14
+#define REG_CBUS_PRI_WR_DATA_2ND        0xC15
+#define REG_CBUS_PRI_RD_DATA_1ST        0xC16
+#define REG_CBUS_PRI_RD_DATA_2ND        0xC17
+
+
+#define REG_CBUS_PRI_VS_CMD             0xC18
+#define REG_CBUS_PRI_VS_DATA            0xC19
+
+#define	REG_MSC_WRITE_BURST_LEN         0xC20       // only for WRITE_BURST
+#define	MSC_REQUESTOR_DONE_NACK         	(0x01 << 6)      
+
+#define	REG_CBUS_MSC_RETRY_INTERVAL			0x1A		// default is 16
+#define	REG_CBUS_DDC_FAIL_LIMIT				0x1C		// default is 5
+#define	REG_CBUS_MSC_FAIL_LIMIT				0x1D		// default is 5
+#define	REG_CBUS_MSC_INT2_STATUS        	0xC1E
+#define REG_CBUS_MSC_INT2_ENABLE             	0xC1F
+	#define	MSC_INT2_REQ_WRITE_MSC              (0x01 << 0)	// Write REG data written.
+	#define	MSC_INT2_HEARTBEAT_MAXFAIL          (0x01 << 1)	// Retry threshold exceeded for sending the Heartbeat
+
+#define	REG_MSC_WRITE_BURST_LEN         0xC20       // only for WRITE_BURST
+
+#define	REG_MSC_HEARTBEAT_CONTROL       0xC21       // Periodic heart beat. TX sends GET_REV_ID MSC command
+#define	MSC_HEARTBEAT_PERIOD_MASK		    0x0F	// bits 3..0
+#define	MSC_HEARTBEAT_FAIL_LIMIT_MASK	    0x70	// bits 6..4
+#define	MSC_HEARTBEAT_ENABLE			    0x80	// bit 7
+
+#define REG_MSC_TIMEOUT_LIMIT           0xC22
+#define	MSC_TIMEOUT_LIMIT_MSB_MASK	        (0x0F)	        // default is 1
+#define	MSC_LEGACY_BIT					    (0x01 << 7)	    // This should be cleared.
+
+#define	REG_CBUS_LINK_CONTROL_1				0xC30	// 
+#define	REG_CBUS_LINK_CONTROL_2				0xC31	// 
+#define	REG_CBUS_LINK_CONTROL_3				0xC32	// 
+#define	REG_CBUS_LINK_CONTROL_4				0xC33	// 
+#define	REG_CBUS_LINK_CONTROL_5				0xC34	// 
+#define	REG_CBUS_LINK_CONTROL_6				0xC35	// 
+#define	REG_CBUS_LINK_CONTROL_7				0xC36	// 
+#define REG_CBUS_LINK_STATUS_1          	0xC37
+#define REG_CBUS_LINK_STATUS_2          	0xC38
+#define	REG_CBUS_LINK_CONTROL_8				0xC39	// 
+#define	REG_CBUS_LINK_CONTROL_9				0xC3A	// 
+#define	REG_CBUS_LINK_CONTROL_10				0xC3B	// 
+#define	REG_CBUS_LINK_CONTROL_11				0xC3C	// 
+#define	REG_CBUS_LINK_CONTROL_12				0xC3D	// 
+
+
+#define REG_CBUS_LINK_CTRL9_0           0xC3A
+#define REG_CBUS_LINK_CTRL9_1           0xCBA
+
+#define	REG_CBUS_DRV_STRENGTH_0				0xC40	// 
+#define	REG_CBUS_DRV_STRENGTH_1				0xC41	// 
+#define	REG_CBUS_ACK_CONTROL				0xC42	// 
+#define	REG_CBUS_CAL_CONTROL				0xC43	// Calibration
+
+#define REG_CBUS_SCRATCHPAD_0           0xCC0
+#define REG_CBUS_DEVICE_CAP_0           0xC80
+#define REG_CBUS_DEVICE_CAP_1           0xC81
+#define REG_CBUS_DEVICE_CAP_2           0xC82
+#define REG_CBUS_DEVICE_CAP_3           0xC83
+#define REG_CBUS_DEVICE_CAP_4           0xC84
+#define REG_CBUS_DEVICE_CAP_5           0xC85
+#define REG_CBUS_DEVICE_CAP_6           0xC86
+#define REG_CBUS_DEVICE_CAP_7           0xC87
+#define REG_CBUS_DEVICE_CAP_8           0xC88
+#define REG_CBUS_DEVICE_CAP_9           0xC89
+#define REG_CBUS_DEVICE_CAP_A           0xC8A
+#define REG_CBUS_DEVICE_CAP_B           0xC8B
+#define REG_CBUS_DEVICE_CAP_C           0xC8C
+#define REG_CBUS_DEVICE_CAP_D           0xC8D
+#define REG_CBUS_DEVICE_CAP_E           0xC8E
+#define REG_CBUS_DEVICE_CAP_F           0xC8F
+#define REG_CBUS_SET_INT_0				0xCA0
+#define REG_CBUS_SET_INT_1				0xCA1
+#define REG_CBUS_SET_INT_2				0xCA2
+#define REG_CBUS_SET_INT_3				0xCA3
+#define REG_CBUS_WRITE_STAT_0        	0xCB0
+#define REG_CBUS_WRITE_STAT_1        	0xCB1
+#define REG_CBUS_WRITE_STAT_2        	0xCB2
+#define REG_CBUS_WRITE_STAT_3        	0xCB3
+
+//------------------------------------------------------------------------------
+// EDID Registers in Page 9     (0xE0)
+//------------------------------------------------------------------------------
+
+#define REG_CBUS_PORT_SEL_AUTO          0x9E6
+#define REG_CBUS_PORT_OVWR_MODE         0x9E7
+#define REG_CBUS_PORT_OVWR_VALUE        0x9E8
+
+#define REG_CBUS_DU_MODE        			0x9E1
+#define REG_CBUS_DU_MODE_DELAY				0x00
+#define REG_CBUS_DU_CNT_5					0x01
+#define REG_CBUS_DU_CNT_7					0x03
+#define REG_CBUS_DU_CNT_9					0x05
+#define REG_CBUS_DU_CNT_11					0x07
+#endif  // __SI_CBUS_REGS_H__
+
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/si_cpCbus.c news/kernel/drivers/media/video/samsung/mhl_v1/si_cpCbus.c
--- kernel/drivers/media/video/samsung/mhl_v1/si_cpCbus.c	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/si_cpCbus.c	2011-06-17 19:41:22.000000000 +0900
@@ -1,654 +1,675 @@
-//***************************************************************************
-//!file     si_cpCBUS.c
-//!brief    CP 9387 Starter Kit CDC demonstration code.
-//
-// No part of this work may be reproduced, modified, distributed,
-// transmitted, transcribed, or translated into any language or computer
-// format, in any form or by any means without written permission of
-// Silicon Image, Inc., 1060 East Arques Avenue, Sunnyvale, California 94085
-//
-// Copyright 2009, Silicon Image, Inc.  All rights reserved.
-//***************************************************************************/
-
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/i2c.h>
-#include <linux/gpio.h>
-#include <plat/pm.h>
-#include <asm/irq.h>
-#include <linux/delay.h>
-#include <plat/gpio-cfg.h>
-#include <mach/regs-gpio.h>
-#include <mach/regs-clock.h>
-
-#include <linux/syscalls.h> 
-#include <linux/fcntl.h> 
-#include <asm/uaccess.h> 
-#include <linux/types.h>
-
-#include "Common_Def.h"
-#include "si_apiCbus.h"
-
-//extern void rcp_cbus_uevent(void);	//MHL v1 //NAGSM_Android_SEL_Kernel_Aakash_20101126
-
-#if (IS_CBUS == 1)
-//------------------------------------------------------------------------------
-// Module variables
-//------------------------------------------------------------------------------
-
-typedef struct
-{
-	byte rcpKeyCode;          //!< RCP CBUS Key Code
-	char   rcpName[30];
-} SI_Rc5RcpConversion_t;
-
-SI_Rc5RcpConversion_t RcpSourceToSink[] =
-{
-	{ MHD_RCP_CMD_SELECT,			"Select"},
-	{ MHD_RCP_CMD_UP,				"Up"},
-	{ MHD_RCP_CMD_DOWN,				"Down"},
-	{ MHD_RCP_CMD_LEFT,				"Left"},
-	{ MHD_RCP_CMD_RIGHT, 			"Right"},
-	//{ MHD_RCP_CMD_RIGHT_UP,		"Right Up"},
-	//{ MHD_RCP_CMD_RIGHT_DOWN,		"Right Down"},
-	//{ MHD_RCP_CMD_LEFT_UP,		"Left Up"},
-	//{ MHD_RCP_CMD_LEFT_DOWN,		"Left Down"},
-	{ MHD_RCP_CMD_ROOT_MENU,		"Root Menu"},
-	//{ MHD_RCP_CMD_SETUP_MENU,		"Setup Menu"},
-	//{ MHD_RCP_CMD_CONTENTS_MENU,	"Contents Menu"},
-	//{ MHD_RCP_CMD_FAVORITE_MENU,	"Favorite Menu"},
-	{ MHD_RCP_CMD_EXIT,				"Exit"},
-	// 0x0E - 0x1F Reserved 
-	{ MHD_RCP_CMD_NUM_0,			"Num 0"},
-	{ MHD_RCP_CMD_NUM_1,			"Num 1"},
-	{ MHD_RCP_CMD_NUM_2,			"Num 2"},
-	{ MHD_RCP_CMD_NUM_3,			"Num 3"},
-	{ MHD_RCP_CMD_NUM_4,			"Num 4"},
-	{ MHD_RCP_CMD_NUM_5,			"Num 5"},
-	{ MHD_RCP_CMD_NUM_6,			"Num 6"},
-	{ MHD_RCP_CMD_NUM_7,			"Num 7"},
-	{ MHD_RCP_CMD_NUM_8,			"Num 8"},
-	{ MHD_RCP_CMD_NUM_9,			"Num 9"},
-	//{ MHD_RCP_CMD_DOT,				"Dot"},
-	{ MHD_RCP_CMD_ENTER,			"Enter"},
-	{ MHD_RCP_CMD_CLEAR,			"Clear"},
-	// 0x2D - 0x2F Reserved 
-	{ MHD_RCP_CMD_CH_UP,			"Channel Up"},
-	{ MHD_RCP_CMD_CH_DOWN,			"Channel Down"},
-	{ MHD_RCP_CMD_PRE_CH,			"Previous Channel"},
-	{ MHD_RCP_CMD_SOUND_SELECT,		"Sound Select"},
-	//{ MHD_RCP_CMD_INPUT_SELECT,	"Input Select"},
-	//{ MHD_RCP_CMD_SHOW_INFO,		"Show Info"},
-	//{ MHD_RCP_CMD_HELP,			"Help"},
-	//{ MHD_RCP_CMD_PAGE_UP,		"Page Up"},
-	//{ MHD_RCP_CMD_PAGE_DOWN,		"Page Down"},
-	// 0x39 - 0x40 Reserved 
-	{ MHD_RCP_CMD_VOL_UP,			"Volume Up"},
-	{ MHD_RCP_CMD_VOL_DOWN,			"Volume Down"},
-	{ MHD_RCP_CMD_MUTE,				"Mute"},
-	{ MHD_RCP_CMD_PLAY,				"Play"},
-	{ MHD_RCP_CMD_STOP,			 	"Stop"},
-	{ MHD_RCP_CMD_PAUSE,			"Pause"},
-	{ MHD_RCP_CMD_RECORD,			"Record"},
-	{ MHD_RCP_CMD_REWIND,			"Rewind"},
-	{ MHD_RCP_CMD_FAST_FWD,			"Fast Fwd"},
-	{ MHD_RCP_CMD_EJECT,			"Eject"},
-	{ MHD_RCP_CMD_FWD,				"Forward"},
-	{ MHD_RCP_CMD_BKWD,				"Backward"},
-	// 0X4D - 0x4F Reserved
-	//{ MHD_RCP_CMD_ANGLE,			"Angle"},
-	//{ MHD_RCP_CMD_SUBPICTURE,		"Subpicture"},
-	// 0x52 - 0x5F Reserved
-	{ MHD_RCP_CMD_PLAY_FUNC,		"Play Function"},
-	{ MHD_RCP_CMD_PAUSE_PLAY_FUNC,	"Pause Play Function"},
-	{ MHD_RCP_CMD_RECORD_FUNC,		"Record Function"},
-	{ MHD_RCP_CMD_PAUSE_REC_FUNC,	"Pause Record Function"},
-	{ MHD_RCP_CMD_STOP_FUNC,		"Stop Function"},
-	{ MHD_RCP_CMD_MUTE_FUNC,		"Mute Function"},
-	{ MHD_RCP_CMD_UN_MUTE_FUNC,		"Un-Mute Function"},
-	//{ MHD_RCP_CMD_TUNE_FUNC,		"Tune Function"},
-	//{ MHD_RCP_CMD_MEDIA_FUNC,		"Media Function"},
-	// 0x69 - 0x70 Reserved
-	//{ MHD_RCP_CMD_F1,				"F1"},
-	//{ MHD_RCP_CMD_F2,				"F2"},
-	//{ MHD_RCP_CMD_F3,				"F3"},
-	//{ MHD_RCP_CMD_F4,				"F4"},
-	//{ MHD_RCP_CMD_F5,				"F5"},
-	// 0x76 - 0x7D Reserved
-	//{ MHD_RCP_CMD_VS,				"Vendor Specific"}
-	// 0x7F Reserved
-};
-
-//------------------------------------------------------------------------------
-// Function:    CbusRc5toRcpConvert
-// Description: Translate RC5 command to CBUS RCP command
-// Parameters:  keyData: key code from the remote controller
-// Returns:     RCP code equivalent to passed RC5 key code or 0xFF if not in list.
-//------------------------------------------------------------------------------
-
-static byte CbusRc5toRcpConvert ( byte keyCode )
-{
-	byte i;
-	byte retVal = 0xFF;
-	byte length = sizeof(RcpSourceToSink)/sizeof(SI_Rc5RcpConversion_t);
-
-	for ( i = 0; i < length ; i++ )
-	{
-		if ( keyCode == RcpSourceToSink[i].rcpKeyCode )
-		{
-			retVal = RcpSourceToSink[i].rcpKeyCode;
-#ifdef RCP_DEBUG
-			printk("CPCBUS:: Send ----> %s\n",
-				RcpSourceToSink[i].rcpName );
-#endif
-			break;
-		}
-	}
-
-	/* Return the new code or 0xFF if not found.    */
-
-	return( ( i == length ) ? 0xFF : retVal );
-}
-
-//------------------------------------------------------------------------------
-// Function:    CpCbusSendRcpMessage
-// Description: Convert input port number to CBUS channel and send the
-//              passed RC5 key code as a CBUS RCP key code.
-// Parameters:  port    - Port Processor input port index
-//              keyCode - Remote control button code.
-// Returns:     true if successful, false if not MHD port or other failure.
-//------------------------------------------------------------------------------
-
-Bool CpCbusSendRcpMessage ( byte channel, byte keyCode )
-{
-	Bool  success;
-
-	success = FALSE;
-	for ( ;; )
-	{
-		printk( "CPCBUS:: Sending RCP Msg:: %02X keycode"
-				" to channel %d CBUS\n\n",
-				(int)keyCode, (int)channel );
-		if (channel == 0xFF) {
-			printk( "\n::::::: Bad channel -- " );
-			break;
-		}				      
-
-		keyCode = CbusRc5toRcpConvert( keyCode );
-		if (keyCode == 0xFF) {
-			printk( "\n::::::: Bad KeyCode -- " );
-			break;
-		}
-
-		success = SI_CbusMscMsgSubCmdSend( channel,
-						MHD_MSC_MSG_RCP,
-						keyCode );
-		break;
-	}
-
-	if ( !success )
-	{
-		printk("Unable to send command :::::::\n");
-	}
-
-	return success;
-}
-
-//------------------------------------------------------------------------------
-// Function:    CpCbusSendRapMessage
-// Parameters:  port    - Port Processor input port index
-//              actionCode - Action code.
-// Returns:     true if successful, false if not MHD port or other failure.
-//------------------------------------------------------------------------------
-
-Bool CpCbusSendRapMessage ( byte channel, byte actCode )
-{
-	Bool  success;
-
-	success = FALSE;
-	for ( ;; )
-	{
-		printk( "CPCBUS:: Sending RAP Msg:: %02X action code"
-			" to channel %d CBUS\n\n",
-			(int)actCode, (int)channel );
-
-		if ( channel == 0xFF) {
-			printk("\n::::::: Bad channel -- ");
-			break;
-		}
-
-		if ((actCode == MHD_RAP_CMD_POLL) ||
-		(actCode == MHD_RAP_CMD_CHG_QUIET) ||
-		(actCode != MHD_RAP_CMD_CHG_ACTIVE_PWR)) {
-			success = SI_CbusMscMsgSubCmdSend(channel,
-						MHD_MSC_MSG_RAP,
-						actCode );
-			break;
-		} else {
-			printk("\n::::::: Bad action code -- ");
-			break;
-		}
-	}
-
-	if (!success) {
-		printk( "Unable to send action command :::::::\n" );
-	}
-
-	return success;
-}
-
-//------------------------------------------------------------------------------
-// Function:    CpProcessRcpMessage
-// Description: Process the passed RCP message.
-// Returns:     The RCPK status code.
-//------------------------------------------------------------------------------
-
-static byte CpProcessRcpMessage ( byte channel, byte rcpData )
-{
-	byte rcpkStatus = MHD_MSC_MSG_NO_ERROR;
-
-	printk("RCP Key Code: 0x%02X, channel: 0x%02X\n",
-			(int)rcpData, (int)channel );
-
-	switch (rcpData) {
-	case MHD_RCP_CMD_SELECT:
-		printk("\nSelect received\n\n");
-		break;
-	case MHD_RCP_CMD_UP:
-		printk("\nUp received\n\n");
-		break;
-	case MHD_RCP_CMD_DOWN:
-		printk("\nDown received\n\n");
-		break;
-	case MHD_RCP_CMD_LEFT:
-		printk("\nLeft received\n\n");
-		break;
-	case MHD_RCP_CMD_RIGHT:
-		printk("\nRight received\n\n");
-		break;
-	case MHD_RCP_CMD_RIGHT_UP:
-		printk("\n MHD_RCP_CMD_RIGHT_UP\n\n");
-		break;
-	case MHD_RCP_CMD_RIGHT_DOWN:
-		printk("\n MHD_RCP_CMD_RIGHT_DOWN \n\n");
-		break;
-	case MHD_RCP_CMD_LEFT_UP:
-		printk("\n MHD_RCP_CMD_LEFT_UP\n\n");
-		break;
-	case MHD_RCP_CMD_LEFT_DOWN:
-		printk("\n MHD_RCP_CMD_LEFT_DOWN\n\n");
-		break;      
-	case MHD_RCP_CMD_ROOT_MENU:
-		printk("\nRoot Menu received\n\n");
-		break;
-	case MHD_RCP_CMD_SETUP_MENU:
-		printk("\n MHD_RCP_CMD_SETUP_MENU\n\n");
-		break;      
-
-	case MHD_RCP_CMD_CONTENTS_MENU:
-		printk("\n MHD_RCP_CMD_CONTENTS_MENU\n\n");
-		break;      
-
-	case MHD_RCP_CMD_FAVORITE_MENU:
-		printk("\n MHD_RCP_CMD_FAVORITE_MENU\n\n");
-		break;            
-
-	case MHD_RCP_CMD_EXIT:
-		printk("\nExit received\n\n");
-		break;
-
-	case MHD_RCP_CMD_NUM_0:
-		printk("\nNumber 0 received\n\n");
-		break;
-
-	case MHD_RCP_CMD_NUM_1:
-		printk("\nNumber 1 received\n\n");
-		break;
-
-	case MHD_RCP_CMD_NUM_2:
-		printk("\nNumber 2 received\n\n");
-		break;
-
-	case MHD_RCP_CMD_NUM_3:
-		printk("\nNumber 3 received\n\n");
-		break;
-
-	case MHD_RCP_CMD_NUM_4:
-		printk("\nNumber 4 received\n\n");
-		break;
-
-	case MHD_RCP_CMD_NUM_5:
-		printk("\nNumber 5 received\n\n");
-		break;
-
-	case MHD_RCP_CMD_NUM_6:
-		printk("\nNumber 6 received\n\n");
-		break;
-
-	case MHD_RCP_CMD_NUM_7:
-		printk("\nNumber 7 received\n\n");
-		break;
-
-	case MHD_RCP_CMD_NUM_8:
-		printk("\nNumber 8 received\n\n");
-		break;
-
-	case MHD_RCP_CMD_NUM_9:
-		printk("\nNumber 9 received\n\n");
-		break;
-
-	case MHD_RCP_CMD_DOT:
-		printk("\n MHD_RCP_CMD_DOT\n\n");
-		break;          
-
-	case MHD_RCP_CMD_ENTER:
-		printk("\nEnter received\n\n");
-		break;
-
-	case MHD_RCP_CMD_CLEAR:
-		printk("\nClear received\n\n");
-		break;
-
-	case MHD_RCP_CMD_CH_UP:
-		printk("\n MHD_RCP_CMD_CH_UP\n\n");
-		break; 
-
-	case MHD_RCP_CMD_CH_DOWN:
-		printk("\n MHD_RCP_CMD_CH_DOWN\n\n");
-		break;       
-
-	case MHD_RCP_CMD_PRE_CH:
-		printk("\n MHD_RCP_CMD_PRE_CH\n\n");
-		break;           
-
-	case MHD_RCP_CMD_SOUND_SELECT:
-		printk("\nSound Select received\n\n");
-		break;
-
-	case MHD_RCP_CMD_INPUT_SELECT:
-		printk("\n MHD_RCP_CMD_INPUT_SELECT\n\n");
-		break;    
-
-	case MHD_RCP_CMD_SHOW_INFO:
-		printk("\n MHD_RCP_CMD_SHOW_INFO\n\n");
-		break;     
-
-	case MHD_RCP_CMD_HELP:
-		printk("\n MHD_RCP_CMD_HELP\n\n");
-		break;   
-
-	case MHD_RCP_CMD_PAGE_UP:
-		printk("\n MHD_RCP_CMD_PAGE_UP\n\n");
-		break;  
-
-	case MHD_RCP_CMD_PAGE_DOWN:
-		printk("\n MHD_RCP_CMD_PAGE_DOWN\n\n");
-		break;             
-
-	case MHD_RCP_CMD_VOL_UP:
-		printk("\n MHD_RCP_CMD_VOL_UP\n\n");
-		break;             
-
-	case MHD_RCP_CMD_VOL_DOWN:
-		printk("\n MHD_RCP_CMD_VOL_DOWN\n\n");
-		break;             
-
-	case MHD_RCP_CMD_MUTE:
-		printk("\n MHD_RCP_CMD_MUTE\n\n");
-		break;             
-
-	case MHD_RCP_CMD_PLAY:
-		printk("\nPlay received\n\n");
-		break;
-
-	case MHD_RCP_CMD_STOP:
-		printk("\n MHD_RCP_CMD_STOP\n\n");
-		break;   
-
-	case MHD_RCP_CMD_PAUSE:
-		printk("\nPause received\n\n");
-		break;
-
-	case MHD_RCP_CMD_RECORD:
-		printk("\n MHD_RCP_CMD_RECORD\n\n");
-		break;   
-
-	case MHD_RCP_CMD_FAST_FWD:
-		printk("\nFastfwd received\n\n");
-		break;
-
-	case MHD_RCP_CMD_REWIND:
-		printk("\nRewind received\n\n");
-		break;
-
-	case MHD_RCP_CMD_EJECT:
-		printk("\nEject received\n\n");
-		break;
-
-	case MHD_RCP_CMD_FWD:
-		printk("\nForward received\n\n");
-		break;
-
-	case MHD_RCP_CMD_BKWD:
-		printk("\nBackward received\n\n");
-		break;
-
-	case MHD_RCP_CMD_PLAY_FUNC:
-		printk("\nPlay Function received\n\n");
-		break;
-
-	case MHD_RCP_CMD_PAUSE_PLAY_FUNC:
-		printk("\nPause_Play Function received\n\n");
-		break;
-
-	case MHD_RCP_CMD_STOP_FUNC:
-		printk("\nStop Function received\n\n");
-		break;
-
-	default:
-		rcpkStatus = MHD_MSC_MSG_INEFFECTIVE_KEY_CODE;
-		break;
-	}
-
-	if ( rcpkStatus == MHD_MSC_MSG_INEFFECTIVE_KEY_CODE ) {
-		printk("\nKeyCode not recognized or supported.\n\n");
-	}
-
-	return rcpkStatus;
-}
-
-//------------------------------------------------------------------------------
-// Function:    CpProcessRapMessage
-// Description: Process the passed RAP message.
-// Returns:     The RAPK status code.
-//------------------------------------------------------------------------------
-
-static byte CpProcessRapMessage ( byte channel, byte rcpData )
-{
-	byte rapkStatus = MHD_MSC_MSG_NO_ERROR;
-
-	printk("RAP Key Code: 0x%02X, channel: 0x%02X\n",
-			(int)rcpData, (int)channel );
-
-	switch (rcpData) {
-	case MHD_RAP_CMD_POLL:
-		printk("\nPOLL received\n\n");
-		break;
-
-	case MHD_RAP_CMD_CHG_ACTIVE_PWR:
-		printk( "\nCHANGE TO ACTIVE POWER STATE"
-				" received\n\n");
-		break;        
-
-	case MHD_RAP_CMD_CHG_QUIET:
-		printk( "\nCHANGE TO QUIET STATE"
-				" received\n\n");
-		//TPI_GoToD3();  //???
-		break;
-
-	default:
-		rapkStatus = MHD_MSC_MSG_RAP_UNRECOGNIZED_ACT_CODE;
-		break;
-	}
-
-	if ( rapkStatus == MHD_MSC_MSG_RAP_UNRECOGNIZED_ACT_CODE ) {
-		printk("\nKeyCode not recognized !! \n\n" );
-	}
-
-	return rapkStatus;
-}
-
-//------------------------------------------------------------------------------
-// Function:    CbusConnectionCheck
-// Description: Display any change in CBUS connection state and enable
-//              CBUS heartbeat if channel has been connected.
-// Parameters:  channel - CBUS channel to check
-//------------------------------------------------------------------------------
-
-static void CbusConnectionCheck (byte channel)
-{
-	static byte busConnected[ MHD_MAX_CHANNELS ] = {0};
-
-	/* If CBUS connection state has changed for this channel,   */
-	/* update channel state and hardware.                       */
-
-	if (busConnected[channel] != SI_CbusChannelConnected(channel)) {
-		busConnected[ channel ] = SI_CbusChannelConnected( channel );
-
-		// heartbeat has been disabled in all products
-		// SI_CbusHeartBeat( channel, busConnected[ channel ] );
-
-		printk("CPCBUS:: ***Channel: %d,  CBUS %s ****\n",
-				(int)channel ,
-				busConnected[ channel ] ?
-				"Connected" : "Unconnected");
-	}
-}
-
-//------------------------------------------------------------------------------
-// Function:    CpCbusProcessPrivateMessage
-// Description: Get the result of the last message sent and use it appropriately
-//              or process a request from the connected device.
-// Parameters:  channel - CBUS channel that has message data for us.
-//------------------------------------------------------------------------------
-
-static void CpCbusProcessPrivateMessage(byte channel)
-{
-	byte     status;
-	cbus_req_t  *pCmdRequest;
-
-	pCmdRequest = SI_CbusRequestData( channel );
-	//CbusRcpData = pCmdRequest->offsetData;
-
-	switch ( pCmdRequest->command ) {
-	case MHD_MSC_MSG_RCP:
-		printk("MHD_MSC_MSG_RCP 1 \n");
-	/* Acknowledge receipt of command and process it.  Note that    */
-	/* we could send the ack before processing anything, because it */
-	/* is an indicator that the command was properly received, not  */
-	/* that it was executed, however, we use one function to parse  */
-	/* the command for errors AND for processing. The only thing we */
-	/* must do is make sure that the processing does not exceed the */
-	/* ACK response time limit.                                     */
-
-	/* MHL v1					*/
-	/* NAGSM_Android_SEL_Kernel_Aakash_20101130	*/
-	/* Inform Kernel only on MHD_MSC_MSG_RCP	*/
-		//CbusRcpData = pCmdRequest->offsetData;
-
-		//rcp_cbus_uevent();
-		//MHL v1 //NAGSM_Android_SEL_Kernel_Aakash_20101126
-
-		status = CpProcessRcpMessage(channel, pCmdRequest->offsetData);
-		SI_CbusRcpMessageAck(channel, status, pCmdRequest->offsetData);
-		break;
-
-	case MHD_MSC_MSG_RCPK:
-		printk("MHD_MSC_MSG_RCPK 1\n");          
-		break;
-
-	case MHD_MSC_MSG_RCPE:  
-		printk("MHD_MSC_MSG_RCPE 1\n");            
-		break;
-
-	case MHD_MSC_MSG_RAP:
-		printk("MHD_MSC_MSG_RAP 1\n");            
-		status = CpProcessRapMessage(channel, pCmdRequest->offsetData );
-			SI_CbusRapMessageAck(channel, status);
-		break;
-
-	case MHD_MSC_MSG_RAPK:  
-		break;
-	}
-}
-
-//------------------------------------------------------------------------------
-// Function:    CpCbusHandler
-// Description: Polls the send/receive state of the CBUS hardware.
-//------------------------------------------------------------------------------
-
-void CpCbusHandler(void)
-{
-	byte channel, status;
-
-	/* Monitor all CBUS channels.   */
-
-	for (channel = 0; channel < MHD_MAX_CHANNELS; channel++) {
-		/* Update CBUS status.  */
-		SI_CbusUpdateBusStatus( channel );
-		CbusConnectionCheck( channel );
-
-		/* Monitor CBUS interrupts. */
-		status = SI_CbusHandler( channel );
-		if ( status == STATUS_SUCCESS ) {
-			/* Get status of current request, if any.   */
-
-			status = SI_CbusRequestStatus( channel );
-			switch ( status ) {
-			case CBUS_REQ_IDLE: 
-				printk("CBUS_REQ_IDLE\n");
-				break;
-
-			case CBUS_REQ_PENDING:
-				printk("CBUS_REQ_PENDING\n");              
-				break;
-
-			case CBUS_REQ_SENT:
-				printk("CBUS_REQ_SENT\n");              
-				break;
-
-			case CBUS_REQ_RECEIVED:
-				printk("CBUS_REQ_RECEIVED\n");  
-			/* Received a message or message response.  */
-			/* Go do what is appropriate.               */
-
-				CpCbusProcessPrivateMessage( channel );
-				break;
-
-			default:
-				break;
-			}
-		} else if ( status == ERROR_NO_HEARTBEAT ) {
-			printk("Lost CBUS channel %d heartbeat\n",
-						(int)channel);
-		} else if ( status == ERROR_NACK_FROM_PEER ) {
-			printk ("NACK received from peer, cmd should be"
-				" sent again.\n");
-		} else {
-		/* Lee: Only thing that comes here is interrupt timeout */
-		/*  -- is this bad? */
-		}
-	}
-}
-
-//------------------------------------------------------------------------------
-// Function:    CpCbusInitialize
-// Description: Initialize the CBUS subsystem and enabled the default channels
-//------------------------------------------------------------------------------
-
-void CpCbusInitialize(void)
-{
-	/* Initialize the basic hardware.   */
-	SI_CbusInitialize();
-}
-#endif
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <plat/pm.h>
+#include <asm/irq.h>
+#include <linux/delay.h>
+#include <plat/gpio-cfg.h>
+#include <mach/regs-gpio.h>
+#include <mach/regs-clock.h>
+
+#include <linux/syscalls.h> 
+#include <linux/fcntl.h> 
+#include <asm/uaccess.h> 
+#include <linux/types.h>
+
+#include "Common_Def.h"
+#include "si_apiCbus.h"
+
+//extern void rcp_cbus_uevent(void);	//MHL v1 //NAGSM_Android_SEL_Kernel_Aakash_20101126
+
+#if (IS_CBUS == 1)
+//------------------------------------------------------------------------------
+// Module variables
+//------------------------------------------------------------------------------
+
+typedef struct
+{
+	byte rcpKeyCode;          //!< RCP CBUS Key Code
+	char   rcpName[30];
+} SI_Rc5RcpConversion_t;
+
+SI_Rc5RcpConversion_t RcpSourceToSink[] =
+{
+	{ MHD_RCP_CMD_SELECT,			"Select"},
+	{ MHD_RCP_CMD_UP,				"Up"},
+	{ MHD_RCP_CMD_DOWN,				"Down"},
+	{ MHD_RCP_CMD_LEFT,				"Left"},
+	{ MHD_RCP_CMD_RIGHT, 			"Right"},
+	//{ MHD_RCP_CMD_RIGHT_UP,		"Right Up"},
+	//{ MHD_RCP_CMD_RIGHT_DOWN,		"Right Down"},
+	//{ MHD_RCP_CMD_LEFT_UP,		"Left Up"},
+	//{ MHD_RCP_CMD_LEFT_DOWN,		"Left Down"},
+	{ MHD_RCP_CMD_ROOT_MENU,		"Root Menu"},
+	//{ MHD_RCP_CMD_SETUP_MENU,		"Setup Menu"},
+	//{ MHD_RCP_CMD_CONTENTS_MENU,	"Contents Menu"},
+	//{ MHD_RCP_CMD_FAVORITE_MENU,	"Favorite Menu"},
+	{ MHD_RCP_CMD_EXIT,				"Exit"},
+	// 0x0E - 0x1F Reserved 
+	{ MHD_RCP_CMD_NUM_0,			"Num 0"},
+	{ MHD_RCP_CMD_NUM_1,			"Num 1"},
+	{ MHD_RCP_CMD_NUM_2,			"Num 2"},
+	{ MHD_RCP_CMD_NUM_3,			"Num 3"},
+	{ MHD_RCP_CMD_NUM_4,			"Num 4"},
+	{ MHD_RCP_CMD_NUM_5,			"Num 5"},
+	{ MHD_RCP_CMD_NUM_6,			"Num 6"},
+	{ MHD_RCP_CMD_NUM_7,			"Num 7"},
+	{ MHD_RCP_CMD_NUM_8,			"Num 8"},
+	{ MHD_RCP_CMD_NUM_9,			"Num 9"},
+	//{ MHD_RCP_CMD_DOT,				"Dot"},
+	{ MHD_RCP_CMD_ENTER,			"Enter"},
+	{ MHD_RCP_CMD_CLEAR,			"Clear"},
+	// 0x2D - 0x2F Reserved 
+	{ MHD_RCP_CMD_CH_UP,			"Channel Up"},
+	{ MHD_RCP_CMD_CH_DOWN,			"Channel Down"},
+	{ MHD_RCP_CMD_PRE_CH,			"Previous Channel"},
+	{ MHD_RCP_CMD_SOUND_SELECT,		"Sound Select"},
+	//{ MHD_RCP_CMD_INPUT_SELECT,	"Input Select"},
+	//{ MHD_RCP_CMD_SHOW_INFO,		"Show Info"},
+	//{ MHD_RCP_CMD_HELP,			"Help"},
+	//{ MHD_RCP_CMD_PAGE_UP,		"Page Up"},
+	//{ MHD_RCP_CMD_PAGE_DOWN,		"Page Down"},
+	// 0x39 - 0x40 Reserved 
+	{ MHD_RCP_CMD_VOL_UP,			"Volume Up"},
+	{ MHD_RCP_CMD_VOL_DOWN,			"Volume Down"},
+	{ MHD_RCP_CMD_MUTE,				"Mute"},
+	{ MHD_RCP_CMD_PLAY,				"Play"},
+	{ MHD_RCP_CMD_STOP,			 	"Stop"},
+	{ MHD_RCP_CMD_PAUSE,			"Pause"},
+	{ MHD_RCP_CMD_RECORD,			"Record"},
+	{ MHD_RCP_CMD_REWIND,			"Rewind"},
+	{ MHD_RCP_CMD_FAST_FWD,			"Fast Fwd"},
+	{ MHD_RCP_CMD_EJECT,			"Eject"},
+	{ MHD_RCP_CMD_FWD,				"Forward"},
+	{ MHD_RCP_CMD_BKWD,				"Backward"},
+	// 0X4D - 0x4F Reserved
+	//{ MHD_RCP_CMD_ANGLE,			"Angle"},
+	//{ MHD_RCP_CMD_SUBPICTURE,		"Subpicture"},
+	// 0x52 - 0x5F Reserved
+	{ MHD_RCP_CMD_PLAY_FUNC,		"Play Function"},
+	{ MHD_RCP_CMD_PAUSE_PLAY_FUNC,	"Pause Play Function"},
+	{ MHD_RCP_CMD_RECORD_FUNC,		"Record Function"},
+	{ MHD_RCP_CMD_PAUSE_REC_FUNC,	"Pause Record Function"},
+	{ MHD_RCP_CMD_STOP_FUNC,		"Stop Function"},
+	{ MHD_RCP_CMD_MUTE_FUNC,		"Mute Function"},
+	{ MHD_RCP_CMD_UN_MUTE_FUNC,		"Un-Mute Function"},
+	//{ MHD_RCP_CMD_TUNE_FUNC,		"Tune Function"},
+	//{ MHD_RCP_CMD_MEDIA_FUNC,		"Media Function"},
+	// 0x69 - 0x70 Reserved
+	//{ MHD_RCP_CMD_F1,				"F1"},
+	//{ MHD_RCP_CMD_F2,				"F2"},
+	//{ MHD_RCP_CMD_F3,				"F3"},
+	//{ MHD_RCP_CMD_F4,				"F4"},
+	//{ MHD_RCP_CMD_F5,				"F5"},
+	// 0x76 - 0x7D Reserved
+	//{ MHD_RCP_CMD_VS,				"Vendor Specific"}
+	// 0x7F Reserved
+};
+
+//------------------------------------------------------------------------------
+// Function:    CbusRc5toRcpConvert
+// Description: Translate RC5 command to CBUS RCP command
+// Parameters:  keyData: key code from the remote controller
+// Returns:     RCP code equivalent to passed RC5 key code or 0xFF if not in list.
+//------------------------------------------------------------------------------
+
+static byte CbusRc5toRcpConvert ( byte keyCode )
+{
+	byte i;
+	byte retVal = 0xFF;
+	byte length = sizeof(RcpSourceToSink)/sizeof(SI_Rc5RcpConversion_t);
+
+	for ( i = 0; i < length ; i++ )
+	{
+		if ( keyCode == RcpSourceToSink[i].rcpKeyCode )
+		{
+			retVal = RcpSourceToSink[i].rcpKeyCode;
+#ifdef RCP_DEBUG
+			printk("CPCBUS:: Send ----> %s\n",
+				RcpSourceToSink[i].rcpName );
+#endif
+			break;
+		}
+	}
+
+	/* Return the new code or 0xFF if not found.    */
+
+	return( ( i == length ) ? 0xFF : retVal );
+}
+
+//------------------------------------------------------------------------------
+// Function:    CpCbusSendRcpMessage
+// Description: Convert input port number to CBUS channel and send the
+//              passed RC5 key code as a CBUS RCP key code.
+// Parameters:  port    - Port Processor input port index
+//              keyCode - Remote control button code.
+// Returns:     true if successful, false if not MHD port or other failure.
+//------------------------------------------------------------------------------
+
+Bool CpCbusSendRcpMessage ( byte channel, byte keyCode )
+{
+	Bool  success;
+
+	success = FALSE;
+	for ( ;; )
+	{
+		printk( "CPCBUS:: Sending RCP Msg:: %02X keycode"
+				" to channel %d CBUS\n\n",
+				(int)keyCode, (int)channel );
+		if (channel == 0xFF) {
+			printk( "\n::::::: Bad channel -- " );
+			break;
+		}				      
+
+		keyCode = CbusRc5toRcpConvert( keyCode );
+		if (keyCode == 0xFF) {
+			printk( "\n::::::: Bad KeyCode -- " );
+			break;
+		}
+
+		success = SI_CbusMscMsgSubCmdSend( channel,
+						MHD_MSC_MSG_RCP,
+						keyCode );
+		break;
+	}
+
+	if ( !success )
+	{
+		printk("Unable to send command :::::::\n");
+	}
+
+	return success;
+}
+
+//------------------------------------------------------------------------------
+// Function:    CpCbusSendRapMessage
+// Parameters:  port    - Port Processor input port index
+//              actionCode - Action code.
+// Returns:     true if successful, false if not MHD port or other failure.
+//------------------------------------------------------------------------------
+
+Bool CpCbusSendRapMessage ( byte channel, byte actCode )
+{
+	Bool  success;
+
+	success = FALSE;
+	for ( ;; )
+	{
+		printk( "CPCBUS:: Sending RAP Msg:: %02X action code"
+			" to channel %d CBUS\n\n",
+			(int)actCode, (int)channel );
+
+		if ( channel == 0xFF) {
+			printk("\n::::::: Bad channel -- ");
+			break;
+		}
+
+		if ((actCode == MHD_RAP_CMD_POLL) ||
+		(actCode == MHD_RAP_CMD_CHG_QUIET) ||
+		(actCode != MHD_RAP_CMD_CHG_ACTIVE_PWR)) {
+			success = SI_CbusMscMsgSubCmdSend(channel,
+						MHD_MSC_MSG_RAP,
+						actCode );
+			break;
+		} else {
+			printk("\n::::::: Bad action code -- ");
+			break;
+		}
+	}
+
+	if (!success) {
+		printk( "Unable to send action command :::::::\n" );
+	}
+
+	return success;
+}
+
+//------------------------------------------------------------------------------
+// Function:    CpProcessRcpMessage
+// Description: Process the passed RCP message.
+// Returns:     The RCPK status code.
+//------------------------------------------------------------------------------
+
+static byte CpProcessRcpMessage ( byte channel, byte rcpData )
+{
+	byte rcpkStatus = MHD_MSC_MSG_NO_ERROR;
+
+	printk("RCP Key Code: 0x%02X, channel: 0x%02X\n",
+			(int)rcpData, (int)channel );
+
+	switch (rcpData) {
+	case MHD_RCP_CMD_SELECT:
+		printk("\nSelect received\n\n");
+		break;
+	case MHD_RCP_CMD_UP:
+		printk("\nUp received\n\n");
+		break;
+	case MHD_RCP_CMD_DOWN:
+		printk("\nDown received\n\n");
+		break;
+	case MHD_RCP_CMD_LEFT:
+		printk("\nLeft received\n\n");
+		break;
+	case MHD_RCP_CMD_RIGHT:
+		printk("\nRight received\n\n");
+		break;
+	case MHD_RCP_CMD_RIGHT_UP:
+		printk("\n MHD_RCP_CMD_RIGHT_UP\n\n");
+		break;
+	case MHD_RCP_CMD_RIGHT_DOWN:
+		printk("\n MHD_RCP_CMD_RIGHT_DOWN \n\n");
+		break;
+	case MHD_RCP_CMD_LEFT_UP:
+		printk("\n MHD_RCP_CMD_LEFT_UP\n\n");
+		break;
+	case MHD_RCP_CMD_LEFT_DOWN:
+		printk("\n MHD_RCP_CMD_LEFT_DOWN\n\n");
+		break;      
+	case MHD_RCP_CMD_ROOT_MENU:
+		printk("\nRoot Menu received\n\n");
+		break;
+	case MHD_RCP_CMD_SETUP_MENU:
+		printk("\n MHD_RCP_CMD_SETUP_MENU\n\n");
+		break;      
+
+	case MHD_RCP_CMD_CONTENTS_MENU:
+		printk("\n MHD_RCP_CMD_CONTENTS_MENU\n\n");
+		break;      
+
+	case MHD_RCP_CMD_FAVORITE_MENU:
+		printk("\n MHD_RCP_CMD_FAVORITE_MENU\n\n");
+		break;            
+
+	case MHD_RCP_CMD_EXIT:
+		printk("\nExit received\n\n");
+		break;
+
+	case MHD_RCP_CMD_NUM_0:
+		printk("\nNumber 0 received\n\n");
+		break;
+
+	case MHD_RCP_CMD_NUM_1:
+		printk("\nNumber 1 received\n\n");
+		break;
+
+	case MHD_RCP_CMD_NUM_2:
+		printk("\nNumber 2 received\n\n");
+		break;
+
+	case MHD_RCP_CMD_NUM_3:
+		printk("\nNumber 3 received\n\n");
+		break;
+
+	case MHD_RCP_CMD_NUM_4:
+		printk("\nNumber 4 received\n\n");
+		break;
+
+	case MHD_RCP_CMD_NUM_5:
+		printk("\nNumber 5 received\n\n");
+		break;
+
+	case MHD_RCP_CMD_NUM_6:
+		printk("\nNumber 6 received\n\n");
+		break;
+
+	case MHD_RCP_CMD_NUM_7:
+		printk("\nNumber 7 received\n\n");
+		break;
+
+	case MHD_RCP_CMD_NUM_8:
+		printk("\nNumber 8 received\n\n");
+		break;
+
+	case MHD_RCP_CMD_NUM_9:
+		printk("\nNumber 9 received\n\n");
+		break;
+
+	case MHD_RCP_CMD_DOT:
+		printk("\n MHD_RCP_CMD_DOT\n\n");
+		break;          
+
+	case MHD_RCP_CMD_ENTER:
+		printk("\nEnter received\n\n");
+		break;
+
+	case MHD_RCP_CMD_CLEAR:
+		printk("\nClear received\n\n");
+		break;
+
+	case MHD_RCP_CMD_CH_UP:
+		printk("\n MHD_RCP_CMD_CH_UP\n\n");
+		break; 
+
+	case MHD_RCP_CMD_CH_DOWN:
+		printk("\n MHD_RCP_CMD_CH_DOWN\n\n");
+		break;       
+
+	case MHD_RCP_CMD_PRE_CH:
+		printk("\n MHD_RCP_CMD_PRE_CH\n\n");
+		break;           
+
+	case MHD_RCP_CMD_SOUND_SELECT:
+		printk("\nSound Select received\n\n");
+		break;
+
+	case MHD_RCP_CMD_INPUT_SELECT:
+		printk("\n MHD_RCP_CMD_INPUT_SELECT\n\n");
+		break;    
+
+	case MHD_RCP_CMD_SHOW_INFO:
+		printk("\n MHD_RCP_CMD_SHOW_INFO\n\n");
+		break;     
+
+	case MHD_RCP_CMD_HELP:
+		printk("\n MHD_RCP_CMD_HELP\n\n");
+		break;   
+
+	case MHD_RCP_CMD_PAGE_UP:
+		printk("\n MHD_RCP_CMD_PAGE_UP\n\n");
+		break;  
+
+	case MHD_RCP_CMD_PAGE_DOWN:
+		printk("\n MHD_RCP_CMD_PAGE_DOWN\n\n");
+		break;             
+
+	case MHD_RCP_CMD_VOL_UP:
+		printk("\n MHD_RCP_CMD_VOL_UP\n\n");
+		break;             
+
+	case MHD_RCP_CMD_VOL_DOWN:
+		printk("\n MHD_RCP_CMD_VOL_DOWN\n\n");
+		break;             
+
+	case MHD_RCP_CMD_MUTE:
+		printk("\n MHD_RCP_CMD_MUTE\n\n");
+		break;             
+
+	case MHD_RCP_CMD_PLAY:
+		printk("\nPlay received\n\n");
+		break;
+
+	case MHD_RCP_CMD_STOP:
+		printk("\n MHD_RCP_CMD_STOP\n\n");
+		break;   
+
+	case MHD_RCP_CMD_PAUSE:
+		printk("\nPause received\n\n");
+		break;
+
+	case MHD_RCP_CMD_RECORD:
+		printk("\n MHD_RCP_CMD_RECORD\n\n");
+		break;   
+
+	case MHD_RCP_CMD_FAST_FWD:
+		printk("\nFastfwd received\n\n");
+		break;
+
+	case MHD_RCP_CMD_REWIND:
+		printk("\nRewind received\n\n");
+		break;
+
+	case MHD_RCP_CMD_EJECT:
+		printk("\nEject received\n\n");
+		break;
+
+	case MHD_RCP_CMD_FWD:
+		printk("\nForward received\n\n");
+		break;
+
+	case MHD_RCP_CMD_BKWD:
+		printk("\nBackward received\n\n");
+		break;
+
+	case MHD_RCP_CMD_PLAY_FUNC:
+		printk("\nPlay Function received\n\n");
+		break;
+
+	case MHD_RCP_CMD_PAUSE_PLAY_FUNC:
+		printk("\nPause_Play Function received\n\n");
+		break;
+
+	case MHD_RCP_CMD_STOP_FUNC:
+		printk("\nStop Function received\n\n");
+		break;
+
+	default:
+		rcpkStatus = MHD_MSC_MSG_INEFFECTIVE_KEY_CODE;
+		break;
+	}
+
+	if ( rcpkStatus == MHD_MSC_MSG_INEFFECTIVE_KEY_CODE ) {
+		printk("\nKeyCode not recognized or supported.\n\n");
+	}
+
+	return rcpkStatus;
+}
+
+//------------------------------------------------------------------------------
+// Function:    CpProcessRapMessage
+// Description: Process the passed RAP message.
+// Returns:     The RAPK status code.
+//------------------------------------------------------------------------------
+
+static byte CpProcessRapMessage ( byte channel, byte rcpData )
+{
+	byte rapkStatus = MHD_MSC_MSG_NO_ERROR;
+
+	printk("RAP Key Code: 0x%02X, channel: 0x%02X\n",
+			(int)rcpData, (int)channel );
+
+	switch (rcpData) {
+	case MHD_RAP_CMD_POLL:
+		printk("\nPOLL received\n\n");
+		break;
+
+	case MHD_RAP_CMD_CHG_ACTIVE_PWR:
+		printk( "\nCHANGE TO ACTIVE POWER STATE"
+				" received\n\n");
+		break;        
+
+	case MHD_RAP_CMD_CHG_QUIET:
+		printk( "\nCHANGE TO QUIET STATE"
+				" received\n\n");
+		//TPI_GoToD3();  //???
+		break;
+
+	default:
+		rapkStatus = MHD_MSC_MSG_RAP_UNRECOGNIZED_ACT_CODE;
+		break;
+	}
+
+	if ( rapkStatus == MHD_MSC_MSG_RAP_UNRECOGNIZED_ACT_CODE ) {
+		printk("\nKeyCode not recognized !! \n\n" );
+	}
+
+	return rapkStatus;
+}
+
+//------------------------------------------------------------------------------
+// Function:    CbusConnectionCheck
+// Description: Display any change in CBUS connection state and enable
+//              CBUS heartbeat if channel has been connected.
+// Parameters:  channel - CBUS channel to check
+//------------------------------------------------------------------------------
+
+static void CbusConnectionCheck (byte channel)
+{
+	static byte busConnected[ MHD_MAX_CHANNELS ] = {0};
+
+	/* If CBUS connection state has changed for this channel,   */
+	/* update channel state and hardware.                       */
+
+	if (busConnected[channel] != SI_CbusChannelConnected(channel)) {
+		busConnected[ channel ] = SI_CbusChannelConnected( channel );
+
+		// heartbeat has been disabled in all products
+		// SI_CbusHeartBeat( channel, busConnected[ channel ] );
+
+		printk("CPCBUS:: ***Channel: %d,  CBUS %s ****\n",
+				(int)channel ,
+				busConnected[ channel ] ?
+				"Connected" : "Unconnected");
+	}
+}
+
+//------------------------------------------------------------------------------
+// Function:    CpCbusProcessPrivateMessage
+// Description: Get the result of the last message sent and use it appropriately
+//              or process a request from the connected device.
+// Parameters:  channel - CBUS channel that has message data for us.
+//------------------------------------------------------------------------------
+
+static void CpCbusProcessPrivateMessage(byte channel)
+{
+	byte     status;
+	cbus_req_t  *pCmdRequest;
+
+	pCmdRequest = SI_CbusRequestData( channel );
+	//CbusRcpData = pCmdRequest->offsetData;
+
+	switch ( pCmdRequest->command ) {
+	case MHD_MSC_MSG_RCP:
+		printk("MHD_MSC_MSG_RCP 1 \n");
+	/* Acknowledge receipt of command and process it.  Note that    */
+	/* we could send the ack before processing anything, because it */
+	/* is an indicator that the command was properly received, not  */
+	/* that it was executed, however, we use one function to parse  */
+	/* the command for errors AND for processing. The only thing we */
+	/* must do is make sure that the processing does not exceed the */
+	/* ACK response time limit.                                     */
+
+	/* MHL v1					*/
+	/* NAGSM_Android_SEL_Kernel_Aakash_20101130	*/
+	/* Inform Kernel only on MHD_MSC_MSG_RCP	*/
+		//CbusRcpData = pCmdRequest->offsetData;
+
+		//rcp_cbus_uevent();
+		//MHL v1 //NAGSM_Android_SEL_Kernel_Aakash_20101126
+
+		status = CpProcessRcpMessage(channel, pCmdRequest->offsetData);
+		SI_CbusRcpMessageAck(channel, status, pCmdRequest->offsetData);
+		break;
+
+	case MHD_MSC_MSG_RCPK:
+		printk("MHD_MSC_MSG_RCPK 1\n");          
+		break;
+
+	case MHD_MSC_MSG_RCPE:  
+		printk("MHD_MSC_MSG_RCPE 1\n");            
+		break;
+
+	case MHD_MSC_MSG_RAP:
+		printk("MHD_MSC_MSG_RAP 1\n");            
+		status = CpProcessRapMessage(channel, pCmdRequest->offsetData );
+			SI_CbusRapMessageAck(channel, status);
+		break;
+
+	case MHD_MSC_MSG_RAPK:  
+		break;
+	}
+}
+
+//------------------------------------------------------------------------------
+// Function:    CpCbusHandler
+// Description: Polls the send/receive state of the CBUS hardware.
+//------------------------------------------------------------------------------
+
+void CpCbusHandler(void)
+{
+	byte channel, status;
+
+	/* Monitor all CBUS channels.   */
+
+	for (channel = 0; channel < MHD_MAX_CHANNELS; channel++) {
+		/* Update CBUS status.  */
+		SI_CbusUpdateBusStatus( channel );
+		CbusConnectionCheck( channel );
+
+		/* Monitor CBUS interrupts. */
+		status = SI_CbusHandler( channel );
+		if ( status == STATUS_SUCCESS ) {
+			/* Get status of current request, if any.   */
+
+			status = SI_CbusRequestStatus( channel );
+			switch ( status ) {
+			case CBUS_REQ_IDLE: 
+				printk("CBUS_REQ_IDLE\n");
+				break;
+
+			case CBUS_REQ_PENDING:
+				printk("CBUS_REQ_PENDING\n");              
+				break;
+
+			case CBUS_REQ_SENT:
+				printk("CBUS_REQ_SENT\n");              
+				break;
+
+			case CBUS_REQ_RECEIVED:
+				printk("CBUS_REQ_RECEIVED\n");  
+			/* Received a message or message response.  */
+			/* Go do what is appropriate.               */
+
+				CpCbusProcessPrivateMessage( channel );
+				break;
+
+			default:
+				break;
+			}
+		} else if ( status == ERROR_NO_HEARTBEAT ) {
+			printk("Lost CBUS channel %d heartbeat\n",
+						(int)channel);
+		} else if ( status == ERROR_NACK_FROM_PEER ) {
+			printk ("NACK received from peer, cmd should be"
+				" sent again.\n");
+		} else {
+		/* Lee: Only thing that comes here is interrupt timeout */
+		/*  -- is this bad? */
+		}
+	}
+}
+
+//------------------------------------------------------------------------------
+// Function:    CpCbusInitialize
+// Description: Initialize the CBUS subsystem and enabled the default channels
+//------------------------------------------------------------------------------
+
+void CpCbusInitialize(void)
+{
+	/* Initialize the basic hardware.   */
+	SI_CbusInitialize();
+}
+#endif
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/si_cpCbus.h news/kernel/drivers/media/video/samsung/mhl_v1/si_cpCbus.h
--- kernel/drivers/media/video/samsung/mhl_v1/si_cpCbus.h	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/si_cpCbus.h	2011-06-17 19:41:22.000000000 +0900
@@ -1,15 +1,37 @@
-//***************************************************************************
-//!file     si_cbus.h
-//!brief    si_apiCbus wrapper for multiple chip.
-//
-// No part of this work may be reproduced, modified, distributed,
-// transmitted, transcribed, or translated into any language or computer
-// format, in any form or by any means without written permission of
-// Silicon Image, Inc., 1060 East Arques Avenue, Sunnyvale, California 94085
-//
-// Copyright 2008-2009, Silicon Image, Inc.  All rights reserved.
-//***************************************************************************/
-
-void CpCbusHandler ( void );
-void CpCbusInitialize ( void );
-
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+
+void CpCbusHandler ( void );
+void CpCbusInitialize ( void );
+
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/sii9234.c news/kernel/drivers/media/video/samsung/mhl_v1/sii9234.c
--- kernel/drivers/media/video/samsung/mhl_v1/sii9234.c	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/sii9234.c	2011-06-17 19:41:22.000000000 +0900
@@ -1,791 +1,796 @@
-/********************************************************************************
-* (C) COPYRIGHT 2010 SAMSUNG ELECTRONICS				*
-* Silicon Image MHL(Mobile HD Link) Transmitter device driver		*
-*									*
-* File Name : sii9234.c							*
-*									*
-* Author    : Aakash Manik 						*
-* 			aakash.manik@samsung.com			*
-*						 			*
-*									*
-* Version   : V1							*
-* Date      : 11/NOV/2010						*
-*				Draft under Review			*
-*									*
-*									*
-* Description: Source file for MHL sii9234 Transciever 			* 
-*									*
-* Version info								*
-* v0.9 : SGH-I997 Project Primitive MHL Driver				*
-*		-  Author Kyungrok Min					*
-*				<gyoungrok.min@samsung.com>		*
-* Version info								*
-* v1.0 : 11/Nov/2010 - Driver Restructuring and  			*
-* 			Integration for Dempsey Project			*
-*									*
-********************************************************************************/
-
-
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/i2c.h>
-#include <linux/gpio.h>
-#include <plat/pm.h>
-#include <asm/irq.h>
-#include <linux/delay.h>
-#include <plat/gpio-cfg.h>
-#include <plat/gpio-core.h>
-#include <mach/regs-gpio.h>
-#include <mach/regs-clock.h>
-#include <linux/miscdevice.h>
-#include <linux/slab.h>
-#include <linux/syscalls.h> 
-#include <linux/fcntl.h> 
-#include <asm/uaccess.h> 
-#include <linux/regulator/consumer.h>
-#include <linux/mfd/max8998.h>
-#include <linux/mfd/max8997.h>
-
-
-#include "sii9234_driver.h"
-#include "Common_Def.h"
-
-
-#define SUBJECT "MHL_DRIVER"
-
-#define SII_DEV_DBG(format,...)\
-	printk ("[ "SUBJECT " (%s,%d) ] " format "\n", __func__, __LINE__, ## __VA_ARGS__);
-
-struct work_struct sii9234_int_work;
-struct workqueue_struct *sii9234_wq = NULL;
-
-struct i2c_driver sii9234_i2c_driver;
-struct i2c_client *sii9234_i2c_client = NULL;
-
-struct i2c_driver sii9234a_i2c_driver;
-struct i2c_client *sii9234a_i2c_client = NULL;
-
-struct i2c_driver sii9234b_i2c_driver;
-struct i2c_client *sii9234b_i2c_client = NULL;
-
-struct i2c_driver sii9234c_i2c_driver;
-struct i2c_client *sii9234c_i2c_client = NULL;
-
-extern bool sii9234_init(void);
-
-static struct i2c_device_id sii9234_id[] = {
-	{"SII9234", 0},
-	{}
-};
-
-static struct i2c_device_id sii9234a_id[] = {
-	{"SII9234A", 0},
-	{}
-};
-
-static struct i2c_device_id sii9234b_id[] = {
-	{"SII9234B", 0},
-	{}
-};
-
-static struct i2c_device_id sii9234c_id[] = {
-	{"SII9234C", 0},
-	{}
-};
-
-int MHL_i2c_init = 0;
-
-
-struct sii9234_state {
-	struct i2c_client *client;
-};
-
-void sii9234_cfg_power(bool on);
-
-static void sii9234_cfg_gpio(void);
-
-irqreturn_t mhl_int_irq_handler(int irq, void *dev_id);
-
-irqreturn_t mhl_wake_up_irq_handler(int irq, void *dev_id);
-
-void sii9234_interrupt_event_work(struct work_struct *p);
-
-#define MHL_SWITCH_TEST	1
-
-#ifdef MHL_SWITCH_TEST
-struct class *sec_mhl;
-EXPORT_SYMBOL(sec_mhl);
-
-struct device *mhl_switch;
-EXPORT_SYMBOL(mhl_switch);
-
-static ssize_t check_MHL_command(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	int count;
-	int res;
-
-	printk(KERN_ERR "[MHL]: check_MHL_command\n");
-	sii9234_cfg_power(1);
-	res = SiI9234_startTPI();
-	count = sprintf(buf,"%d\n", res );
-	sii9234_cfg_power(0);
-	return count;
-
-}
-
-static ssize_t change_switch_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
-{
-	char *after;
-	unsigned long value = simple_strtoul(buf, &after, 10);
-	int i;
-	printk(KERN_ERR "[MHL_SWITCH] Change the switch: %ld\n", value);
-
-	if (value == 0) {
-		for (i = 0; i <20; i++) {
-			printk(KERN_ERR "[MHL] try %d\n", i+1);
-			msleep(500);
-		}
-		s3c_gpio_cfgpin(GPIO_MHL_INT, GPIO_MHL_INT_AF);
-		s3c_gpio_setpull(GPIO_MHL_SEL, S3C_GPIO_PULL_UP);
-		gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_HIGH);
-		sii9234_cfg_power(1);
-		sii9234_init();
-	} else {
-		sii9234_cfg_power(0);
-		s3c_gpio_setpull(GPIO_MHL_SEL, S3C_GPIO_PULL_NONE);
-		gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_LOW);
-	}
-	return size;
-}
-
-void MHL_On(bool on)
-{
-	printk("[MHL] USB path change : %d\n", on);
-	if (on == 1) {
-		if(gpio_get_value(GPIO_MHL_SEL))
-			printk("[MHL] GPIO_MHL_SEL : already 1\n");
-		else {
-			gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_HIGH);
-			sii9234_cfg_power(1);
-			sii9234_init();
-		}	
-	} else {
-		if(!gpio_get_value(GPIO_MHL_SEL))
-			printk("[MHL] GPIO_MHL_SEL : already 0\n");
-		else {	
-			sii9234_cfg_power(0);
-			gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_LOW);
-		}
-	}
-
-}
-EXPORT_SYMBOL(MHL_On);
-
-
-static DEVICE_ATTR(mhl_sel, S_IRUGO | S_IWUSR | S_IXOTH, check_MHL_command, change_switch_store);
-#endif
-
-static ssize_t MHD_check_read(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	int count;
-	int res = 0;
-	#if 0
-
-	s3c_gpio_setpull(GPIO_MHL_SEL, S3C_GPIO_PULL_UP);	//MHL_SEL
-
-	gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_HIGH);
-	
-
-	//TVout_LDO_ctrl(true);
-	
-	if(!MHD_HW_IsOn())
-	{
-		sii9234_tpi_init();
-		res = MHD_Read_deviceID();
-		MHD_HW_Off();		
-	}
-	else
-	{
-		sii9234_tpi_init();
-		res = MHD_Read_deviceID();
-	}
-
-	I2C_WriteByte(0x72, 0xA5, 0xE1);
-	res = 0;
-	res = I2C_ReadByte(0x72, 0xA5);
-
-	printk(KERN_ERR "A5 res %x",res);
-
-	res = 0;
-	res = I2C_ReadByte(0x72, 0x1B);
-
-	printk(KERN_ERR "Device ID res %x",res);
-
-	res = 0;
-	res = I2C_ReadByte(0x72, 0x1C);
-
-	printk(KERN_ERR "Device Rev ID res %x",res);
-
-	res = 0;
-	res = I2C_ReadByte(0x72, 0x1D);
-
-	printk(KERN_ERR "Device Reserved ID res %x",res);
-
-	printk(KERN_ERR "\n####HDMI_EN1 %x MHL_RST %x GPIO_MHL_SEL %x\n",gpio_get_value(GPIO_HDMI_EN),gpio_get_value(GPIO_MHL_RST),gpio_get_value(GPIO_MHL_SEL));
-
-	res = I2C_ReadByte(0x7A, 0x3D);
-
-	res = I2C_ReadByte(0x7A, 0xFF);
-		
-	s3c_gpio_setpull(GPIO_MHL_SEL, S3C_GPIO_PULL_NONE);	//MHL_SEL
-
-	gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_LOW);
-#endif
-	count = sprintf(buf,"%d\n", res );
-	//TVout_LDO_ctrl(false);
-	return count;
-}
-
-static ssize_t MHD_check_write(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
-{
-	printk(KERN_ERR "input data --> %s\n", buf);
-
-	return size;
-}
-
-static DEVICE_ATTR(MHD_file, S_IRUGO , MHD_check_read, MHD_check_write);
-
-
-struct i2c_client* get_sii9234_client(u8 device_id)
-{
-
-	struct i2c_client* client_ptr;
-
-	if(device_id == 0x72)
-		client_ptr = sii9234_i2c_client;
-	else if(device_id == 0x7A)
-		client_ptr = sii9234a_i2c_client;
-	else if(device_id == 0x92)
-		client_ptr = sii9234b_i2c_client;
-	else if(device_id == 0xC8)
-		client_ptr = sii9234c_i2c_client;
-	else
-		client_ptr = NULL;
-
-	return client_ptr;
-}
-EXPORT_SYMBOL(get_sii9234_client);
-
-u8 sii9234_i2c_read(struct i2c_client *client, u8 reg)
-{
-	u8 ret;
-	
-	if(!MHL_i2c_init)
-	{
-		SII_DEV_DBG("I2C not ready");
-		return 0;
-	}
-	
-	i2c_smbus_write_byte(client, reg);
-	
-
-	ret = i2c_smbus_read_byte(client);
-
-	//printk(KERN_ERR "#######Read reg %x data %x\n", reg, ret);
-
-	if (ret < 0)
-	{
-		SII_DEV_DBG("i2c read fail");
-		return -EIO;
-	}
-	return ret;
-
-}
-EXPORT_SYMBOL(sii9234_i2c_read);
-
-
-int sii9234_i2c_write(struct i2c_client *client, u8 reg, u8 data)
-{
-	if(!MHL_i2c_init)
-	{
-		SII_DEV_DBG("I2C not ready");
-		return 0;
-	}
-
-	//printk(KERN_ERR "#######Write reg %x data %x\n", reg, data);
-	return i2c_smbus_write_byte_data(client, reg, data);
-}
-EXPORT_SYMBOL(sii9234_i2c_write);
-
-
-void sii9234_interrupt_event_work(struct work_struct *p)
-{
-
-	printk(KERN_ERR "[MHL]sii9234_interrupt_event_work() is called\n");
-	sii9234_interrupt_event();
-}
-
-
-void mhl_int_irq_handler_sched(void)
-{
-	//printk(KERN_ERR "mhl_int_irq_handler_sched() is called\n");
-	queue_work(sii9234_wq, &sii9234_int_work);		
-}
-
-
-irqreturn_t mhl_int_irq_handler(int irq, void *dev_id)
-{
-	printk(KERN_ERR "[MHL]mhl_int_irq_handler() is called\n");
-
-	if (gpio_get_value(GPIO_MHL_SEL))	
-		mhl_int_irq_handler_sched();
-
-	return IRQ_HANDLED;
-}
-
- 
-irqreturn_t mhl_wake_up_irq_handler(int irq, void *dev_id)
-{
-
-	printk(KERN_ERR "mhl_wake_up_irq_handler() is called\n");
-
-	if (gpio_get_value(GPIO_MHL_SEL))	
-		mhl_int_irq_handler_sched();
-	
-	return IRQ_HANDLED;
-}
-
-static int sii9234_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	/* int retval; */
-
-	struct sii9234_state *state;
-
-	struct class *mhl_class;
-	struct device *mhl_dev;
-
-	state = kzalloc(sizeof(struct sii9234_state), GFP_KERNEL);
-	if (state == NULL) {		
-		printk(KERN_ERR "failed to allocate memory \n");
-		return -ENOMEM;
-	}
-	
-	state->client = client;
-	i2c_set_clientdata(client, state);
-
-
-	
-	/* rest of the initialisation goes here. */
-	
-	printk(KERN_ERR "SII9234 attach success!!!\n");
-
-	sii9234_i2c_client = client;
-
-	MHL_i2c_init = 1;
-
-	mhl_class = class_create(THIS_MODULE, "mhl");
-	if (IS_ERR(mhl_class))
-	{
-		pr_err("Failed to create class(mhl)!\n");
-	}
-
-	mhl_dev = device_create(mhl_class, NULL, 0, NULL, "mhl_dev");
-	if (IS_ERR(mhl_dev))
-	{
-		pr_err("Failed to create device(mhl_dev)!\n");
-	}
-
-	if (device_create_file(mhl_dev, &dev_attr_MHD_file) < 0)
-		printk(KERN_ERR "Failed to create device file(%s)!\n", dev_attr_MHD_file.attr.name);
-
-	return 0;
-
-}
-
-
-
-static int __devexit sii9234_remove(struct i2c_client *client)
-{
-	struct sii9234_state *state = i2c_get_clientdata(client);
-	kfree(state);
-
-	return 0;
-}
-
-static int sii9234a_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	struct sii9234_state *state;
-
-	state = kzalloc(sizeof(struct sii9234_state), GFP_KERNEL);
-	if (state == NULL) {		
-		printk(KERN_ERR "failed to allocate memory \n");
-		return -ENOMEM;
-	}
-	
-	state->client = client;
-	i2c_set_clientdata(client, state);
-	
-	/* rest of the initialisation goes here. */
-	
-	printk(KERN_ERR "SII9234A attach success!!!\n");
-
-	sii9234a_i2c_client = client;
-
-	return 0;
-
-}
-
-
-
-static int __devexit sii9234a_remove(struct i2c_client *client)
-{
-	struct sii9234_state *state = i2c_get_clientdata(client);
-	kfree(state);
-	return 0;
-}
-
-static int sii9234b_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	struct sii9234_state *state;
-
-	state = kzalloc(sizeof(struct sii9234_state), GFP_KERNEL);
-	if (state == NULL) {		
-		printk(KERN_ERR "failed to allocate memory \n");
-		return -ENOMEM;
-	}
-	
-	state->client = client;
-	i2c_set_clientdata(client, state);
-	
-	/* rest of the initialisation goes here. */
-	
-	printk(KERN_ERR "SII9234B attach success!!!\n");
-
-	sii9234b_i2c_client = client;
-
-	
-	return 0;
-
-}
-
-
-
-static int __devexit sii9234b_remove(struct i2c_client *client)
-{
-	struct sii9234_state *state = i2c_get_clientdata(client);
-	kfree(state);
-	return 0;
-}
-
-
-static int sii9234c_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	struct sii9234_state *state;
-	int ret;
-
-	state = kzalloc(sizeof(struct sii9234_state), GFP_KERNEL);
-	if (state == NULL) {		
-		printk(KERN_ERR "failed to allocate memory \n");
-		return -ENOMEM;
-	}
-	
-	state->client = client;
-	i2c_set_clientdata(client, state);
-	
-	/* rest of the initialisation goes here. */
-	
-	printk(KERN_ERR "SII9234C attach success!!!\n");
-
-	sii9234c_i2c_client = client;
-
-	msleep(100);	
-
-	sii9234_wq = create_singlethread_workqueue("sii9234_wq");
-	INIT_WORK(&sii9234_int_work, sii9234_interrupt_event_work);
-
-	ret = request_threaded_irq(MHL_INT_IRQ, NULL, mhl_int_irq_handler,
-				IRQF_SHARED , "mhl_int", (void *) state); 
-	if (ret) {
-		printk(KERN_ERR "unable to request irq mhl_int"
-					" err:: %d\n", ret);
-		return ret;
-	}		
-	printk(KERN_ERR "MHL int reques successful %d\n", ret);
-	
-	ret = request_threaded_irq(MHL_WAKEUP_IRQ, NULL,
-		mhl_wake_up_irq_handler, IRQF_SHARED,
-		"mhl_wake_up", (void *) state);
-	if (ret) {
-		printk(KERN_ERR "unable to request irq mhl_wake_up"
-					" err:: %d\n", ret);
-		return ret;
-	}		
-	
-	return 0;
-
-}
-
-
-
-static int __devexit sii9234c_remove(struct i2c_client *client)
-{
-	struct sii9234_state *state = i2c_get_clientdata(client);
-	kfree(state);
-	return 0;
-}
-
-struct i2c_driver sii9234_i2c_driver = {
-	.driver = {
-		.owner	= THIS_MODULE,
-		.name	= "SII9234",
-	},
-	.id_table	= sii9234_id,
-	.probe	= sii9234_i2c_probe,
-	.remove	= __devexit_p(sii9234_remove),
-	.command = NULL,
-};
-
-struct i2c_driver sii9234a_i2c_driver = {
-	.driver = {
-		.owner	= THIS_MODULE,
-		.name	= "SII9234A",
-	},
-	.id_table	= sii9234a_id,
-	.probe	= sii9234a_i2c_probe,
-	.remove	= __devexit_p(sii9234a_remove),
-	.command = NULL,
-};
-
-struct i2c_driver sii9234b_i2c_driver = {
-	.driver = {
-		.owner	= THIS_MODULE,
-		.name	= "SII9234B",
-	},
-	.id_table	= sii9234b_id,
-	.probe	= sii9234b_i2c_probe,
-	.remove	= __devexit_p(sii9234b_remove),
-	.command = NULL,
-};
-
-struct i2c_driver sii9234c_i2c_driver = {
-	.driver = {
-		.owner	= THIS_MODULE,
-		.name	= "SII9234C",
-	},
-	.id_table	= sii9234c_id,
-	.probe	= sii9234c_i2c_probe,
-	.remove	= __devexit_p(sii9234c_remove),
-	.command = NULL,
-};
-
-
-extern struct device * fimc_get_active_device(void);
-
-
-void sii9234_cfg_power(bool on)
-{
-
-	if(on)
-	{
-//		s3c_gpio_cfgpin(GPIO_HDMI_EN,S3C_GPIO_OUTPUT);	//HDMI_EN
-#ifdef CONFIG_TARGET_LOCALE_KOR
-		gpio_set_value(GPIO_HDMI_EN,GPIO_LEVEL_HIGH);
-#else
-		if(system_rev < 7)
-			gpio_set_value(GPIO_HDMI_EN,GPIO_LEVEL_HIGH);
-		else
-			gpio_set_value(GPIO_HDMI_EN_REV07,GPIO_LEVEL_HIGH);
-#endif
-		
-		s3c_gpio_cfgpin(GPIO_MHL_RST,S3C_GPIO_OUTPUT);	//MHL_RST
-		s3c_gpio_setpull(GPIO_MHL_RST, S3C_GPIO_PULL_NONE);
-	
-
-		s3c_gpio_setpull(GPIO_AP_SCL_18V, S3C_GPIO_PULL_DOWN);
-		gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_LOW);
-		msleep(10);
-		gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_HIGH);
-		s3c_gpio_setpull(GPIO_AP_SCL_18V, S3C_GPIO_PULL_NONE);
-
-		sii9234_unmaks_interrupt();
-	}
-	else
-	{
-		gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_LOW);
-		msleep(10);
-		gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_HIGH);
-#ifdef CONFIG_TARGET_LOCALE_KOR
-		gpio_set_value(GPIO_HDMI_EN,GPIO_LEVEL_HIGH);
-#else
-		if(system_rev < 7)
-		  gpio_set_value(GPIO_HDMI_EN,GPIO_LEVEL_LOW);
-		else
-			gpio_set_value(GPIO_HDMI_EN_REV07,GPIO_LEVEL_LOW);
-#endif
-		gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_LOW);
-	}
-	printk(KERN_ERR "[MHL]%s : %d \n",__func__,on);
-
-out:
-	return;
-}
-
-
-static void sii9234_cfg_gpio()
-{
-	s3c_gpio_cfgpin(GPIO_AP_SDA_18V, S3C_GPIO_SFN(0x0));	//AP_MHL_SDA
-	s3c_gpio_setpull(GPIO_AP_SDA_18V, S3C_GPIO_PULL_NONE);
-
-	s3c_gpio_cfgpin(GPIO_AP_SCL_18V,S3C_GPIO_SFN(0x1));	//AP_MHL_SCL
-	s3c_gpio_setpull(GPIO_AP_SCL_18V, S3C_GPIO_PULL_NONE);
-
-	s3c_gpio_cfgpin(GPIO_MHL_WAKE_UP,S3C_GPIO_INPUT);//GPH1(6) XEINT 14
-	set_irq_type(MHL_WAKEUP_IRQ, IRQ_TYPE_EDGE_RISING);
-	s3c_gpio_setpull(GPIO_MHL_WAKE_UP, S3C_GPIO_PULL_DOWN);
-
-	s3c_gpio_setpull(GPIO_MHL_INT, S3C_GPIO_PULL_DOWN);
-	set_irq_type(MHL_INT_IRQ, IRQ_TYPE_EDGE_RISING);
-	s3c_gpio_cfgpin(GPIO_MHL_INT, GPIO_MHL_INT_AF); 
-
-#ifdef CONFIG_TARGET_LOCALE_KOR
-	s3c_gpio_cfgpin(GPIO_HDMI_EN,S3C_GPIO_OUTPUT);	//HDMI_EN
-	gpio_set_value(GPIO_HDMI_EN,GPIO_LEVEL_LOW);
-	s3c_gpio_setpull(GPIO_HDMI_EN, S3C_GPIO_PULL_NONE);
-#else
-	if(system_rev < 7) {
-		s3c_gpio_cfgpin(GPIO_HDMI_EN,S3C_GPIO_OUTPUT);	//HDMI_EN
-		gpio_set_value(GPIO_HDMI_EN,GPIO_LEVEL_LOW);
-		s3c_gpio_setpull(GPIO_HDMI_EN, S3C_GPIO_PULL_NONE);
-	}
-	else {
-		s3c_gpio_cfgpin(GPIO_HDMI_EN_REV07,S3C_GPIO_OUTPUT);	//HDMI_EN
-		gpio_set_value(GPIO_HDMI_EN_REV07,GPIO_LEVEL_LOW);
-		s3c_gpio_setpull(GPIO_HDMI_EN_REV07, S3C_GPIO_PULL_NONE);
-	}
-#endif
-
-	s3c_gpio_cfgpin(GPIO_MHL_RST,S3C_GPIO_OUTPUT);
-	s3c_gpio_setpull(GPIO_MHL_RST, S3C_GPIO_PULL_NONE);
-	gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_LOW);
-
-	s3c_gpio_cfgpin(GPIO_MHL_SEL,S3C_GPIO_OUTPUT);
-	s3c_gpio_setpull(GPIO_MHL_SEL, S3C_GPIO_PULL_NONE);
-	gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_LOW);
-
-}
-
-static int mhl_open(struct inode *ip, struct file *fp)
-{
-	printk(KERN_ERR "[%s] \n",__func__);
-	return 0;
-
-}
-
-static int mhl_release(struct inode *ip, struct file *fp)
-{
-	
-	printk(KERN_ERR "[%s] \n",__func__);
-	return 0;
-}
-
-
-static int mhl_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	printk(KERN_ERR "[%s] \n",__func__);
-
-#if 0
-	byte data;
-
-	switch(cmd)
-	{
-		case MHL_READ_RCP_DATA:
-			data = GetCbusRcpData();
-			ResetCbusRcpData();
-			put_user(data,(byte *)arg);
-			printk(KERN_ERR "MHL_READ_RCP_DATA read");
-			break;
-		
-		default:
-		break;
-	}
-#endif		
-	return 0;
-}
-
-static struct file_operations mhl_fops = {
-	.owner  = THIS_MODULE,
-	.open   = mhl_open,
-    	.release = mhl_release,
-    	.ioctl = mhl_ioctl,
-};
-                 
-static struct miscdevice mhl_device = {
-    .minor  = MISC_DYNAMIC_MINOR,
-    .name   = "mhl",
-    .fops   = &mhl_fops,
-};
-
-static int __init sii9234_module_init(void)
-{
-	int ret;
-
-	sii9234_cfg_gpio();
-
-	/* sii9234_cfg_power(1);	//Turn On power to sii9234 
-	*/
-
-#ifdef MHL_SWITCH_TEST
-	sec_mhl = class_create(THIS_MODULE, "sec_mhl");
-	if (IS_ERR(sec_mhl))
-		printk(KERN_ERR "[MHL] Failed to create class (sec_mhl)\n");
-
-	mhl_switch = device_create(sec_mhl, NULL, 0, NULL, "switch");
-	if (IS_ERR(mhl_switch))
-		printk(KERN_ERR "[MHL] Failed to create device (mhl_switch)\n");
-	if (device_create_file(mhl_switch, &dev_attr_mhl_sel) < 0)
-		printk(KERN_ERR "[MHL] Failed to create file (mhl_sel)");
-#endif
-
-	ret = misc_register(&mhl_device);
-	if(ret) {
-		pr_err(KERN_ERR "misc_register failed - mhl \n");
-	}
-
-	ret = i2c_add_driver(&sii9234_i2c_driver);
-	if (ret != 0)
-		printk(KERN_ERR "[MHL SII9234] can't add i2c driver\n");	
-	else
-		printk(KERN_ERR "[MHL SII9234] add i2c driver\n");
-	ret = i2c_add_driver(&sii9234a_i2c_driver);
-	if (ret != 0)
-		printk(KERN_ERR "[MHL SII9234A] can't add i2c driver\n");	
-	else
-		printk(KERN_ERR "[MHL SII9234A] add i2c driver\n");
-	ret = i2c_add_driver(&sii9234b_i2c_driver);
-	if (ret != 0)
-		printk(KERN_ERR "[MHL SII9234B] can't add i2c driver\n");	
-	else
-		printk(KERN_ERR "[MHL SII9234B] add i2c driver\n");
-
-	ret = i2c_add_driver(&sii9234c_i2c_driver);
-	if (ret != 0)
-		printk(KERN_ERR "[MHL SII9234C] can't add i2c driver\n");	
-	else
-		printk(KERN_ERR "[MHL SII9234C] add i2c driver\n");
-
-	return ret;	
-}
-module_init(sii9234_module_init);
-static void __exit sii9234_exit(void)
-{
-	i2c_del_driver(&sii9234_i2c_driver);
-	i2c_del_driver(&sii9234a_i2c_driver);
-	i2c_del_driver(&sii9234b_i2c_driver);	
-	i2c_del_driver(&sii9234c_i2c_driver);
-	
-};
-module_exit(sii9234_exit);
-
-MODULE_DESCRIPTION("Sii9234 MHL driver");
-MODULE_AUTHOR("Aakash Manik");
-MODULE_LICENSE("GPL");
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <plat/pm.h>
+#include <asm/irq.h>
+#include <linux/delay.h>
+#include <plat/gpio-cfg.h>
+#include <plat/gpio-core.h>
+#include <mach/regs-gpio.h>
+#include <mach/regs-clock.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/syscalls.h> 
+#include <linux/fcntl.h> 
+#include <asm/uaccess.h> 
+#include <linux/regulator/consumer.h>
+#include <linux/mfd/max8998.h>
+#include <linux/mfd/max8997.h>
+
+
+#include "sii9234_driver.h"
+#include "Common_Def.h"
+
+
+#define SUBJECT "MHL_DRIVER"
+
+#define SII_DEV_DBG(format,...)\
+	printk ("[ "SUBJECT " (%s,%d) ] " format "\n", __func__, __LINE__, ## __VA_ARGS__);
+
+struct work_struct sii9234_int_work;
+struct workqueue_struct *sii9234_wq = NULL;
+
+struct i2c_driver sii9234_i2c_driver;
+struct i2c_client *sii9234_i2c_client = NULL;
+
+struct i2c_driver sii9234a_i2c_driver;
+struct i2c_client *sii9234a_i2c_client = NULL;
+
+struct i2c_driver sii9234b_i2c_driver;
+struct i2c_client *sii9234b_i2c_client = NULL;
+
+struct i2c_driver sii9234c_i2c_driver;
+struct i2c_client *sii9234c_i2c_client = NULL;
+
+extern bool sii9234_init(void);
+
+static struct i2c_device_id sii9234_id[] = {
+	{"SII9234", 0},
+	{}
+};
+
+static struct i2c_device_id sii9234a_id[] = {
+	{"SII9234A", 0},
+	{}
+};
+
+static struct i2c_device_id sii9234b_id[] = {
+	{"SII9234B", 0},
+	{}
+};
+
+static struct i2c_device_id sii9234c_id[] = {
+	{"SII9234C", 0},
+	{}
+};
+
+int MHL_i2c_init = 0;
+
+
+struct sii9234_state {
+	struct i2c_client *client;
+};
+
+void sii9234_cfg_power(bool on);
+
+static void sii9234_cfg_gpio(void);
+
+irqreturn_t mhl_int_irq_handler(int irq, void *dev_id);
+
+irqreturn_t mhl_wake_up_irq_handler(int irq, void *dev_id);
+
+void sii9234_interrupt_event_work(struct work_struct *p);
+
+#define MHL_SWITCH_TEST	1
+
+#ifdef MHL_SWITCH_TEST
+struct class *sec_mhl;
+EXPORT_SYMBOL(sec_mhl);
+
+struct device *mhl_switch;
+EXPORT_SYMBOL(mhl_switch);
+
+static ssize_t check_MHL_command(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int count;
+	int res;
+
+	printk(KERN_ERR "[MHL]: check_MHL_command\n");
+	sii9234_cfg_power(1);
+	res = SiI9234_startTPI();
+	count = sprintf(buf,"%d\n", res );
+	sii9234_cfg_power(0);
+	return count;
+
+}
+
+static ssize_t change_switch_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	char *after;
+	unsigned long value = simple_strtoul(buf, &after, 10);
+	int i;
+	printk(KERN_ERR "[MHL_SWITCH] Change the switch: %ld\n", value);
+
+	if (value == 0) {
+		for (i = 0; i <20; i++) {
+			printk(KERN_ERR "[MHL] try %d\n", i+1);
+			msleep(500);
+		}
+		s3c_gpio_cfgpin(GPIO_MHL_INT, GPIO_MHL_INT_AF);
+		s3c_gpio_setpull(GPIO_MHL_SEL, S3C_GPIO_PULL_UP);
+		gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_HIGH);
+		sii9234_cfg_power(1);
+		sii9234_init();
+	} else {
+		sii9234_cfg_power(0);
+		s3c_gpio_setpull(GPIO_MHL_SEL, S3C_GPIO_PULL_NONE);
+		gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_LOW);
+	}
+	return size;
+}
+
+void MHL_On(bool on)
+{
+	printk("[MHL] USB path change : %d\n", on);
+	if (on == 1) {
+		if(gpio_get_value(GPIO_MHL_SEL))
+			printk("[MHL] GPIO_MHL_SEL : already 1\n");
+		else {
+			gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_HIGH);
+			sii9234_cfg_power(1);
+			sii9234_init();
+		}	
+	} else {
+		if(!gpio_get_value(GPIO_MHL_SEL))
+			printk("[MHL] GPIO_MHL_SEL : already 0\n");
+		else {	
+			sii9234_cfg_power(0);
+			gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_LOW);
+		}
+	}
+
+}
+EXPORT_SYMBOL(MHL_On);
+
+
+static DEVICE_ATTR(mhl_sel, S_IRUGO | S_IWUSR | S_IXOTH, check_MHL_command, change_switch_store);
+#endif
+
+static ssize_t MHD_check_read(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int count;
+	int res = 0;
+	#if 0
+
+	s3c_gpio_setpull(GPIO_MHL_SEL, S3C_GPIO_PULL_UP);	//MHL_SEL
+
+	gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_HIGH);
+	
+
+	//TVout_LDO_ctrl(true);
+	
+	if(!MHD_HW_IsOn())
+	{
+		sii9234_tpi_init();
+		res = MHD_Read_deviceID();
+		MHD_HW_Off();		
+	}
+	else
+	{
+		sii9234_tpi_init();
+		res = MHD_Read_deviceID();
+	}
+
+	I2C_WriteByte(0x72, 0xA5, 0xE1);
+	res = 0;
+	res = I2C_ReadByte(0x72, 0xA5);
+
+	printk(KERN_ERR "A5 res %x",res);
+
+	res = 0;
+	res = I2C_ReadByte(0x72, 0x1B);
+
+	printk(KERN_ERR "Device ID res %x",res);
+
+	res = 0;
+	res = I2C_ReadByte(0x72, 0x1C);
+
+	printk(KERN_ERR "Device Rev ID res %x",res);
+
+	res = 0;
+	res = I2C_ReadByte(0x72, 0x1D);
+
+	printk(KERN_ERR "Device Reserved ID res %x",res);
+
+	printk(KERN_ERR "\n####HDMI_EN1 %x MHL_RST %x GPIO_MHL_SEL %x\n",gpio_get_value(GPIO_HDMI_EN),gpio_get_value(GPIO_MHL_RST),gpio_get_value(GPIO_MHL_SEL));
+
+	res = I2C_ReadByte(0x7A, 0x3D);
+
+	res = I2C_ReadByte(0x7A, 0xFF);
+		
+	s3c_gpio_setpull(GPIO_MHL_SEL, S3C_GPIO_PULL_NONE);	//MHL_SEL
+
+	gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_LOW);
+#endif
+	count = sprintf(buf,"%d\n", res );
+	//TVout_LDO_ctrl(false);
+	return count;
+}
+
+static ssize_t MHD_check_write(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	printk(KERN_ERR "input data --> %s\n", buf);
+
+	return size;
+}
+
+static DEVICE_ATTR(MHD_file, S_IRUGO , MHD_check_read, MHD_check_write);
+
+
+struct i2c_client* get_sii9234_client(u8 device_id)
+{
+
+	struct i2c_client* client_ptr;
+
+	if(device_id == 0x72)
+		client_ptr = sii9234_i2c_client;
+	else if(device_id == 0x7A)
+		client_ptr = sii9234a_i2c_client;
+	else if(device_id == 0x92)
+		client_ptr = sii9234b_i2c_client;
+	else if(device_id == 0xC8)
+		client_ptr = sii9234c_i2c_client;
+	else
+		client_ptr = NULL;
+
+	return client_ptr;
+}
+EXPORT_SYMBOL(get_sii9234_client);
+
+u8 sii9234_i2c_read(struct i2c_client *client, u8 reg)
+{
+	u8 ret;
+	
+	if(!MHL_i2c_init)
+	{
+		SII_DEV_DBG("I2C not ready");
+		return 0;
+	}
+	
+	i2c_smbus_write_byte(client, reg);
+	
+
+	ret = i2c_smbus_read_byte(client);
+
+	//printk(KERN_ERR "#######Read reg %x data %x\n", reg, ret);
+
+	if (ret < 0)
+	{
+		SII_DEV_DBG("i2c read fail");
+		return -EIO;
+	}
+	return ret;
+
+}
+EXPORT_SYMBOL(sii9234_i2c_read);
+
+
+int sii9234_i2c_write(struct i2c_client *client, u8 reg, u8 data)
+{
+	if(!MHL_i2c_init)
+	{
+		SII_DEV_DBG("I2C not ready");
+		return 0;
+	}
+
+	//printk(KERN_ERR "#######Write reg %x data %x\n", reg, data);
+	return i2c_smbus_write_byte_data(client, reg, data);
+}
+EXPORT_SYMBOL(sii9234_i2c_write);
+
+
+void sii9234_interrupt_event_work(struct work_struct *p)
+{
+
+	printk(KERN_ERR "[MHL]sii9234_interrupt_event_work() is called\n");
+	sii9234_interrupt_event();
+}
+
+
+void mhl_int_irq_handler_sched(void)
+{
+	//printk(KERN_ERR "mhl_int_irq_handler_sched() is called\n");
+	queue_work(sii9234_wq, &sii9234_int_work);		
+}
+
+
+irqreturn_t mhl_int_irq_handler(int irq, void *dev_id)
+{
+	printk(KERN_ERR "[MHL]mhl_int_irq_handler() is called\n");
+
+	if (gpio_get_value(GPIO_MHL_SEL))	
+		mhl_int_irq_handler_sched();
+
+	return IRQ_HANDLED;
+}
+
+ 
+irqreturn_t mhl_wake_up_irq_handler(int irq, void *dev_id)
+{
+
+	printk(KERN_ERR "mhl_wake_up_irq_handler() is called\n");
+
+	if (gpio_get_value(GPIO_MHL_SEL))	
+		mhl_int_irq_handler_sched();
+	
+	return IRQ_HANDLED;
+}
+
+static int sii9234_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	/* int retval; */
+
+	struct sii9234_state *state;
+
+	struct class *mhl_class;
+	struct device *mhl_dev;
+
+	state = kzalloc(sizeof(struct sii9234_state), GFP_KERNEL);
+	if (state == NULL) {		
+		printk(KERN_ERR "failed to allocate memory \n");
+		return -ENOMEM;
+	}
+	
+	state->client = client;
+	i2c_set_clientdata(client, state);
+
+
+	
+	/* rest of the initialisation goes here. */
+	
+	printk(KERN_ERR "SII9234 attach success!!!\n");
+
+	sii9234_i2c_client = client;
+
+	MHL_i2c_init = 1;
+
+	mhl_class = class_create(THIS_MODULE, "mhl");
+	if (IS_ERR(mhl_class))
+	{
+		pr_err("Failed to create class(mhl)!\n");
+	}
+
+	mhl_dev = device_create(mhl_class, NULL, 0, NULL, "mhl_dev");
+	if (IS_ERR(mhl_dev))
+	{
+		pr_err("Failed to create device(mhl_dev)!\n");
+	}
+
+	if (device_create_file(mhl_dev, &dev_attr_MHD_file) < 0)
+		printk(KERN_ERR "Failed to create device file(%s)!\n", dev_attr_MHD_file.attr.name);
+
+	return 0;
+
+}
+
+
+
+static int __devexit sii9234_remove(struct i2c_client *client)
+{
+	struct sii9234_state *state = i2c_get_clientdata(client);
+	kfree(state);
+
+	return 0;
+}
+
+static int sii9234a_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct sii9234_state *state;
+
+	state = kzalloc(sizeof(struct sii9234_state), GFP_KERNEL);
+	if (state == NULL) {		
+		printk(KERN_ERR "failed to allocate memory \n");
+		return -ENOMEM;
+	}
+	
+	state->client = client;
+	i2c_set_clientdata(client, state);
+	
+	/* rest of the initialisation goes here. */
+	
+	printk(KERN_ERR "SII9234A attach success!!!\n");
+
+	sii9234a_i2c_client = client;
+
+	return 0;
+
+}
+
+
+
+static int __devexit sii9234a_remove(struct i2c_client *client)
+{
+	struct sii9234_state *state = i2c_get_clientdata(client);
+	kfree(state);
+	return 0;
+}
+
+static int sii9234b_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct sii9234_state *state;
+
+	state = kzalloc(sizeof(struct sii9234_state), GFP_KERNEL);
+	if (state == NULL) {		
+		printk(KERN_ERR "failed to allocate memory \n");
+		return -ENOMEM;
+	}
+	
+	state->client = client;
+	i2c_set_clientdata(client, state);
+	
+	/* rest of the initialisation goes here. */
+	
+	printk(KERN_ERR "SII9234B attach success!!!\n");
+
+	sii9234b_i2c_client = client;
+
+	
+	return 0;
+
+}
+
+
+
+static int __devexit sii9234b_remove(struct i2c_client *client)
+{
+	struct sii9234_state *state = i2c_get_clientdata(client);
+	kfree(state);
+	return 0;
+}
+
+
+static int sii9234c_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct sii9234_state *state;
+	int ret;
+
+	state = kzalloc(sizeof(struct sii9234_state), GFP_KERNEL);
+	if (state == NULL) {		
+		printk(KERN_ERR "failed to allocate memory \n");
+		return -ENOMEM;
+	}
+	
+	state->client = client;
+	i2c_set_clientdata(client, state);
+	
+	/* rest of the initialisation goes here. */
+	
+	printk(KERN_ERR "SII9234C attach success!!!\n");
+
+	sii9234c_i2c_client = client;
+
+	msleep(100);	
+
+	sii9234_wq = create_singlethread_workqueue("sii9234_wq");
+	INIT_WORK(&sii9234_int_work, sii9234_interrupt_event_work);
+
+	ret = request_threaded_irq(MHL_INT_IRQ, NULL, mhl_int_irq_handler,
+				IRQF_SHARED , "mhl_int", (void *) state); 
+	if (ret) {
+		printk(KERN_ERR "unable to request irq mhl_int"
+					" err:: %d\n", ret);
+		return ret;
+	}		
+	printk(KERN_ERR "MHL int reques successful %d\n", ret);
+	
+	ret = request_threaded_irq(MHL_WAKEUP_IRQ, NULL,
+		mhl_wake_up_irq_handler, IRQF_SHARED,
+		"mhl_wake_up", (void *) state);
+	if (ret) {
+		printk(KERN_ERR "unable to request irq mhl_wake_up"
+					" err:: %d\n", ret);
+		return ret;
+	}		
+	
+	return 0;
+
+}
+
+
+
+static int __devexit sii9234c_remove(struct i2c_client *client)
+{
+	struct sii9234_state *state = i2c_get_clientdata(client);
+	kfree(state);
+	return 0;
+}
+
+struct i2c_driver sii9234_i2c_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "SII9234",
+	},
+	.id_table	= sii9234_id,
+	.probe	= sii9234_i2c_probe,
+	.remove	= __devexit_p(sii9234_remove),
+	.command = NULL,
+};
+
+struct i2c_driver sii9234a_i2c_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "SII9234A",
+	},
+	.id_table	= sii9234a_id,
+	.probe	= sii9234a_i2c_probe,
+	.remove	= __devexit_p(sii9234a_remove),
+	.command = NULL,
+};
+
+struct i2c_driver sii9234b_i2c_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "SII9234B",
+	},
+	.id_table	= sii9234b_id,
+	.probe	= sii9234b_i2c_probe,
+	.remove	= __devexit_p(sii9234b_remove),
+	.command = NULL,
+};
+
+struct i2c_driver sii9234c_i2c_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "SII9234C",
+	},
+	.id_table	= sii9234c_id,
+	.probe	= sii9234c_i2c_probe,
+	.remove	= __devexit_p(sii9234c_remove),
+	.command = NULL,
+};
+
+
+extern struct device * fimc_get_active_device(void);
+
+
+void sii9234_cfg_power(bool on)
+{
+
+	if(on)
+	{
+//		s3c_gpio_cfgpin(GPIO_HDMI_EN,S3C_GPIO_OUTPUT);	//HDMI_EN
+#ifdef CONFIG_TARGET_LOCALE_KOR
+		gpio_set_value(GPIO_HDMI_EN,GPIO_LEVEL_HIGH);
+#else
+		if(system_rev < 7)
+			gpio_set_value(GPIO_HDMI_EN,GPIO_LEVEL_HIGH);
+		else
+			gpio_set_value(GPIO_HDMI_EN_REV07,GPIO_LEVEL_HIGH);
+#endif
+		
+		s3c_gpio_cfgpin(GPIO_MHL_RST,S3C_GPIO_OUTPUT);	//MHL_RST
+		s3c_gpio_setpull(GPIO_MHL_RST, S3C_GPIO_PULL_NONE);
+	
+
+		s3c_gpio_setpull(GPIO_AP_SCL_18V, S3C_GPIO_PULL_DOWN);
+		gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_LOW);
+		msleep(10);
+		gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_HIGH);
+		s3c_gpio_setpull(GPIO_AP_SCL_18V, S3C_GPIO_PULL_NONE);
+
+		sii9234_unmaks_interrupt();
+	}
+	else
+	{
+		gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_LOW);
+		msleep(10);
+		gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_HIGH);
+#ifdef CONFIG_TARGET_LOCALE_KOR
+		gpio_set_value(GPIO_HDMI_EN,GPIO_LEVEL_HIGH);
+#else
+		if(system_rev < 7)
+		  gpio_set_value(GPIO_HDMI_EN,GPIO_LEVEL_LOW);
+		else
+			gpio_set_value(GPIO_HDMI_EN_REV07,GPIO_LEVEL_LOW);
+#endif
+		gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_LOW);
+	}
+	printk(KERN_ERR "[MHL]%s : %d \n",__func__,on);
+
+out:
+	return;
+}
+
+
+static void sii9234_cfg_gpio()
+{
+	s3c_gpio_cfgpin(GPIO_AP_SDA_18V, S3C_GPIO_SFN(0x0));	//AP_MHL_SDA
+	s3c_gpio_setpull(GPIO_AP_SDA_18V, S3C_GPIO_PULL_NONE);
+
+	s3c_gpio_cfgpin(GPIO_AP_SCL_18V,S3C_GPIO_SFN(0x1));	//AP_MHL_SCL
+	s3c_gpio_setpull(GPIO_AP_SCL_18V, S3C_GPIO_PULL_NONE);
+
+	s3c_gpio_cfgpin(GPIO_MHL_WAKE_UP,S3C_GPIO_INPUT);//GPH1(6) XEINT 14
+	set_irq_type(MHL_WAKEUP_IRQ, IRQ_TYPE_EDGE_RISING);
+	s3c_gpio_setpull(GPIO_MHL_WAKE_UP, S3C_GPIO_PULL_DOWN);
+
+	s3c_gpio_setpull(GPIO_MHL_INT, S3C_GPIO_PULL_DOWN);
+	set_irq_type(MHL_INT_IRQ, IRQ_TYPE_EDGE_RISING);
+	s3c_gpio_cfgpin(GPIO_MHL_INT, GPIO_MHL_INT_AF); 
+
+#ifdef CONFIG_TARGET_LOCALE_KOR
+	s3c_gpio_cfgpin(GPIO_HDMI_EN,S3C_GPIO_OUTPUT);	//HDMI_EN
+	gpio_set_value(GPIO_HDMI_EN,GPIO_LEVEL_LOW);
+	s3c_gpio_setpull(GPIO_HDMI_EN, S3C_GPIO_PULL_NONE);
+#else
+	if(system_rev < 7) {
+		s3c_gpio_cfgpin(GPIO_HDMI_EN,S3C_GPIO_OUTPUT);	//HDMI_EN
+		gpio_set_value(GPIO_HDMI_EN,GPIO_LEVEL_LOW);
+		s3c_gpio_setpull(GPIO_HDMI_EN, S3C_GPIO_PULL_NONE);
+	}
+	else {
+		s3c_gpio_cfgpin(GPIO_HDMI_EN_REV07,S3C_GPIO_OUTPUT);	//HDMI_EN
+		gpio_set_value(GPIO_HDMI_EN_REV07,GPIO_LEVEL_LOW);
+		s3c_gpio_setpull(GPIO_HDMI_EN_REV07, S3C_GPIO_PULL_NONE);
+	}
+#endif
+
+	s3c_gpio_cfgpin(GPIO_MHL_RST,S3C_GPIO_OUTPUT);
+	s3c_gpio_setpull(GPIO_MHL_RST, S3C_GPIO_PULL_NONE);
+	gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_LOW);
+
+	s3c_gpio_cfgpin(GPIO_MHL_SEL,S3C_GPIO_OUTPUT);
+	s3c_gpio_setpull(GPIO_MHL_SEL, S3C_GPIO_PULL_NONE);
+	gpio_set_value(GPIO_MHL_SEL, GPIO_LEVEL_LOW);
+
+}
+
+static int mhl_open(struct inode *ip, struct file *fp)
+{
+	printk(KERN_ERR "[%s] \n",__func__);
+	return 0;
+
+}
+
+static int mhl_release(struct inode *ip, struct file *fp)
+{
+	
+	printk(KERN_ERR "[%s] \n",__func__);
+	return 0;
+}
+
+
+static int mhl_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	printk(KERN_ERR "[%s] \n",__func__);
+
+#if 0
+	byte data;
+
+	switch(cmd)
+	{
+		case MHL_READ_RCP_DATA:
+			data = GetCbusRcpData();
+			ResetCbusRcpData();
+			put_user(data,(byte *)arg);
+			printk(KERN_ERR "MHL_READ_RCP_DATA read");
+			break;
+		
+		default:
+		break;
+	}
+#endif		
+	return 0;
+}
+
+static struct file_operations mhl_fops = {
+	.owner  = THIS_MODULE,
+	.open   = mhl_open,
+    	.release = mhl_release,
+    	.ioctl = mhl_ioctl,
+};
+                 
+static struct miscdevice mhl_device = {
+    .minor  = MISC_DYNAMIC_MINOR,
+    .name   = "mhl",
+    .fops   = &mhl_fops,
+};
+
+static int __init sii9234_module_init(void)
+{
+	int ret;
+
+	sii9234_cfg_gpio();
+
+	/* sii9234_cfg_power(1);	//Turn On power to sii9234 
+	*/
+
+#ifdef MHL_SWITCH_TEST
+	sec_mhl = class_create(THIS_MODULE, "sec_mhl");
+	if (IS_ERR(sec_mhl))
+		printk(KERN_ERR "[MHL] Failed to create class (sec_mhl)\n");
+
+	mhl_switch = device_create(sec_mhl, NULL, 0, NULL, "switch");
+	if (IS_ERR(mhl_switch))
+		printk(KERN_ERR "[MHL] Failed to create device (mhl_switch)\n");
+	if (device_create_file(mhl_switch, &dev_attr_mhl_sel) < 0)
+		printk(KERN_ERR "[MHL] Failed to create file (mhl_sel)");
+#endif
+
+	ret = misc_register(&mhl_device);
+	if(ret) {
+		pr_err(KERN_ERR "misc_register failed - mhl \n");
+	}
+
+	ret = i2c_add_driver(&sii9234_i2c_driver);
+	if (ret != 0)
+		printk(KERN_ERR "[MHL SII9234] can't add i2c driver\n");	
+	else
+		printk(KERN_ERR "[MHL SII9234] add i2c driver\n");
+	ret = i2c_add_driver(&sii9234a_i2c_driver);
+	if (ret != 0)
+		printk(KERN_ERR "[MHL SII9234A] can't add i2c driver\n");	
+	else
+		printk(KERN_ERR "[MHL SII9234A] add i2c driver\n");
+	ret = i2c_add_driver(&sii9234b_i2c_driver);
+	if (ret != 0)
+		printk(KERN_ERR "[MHL SII9234B] can't add i2c driver\n");	
+	else
+		printk(KERN_ERR "[MHL SII9234B] add i2c driver\n");
+
+	ret = i2c_add_driver(&sii9234c_i2c_driver);
+	if (ret != 0)
+		printk(KERN_ERR "[MHL SII9234C] can't add i2c driver\n");	
+	else
+		printk(KERN_ERR "[MHL SII9234C] add i2c driver\n");
+
+	return ret;	
+}
+module_init(sii9234_module_init);
+static void __exit sii9234_exit(void)
+{
+	i2c_del_driver(&sii9234_i2c_driver);
+	i2c_del_driver(&sii9234a_i2c_driver);
+	i2c_del_driver(&sii9234b_i2c_driver);	
+	i2c_del_driver(&sii9234c_i2c_driver);
+	
+};
+module_exit(sii9234_exit);
+
+MODULE_DESCRIPTION("Sii9234 MHL driver");
+MODULE_AUTHOR("Aakash Manik");
+MODULE_LICENSE("GPL");
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/sii9234_driver.c news/kernel/drivers/media/video/samsung/mhl_v1/sii9234_driver.c
--- kernel/drivers/media/video/samsung/mhl_v1/sii9234_driver.c	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/sii9234_driver.c	2011-06-17 19:41:22.000000000 +0900
@@ -1,2919 +1,2922 @@
-/*===========================================================================
-
-  SiI9234 Driver Processor
-
-
-  DESCRIPTION
-  This file explains the SiI9024A initialization and call the virtual main function.
-
-
-  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             
-  No part of this work may be reproduced, modified, distributed, transmitted,    
-  transcribed, or translated into any language or computer format, in any form   
-  or by any means without written permission of: Silicon Image, Inc.,            
-  1060 East Arques Avenue, Sunnyvale, California 94085                           
-  ===========================================================================*/
-
-
-/*===========================================================================
-
-  EDIT HISTORY FOR FILE
-
-  when              who                         what, where, why
-  --------        ---                        ----------------------------------------------------------
-  2010/10/25    Daniel Lee(Philju)      Initial version of file, SIMG Korea 
-  ===========================================================================*/
-
-/*===========================================================================
-  INCLUDE FILES FOR MODULE
-  ===========================================================================*/
-
-
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/i2c.h>
-#include <linux/gpio.h>
-#include <plat/pm.h>
-#include <asm/irq.h>
-#include <linux/delay.h>
-#include <plat/gpio-cfg.h>
-#include <mach/regs-gpio.h>
-#include <mach/regs-clock.h>
-
-#include <linux/syscalls.h> 
-#include <linux/fcntl.h> 
-#include <asm/uaccess.h> 
-#include <plat/gpio-core.h>
-
-#include <linux/hrtimer.h>
-#include <linux/ktime.h>
-
-#include "SiI9234_Reg.h"
-#include "Common_Def.h"
-#include "SiI9234_I2C_master.h"
-#include "SiI9234_I2C_slave_add.h"
-#include "si_cbusDefs.h"
-#include "si_cbus_regs.h"
-#include "si_cbus.h"
-#include "si_apiCbus.h"
-
-/*===========================================================================
-  Definition
-  ===========================================================================*/
-#define TX_HW_RESET_PERIOD      200
-
-#define SiI_DEVICE_ID           0xB0
-
-#define DDC_XLTN_TIMEOUT_MAX_VAL		0x30
-
-#define INDEXED_PAGE_0		0x01
-#define INDEXED_PAGE_1		0x02
-#define INDEXED_PAGE_2		0x03
-
-#define ASR_VALUE 0x04
-
-
-
-#define	TX_POWER_STATE_D0_NO_MHL		TX_POWER_STATE_D2
-
-#define	TX_POWER_STATE_D0_MHL			TX_POWER_STATE_D0
-
-#define	TX_POWER_STATE_FIRST_INIT		0xFF
-
-#define MHL_INIT_POWER_OFF        0x00
-#define MHL_POWER_ON              0x01
-#define MHL_1K_IMPEDANCE_VERIFIED 0x02
-#define MHL_RSEN_VERIFIED         0x04
-#define MHL_TV_OFF_CABLE_CONNECT 0x08
-
-#define TX_DEBUG_PRINT(x) printk x
-
-
-#define	I2C_READ_MODIFY_WRITE(saddr,offset,mask)	I2C_WriteByte(saddr, offset, I2C_ReadByte(saddr, offset) | (mask));
-
-#define	SET_BIT(saddr,offset,bitnumber)		I2C_READ_MODIFY_WRITE(saddr,offset, (1<<bitnumber))
-#define	CLR_BIT(saddr,offset,bitnumber)		I2C_WriteByte(saddr, offset, I2C_ReadByte(saddr, offset) & ~(1<<bitnumber))
-//
-// 90[0] = Enable / Disable MHL Discovery on MHL link
-//
-#define	DISABLE_DISCOVERY				CLR_BIT(SA_TX_Page0_Primary, 0x90, 0);
-#define	ENABLE_DISCOVERY				SET_BIT(SA_TX_Page0_Primary, 0x90, 0);
-//
-//	Look for interrupts on INTR_4 (Register 0x74)
-//		7 = PVT_HTBT(reserved)
-//		6 = RGND RDY		(interested)
-//		5 = VBUS low(interested)	
-//		4 = CBUS LKOUT		(reserved)
-//		3 = USB EST		(reserved)
-//		2 = MHL EST		(reserved)
-//		1 = RPWR5V CHANGE		(reserved)
-//		0 = SCDT CHANGE		(reserved)
-#define	INTR_4_DESIRED_MASK				( BIT_2 | BIT_3 | BIT_4 | BIT_6) 
-#define	UNMASK_INTR_4_INTERRUPTS		I2C_WriteByte(SA_TX_Page0_Primary, 0x78, 0x00) 
-#define	MASK_INTR_4_INTERRUPTS	I2C_WriteByte(SA_TX_Page0_Primary, 0x78, INTR_4_DESIRED_MASK)		
-
-//	Look for interrupts on INTR_1 (Register 0x71)
-//		7 = RSVD		(reserved)
-//		6 = MDI_HPD		(interested)
-//		5 = RSEN CHANGED(interested)
-//		4 = RSVD		(reserved)
-//		3 = RSVD		(reserved)
-//		2 = RSVD		(reserved)
-//		1 = RSVD		(reserved)
-//		0 = RSVD		(reserved)
-
-#define	INTR_1_DESIRED_MASK				(BIT_5|BIT_6) 
-#define	UNMASK_INTR_1_INTERRUPTS		I2C_WriteByte(SA_TX_Page0_Primary, 0x75, 0x00)
-#define	MASK_INTR_1_INTERRUPTS			I2C_WriteByte(SA_TX_Page0_Primary, 0x75, INTR_1_DESIRED_MASK)
-
-//	Look for interrupts on CBUS:CBUS_INTR_STATUS [0xC8:0x08]
-//		7 = RSVD			(reserved)
-//		6 = MSC_RESP_ABORT	(interested)
-//		5 = MSC_REQ_ABORT	(interested)	
-//		4 = MSC_REQ_DONE	(interested)
-//		3 = MSC_MSG_RCVD	(interested)
-//		2 = DDC_ABORT		(interested)
-//		1 = RSVD			(reserved)
-//		0 = rsvd			(reserved)
-#define	INTR_CBUS1_DESIRED_MASK			(BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6)
-#define	UNMASK_CBUS1_INTERRUPTS		I2C_WriteByte(SA_TX_CBUS_Primary, 0x09, 0x00)	
-#define	MASK_CBUS1_INTERRUPTS			I2C_WriteByte(SA_TX_CBUS_Primary, 0x09, INTR_CBUS1_DESIRED_MASK)
-
-#define	INTR_CBUS2_DESIRED_MASK			(BIT_2 | BIT_3)
-#define	UNMASK_CBUS2_INTERRUPTS		 I2C_WriteByte(SA_TX_CBUS_Primary, 0x1F, 0x00)	
-#define	MASK_CBUS2_INTERRUPTS			 I2C_WriteByte(SA_TX_CBUS_Primary, 0x1F, INTR_CBUS2_DESIRED_MASK)
-
-
-#define		MHL_TX_EVENT_NONE			0x00	/* No event worth reporting.  */
-#define		MHL_TX_EVENT_DISCONNECTION	0x01	/* MHL connection has been lost */
-#define		MHL_TX_EVENT_CONNECTION		0x02	/* MHL connection has been established */
-#define		MHL_TX_EVENT_RCP_READY		0x03	/* MHL connection is ready for RCP */
-//
-#define		MHL_TX_EVENT_RCP_RECEIVED	0x04	/* Received an RCP. Key Code in "eventParameter" */
-#define		MHL_TX_EVENT_RCPK_RECEIVED	0x05	/* Received an RCPK message */
-#define		MHL_TX_EVENT_RCPE_RECEIVED	0x06	/* Received an RCPE message .*/
-
-/* To use hrtimer*/
-#define	MS_TO_NS(x)	(x * 1000000)
-
-DECLARE_WAIT_QUEUE_HEAD(wake_wq);
-
-static struct hrtimer hr_wake_timer;
-
-static bool wakeup_time_expired;
-
-static bool hrtimer_initialized;
-static bool first_timer;
-
-enum hrtimer_restart hrtimer_wakeup_callback(struct hrtimer *timer)
-{
-	wake_up(&wake_wq);
-	wakeup_time_expired = true;
-//	hrtimer_cancel(&hr_wake_timer);
-	return HRTIMER_NORESTART;
-}
-
-
-void start_hrtimer_ms(unsigned long delay_in_ms)
-{
-	ktime_t ktime;
-	ktime = ktime_set(0, MS_TO_NS(delay_in_ms));
-
-	wakeup_time_expired = false;
-//	hrtimer_init(&hr_wake_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	if (first_timer)
-		first_timer = false;
-	else
-		hrtimer_cancel(&hr_wake_timer);
-
-//	hr_wake_timer.function = &hrtimer_wakeup_callback;
-	hrtimer_start(&hr_wake_timer, ktime, HRTIMER_MODE_REL);
-}
-
-//wait_queue_head_t wake_wq;
-
-
-
-/*===========================================================================
-
-  ===========================================================================*/
-
-//
-// To remember the current power state.
-//
-byte	fwPowerState = TX_POWER_STATE_FIRST_INIT;
-
-//
-// When MHL Fifo underrun or overrun happens, we set this flag
-// to avoid calling a function in recursive manner. The monitoring loop
-// would look at this flag and call appropriate function and clear this flag.
-//
-//static	bool	gotFifoUnderRunOverRun = FALSE;
-
-//
-// This flag is set to TRUE as soon as a INT1 RSEN CHANGE interrupt arrives and
-// a deglitch timer is started.
-//
-// We will not get any further interrupt so the RSEN LOW status needs to be polled
-// until this timer expires.
-//
-/* static	bool	deglitchingRsenNow = FALSE; */
-
-//
-// To serialize the RCP commands posted to the CBUS engine, this flag
-// is maintained by the function SiiMhlTxDrvSendCbusCommand()
-//
-static	bool		mscCmdInProgress;	// FALSE when it is okay to send a new command
-//
-// Preserve Downstream HPD status
-//
-static	byte	dsHpdStatus = 0;
-
-
-
-byte mhl_cable_status =MHL_INIT_POWER_OFF;			//NAGSM_Android_SEL_Kernel_Aakash_20101214
-
-#define	MHL_MAX_RCP_KEY_CODE	(0x7F + 1)	// inclusive
-byte		rcpSupportTable [MHL_MAX_RCP_KEY_CODE] = {
-	(MHL_DEV_LD_GUI),		// 0x00 = Select
-	(MHL_DEV_LD_GUI),		// 0x01 = Up
-	(MHL_DEV_LD_GUI),		// 0x02 = Down
-	(MHL_DEV_LD_GUI),		// 0x03 = Left
-	(MHL_DEV_LD_GUI),		// 0x04 = Right
-	0, 0, 0, 0,				// 05-08 Reserved
-	(MHL_DEV_LD_GUI),		// 0x09 = Root Menu
-	0, 0, 0,				// 0A-0C Reserved
-	(MHL_DEV_LD_GUI),		// 0x0D = Select
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	// 0E-1F Reserved
-	0,//(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),	// Numeric keys 0x20-0x29
-	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
-	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
-	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
-	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
-	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
-	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
-	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
-	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
-	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
-	0,						// 0x2A = Dot
-	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),	// Enter key = 0x2B
-	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),	// Clear key = 0x2C
-	0, 0, 0,				// 2D-2F Reserved
-	0,//	(MHL_DEV_LD_TUNER),		// 0x30 = Channel Up
-	0,//	(MHL_DEV_LD_TUNER),		// 0x31 = Channel Dn
-	0,//	(MHL_DEV_LD_TUNER),		// 0x32 = Previous Channel
-	0,//	(MHL_DEV_LD_AUDIO),		// 0x33 = Sound Select
-	0,						// 0x34 = Input Select
-	0,						// 0x35 = Show Information
-	0,						// 0x36 = Help
-	0,						// 0x37 = Page Up
-	0,						// 0x38 = Page Down
-	0, 0, 0, 0, 0, 0, 0,	// 0x39-0x3F Reserved
-	0,						// 0x40 = Undefined
-
-	0,//	(MHL_DEV_LD_SPEAKER),	// 0x41 = Volume Up
-	0,//	(MHL_DEV_LD_SPEAKER),	// 0x42 = Volume Down
-	0,//	(MHL_DEV_LD_SPEAKER),	// 0x43 = Mute
-	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),	// 0x44 = Play
-	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_RECORD),	// 0x45 = Stop
-	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_RECORD),	// 0x46 = Pause
-	0,//	(MHL_DEV_LD_RECORD),	// 0x47 = Record
-	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),	// 0x48 = Rewind
-	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),	// 0x49 = Fast Forward
-	0,//	(MHL_DEV_LD_MEDIA),		// 0x4A = Eject
-	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA),	// 0x4B = Forward
-	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA),	// 0x4C = Backward
-	0, 0, 0,				// 4D-4F Reserved
-	0,						// 0x50 = Angle
-	0,						// 0x51 = Subpicture
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 52-5F Reserved
-	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),	// 0x60 = Play Function
-	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),	// 0x61 = Pause the Play Function
-	0,//	(MHL_DEV_LD_RECORD),	// 0x62 = Record Function
-	0,//	(MHL_DEV_LD_RECORD),	// 0x63 = Pause the Record Function
-	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_RECORD),	// 0x64 = Stop Function
-
-	0,//	(MHL_DEV_LD_SPEAKER),	// 0x65 = Mute Function
-	0,//	(MHL_DEV_LD_SPEAKER),	// 0x66 = Restore Mute Function
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	// Undefined or reserved
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 		// Undefined or reserved
-};
-
-/*===========================================================================
-  FUNCTION DEFINITIONS
-  ===========================================================================*/
-static	void	Int4Isr(void);
-static	void	Int1RsenIsr(void);
-static	void	MhlCbusIsr(void);
-/* static	void 	DeglitchRsenLow(void); */
-
-void	CbusReset(void);
-void	SwitchToD0(void);
-void	SwitchToD3(void);
-void	WriteInitialRegisterValues(void);
-static	void	InitCBusRegs(void);
-static	void	ForceUsbIdSwitchOpen(void);
-static	void	ReleaseUsbIdSwitchOpen(void);
-void	MhlTxDrvProcessConnection(void);
-void	MhlTxDrvProcessDisconnection(void);
-static	void	ApplyDdcAbortSafety(void);
-
-
-//
-// Store global config info here. This is shared by the driver.
-//
-//
-//
-// structure to hold operating information of MhlTx component
-//
-static	mhlTx_config_t	mhlTxConfig;
-//
-// Functions used internally.
-//
-static	bool 		SiiMhlTxRapkSend( void );
-static	void		MhlTxDriveStates( void );
-static	void		MhlTxResetStates( void );
-static	bool		MhlTxSendMscMsg ( byte command, byte cmdData );
-void	SiiMhlTxNotifyConnection( bool mhlConnected );
-void	AppVbusControl( bool powerOn );
-void	AppRcpDemo( byte event, byte eventParameter);
-void	SiiMhlTxNotifyDsHpdChange( byte dsHpdStatus );
-bool SiiMhlTxReadDevcap( byte offset );
-bool SiiMhlTxRcpkSend( byte );
-
-void	SiiMhlTxGotMhlStatus( byte status_0, byte status_1 );
-void	SiiMhlTxGotMhlIntr( byte intr_0, byte intr_1 );
-void	SiiMhlTxGotMhlMscMsg( byte subCommand, byte cmdData );
-void	SiiMhlTxMscCommandDone( byte data1 );
-void SiiMhlTxGetEvents( byte *event, byte *eventParameter );
-//void SiiMhlTxInitialize( void );
-
-bool SiiMhlTxRcpeSend( byte rcpeErrorCode );
-
-void DelayMS(word msec);
-
-void sii9234_hw_reset(void);
-void sii_mhl_tx_init( void );
-
-
-
-Bool sii9234_init(void);
-void sii9234_interrupt_event(void);
-
-void	ProcessRgnd( void );
-/* jinho96.kim 2011.01.06 */
-extern void rcp_cbus_uevent(u8);		//Subhransu
-
-
-
-/*======================================================================*/
-
-
-/*===========================================================================
-  FUNCTION DelayMS
-
-  DESCRIPTION
-
-
-  DEPENDENCIES
-  None
-
-  RETURN VALUE
-  None
-
-  SIDE EFFECTS
-  None
-  ===========================================================================*/
-void DelayMS(word msec)
-{
-	msleep(msec);
-}
-
-
-/*===========================================================================
-  FUNCTION sii9234_hw_reset
-
-  DESCRIPTION
-  SiI9024A HW reset
-
-  DEPENDENCIES
-  None
-
-  RETURN VALUE
-  None
-
-  SIDE EFFECTS
-  None
-  ===========================================================================*/
-void sii9234_hw_reset(void)
-{
-	printk(KERN_ERR ">>TxHW_Reset()\n");
-
-	s3c_gpio_setpull(GPIO_MHL_RST, S3C_GPIO_PULL_NONE);
-	gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_LOW);
-	//PinTxHwReset = LOW;
-	DelayMS(TX_HW_RESET_PERIOD);
-	gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_HIGH);
-	printk(KERN_ERR ">>TxHW_Reset() done\n");
-}
-
-/*===========================================================================
-  FUNCTION SiI9234_startTPI
-
-  DESCRIPTION
-  Change the TPI mode (SW->H/W TPI mode)
-
-  DEPENDENCIES
-  None
-
-  RETURN VALUE
-  None
-
-  SIDE EFFECTS
-  None
-  ===========================================================================*/
-Bool SiI9234_startTPI(void)
-{
-	byte devID = 0x00;
-
-	printk(KERN_ERR ">>StartTPI()\n");
-
-	WriteByteTPI(TPI_ENABLE, 0x00);            // Write "0" to 72:C7 to start HW TPI mode
-	DelayMS(10);
-
-	devID = ReadByteTPI(TPI_DEVICE_ID);
-
-	if (devID == SiI_DEVICE_ID) 
-	{
-		printk(KERN_ERR "######## Subhransu: Silicon Device Id: %x\n", devID);
-		return TRUE;
-	}
-
-	printk(KERN_ERR "Unsupported TX\n");
-	return FALSE;
-}
-
-
-/*===========================================================================
-  FUNCTION sii9234_init
-
-  DESCRIPTION
-  SiI9234 initialization function.
-
-  DEPENDENCIES
-  None
-
-  RETURN VALUE
-  None
-
-  SIDE EFFECTS
-  None
-  ===========================================================================*/
-Bool sii9234_init(void)
-{
-	printk(KERN_ERR "# SiI9234 initialization start~ \n"); 
-
-	//sii9234_hw_reset();
-
-	sii_mhl_tx_init();
-
-	return TRUE;
-}
-
-//////////////////////////////////////////////////////////////////////////////
-//
-// SiiMhlTxChipInitialize
-//
-// Chip specific initialization.
-// This function is for SiI 9244 Initialization: HW Reset, Interrupt enable.
-//
-//
-//////////////////////////////////////////////////////////////////////////////
-
-bool SiiMhlTxChipInitialize ( void )
-{
-	TX_DEBUG_PRINT( ("Drv: SiiMhlTxChipInitialize: %02X44\n", (int)I2C_ReadByte(SA_TX_Page0_Primary, 0x03)) );
-
-	// setup device registers. Ensure RGND interrupt would happen.
-	WriteInitialRegisterValues();
-
-	// Setup interrupt masks for all those we are interested.
-	MASK_INTR_4_INTERRUPTS;
-	MASK_INTR_1_INTERRUPTS;
-	//MASK_CBUS1_INTERRUPTS; 
-	//MASK_CBUS2_INTERRUPTS;
-
-	SwitchToD3();
-
-	return TRUE;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-// SiiMhlTxDeviceIsr
-//
-// This function must be called from a master interrupt handler or any polling
-// loop in the host software if during initialization call the parameter
-// interruptDriven was set to TRUE. SiiMhlTxGetEvents will not look at these
-// events assuming firmware is operating in interrupt driven mode. MhlTx component
-// performs a check of all its internal status registers to see if a hardware event
-// such as connection or disconnection has happened or an RCP message has been
-// received from the connected device. Due to the interruptDriven being TRUE,
-// MhlTx code will ensure concurrency by asking the host software and hardware to
-// disable interrupts and restore when completed. Device interrupts are cleared by
-// the MhlTx component before returning back to the caller. Any handling of
-// programmable interrupt controller logic if present in the host will have to
-// be done by the caller after this function returns back.
-
-// This function has no parameters and returns nothing.
-//
-// This is the master interrupt handler for 9244. It calls sub handlers
-// of interest. Still couple of status would be required to be picked up
-// in the monitoring routine (Sii9244TimerIsr)
-//
-// To react in least amount of time hook up this ISR to processor's
-// interrupt mechanism.
-//
-// Just in case environment does not provide this, set a flag so we
-// call this from our monitor (Sii9244TimerIsr) in periodic fashion.
-//
-// Device Interrupts we would look at
-//		RGND		= to wake up from D3
-//		MHL_EST 	= connection establishment
-//		CBUS_LOCKOUT= Service USB switch
-//		RSEN_LOW	= Disconnection deglitcher
-//		CBUS 		= responder to peer messages
-//					  Especially for DCAP etc time based events
-//
-void 	SiiMhlTxDeviceIsr( void )
-{
-	byte tmp;		//NAGSM_Android_SEL_Kernel_Aakash_20101214
-	if( TX_POWER_STATE_D0_MHL != fwPowerState )
-	{  
-		//
-		// Check important RGND, MHL_EST, CBUS_LOCKOUT and SCDT interrupts
-		// During D3 we only get RGND but same ISR can work for both states
-		//
-		Int4Isr();
-
-		if(mhl_cable_status == MHL_TV_OFF_CABLE_CONNECT)
-		{
-			return ;
-		}
-                //NAGSM_Android_SEL_Kernel_Aakash_20101214
-
-		tmp = ReadByteCBUS(0x08);
-		WriteByteCBUS(0x08, tmp);
-		tmp = ReadByteCBUS(0x1E);
-		WriteByteCBUS(0x1E, tmp);    
-
-                //NAGSM_Android_SEL_Kernel_Aakash_20101214
-
-	}
-	else if( TX_POWER_STATE_D0_MHL == fwPowerState ) //NAGSM_Android_SEL_Kernel_Aakash_20101214
-	{
-
-		//
-		// Check for any peer messages for DCAP_CHG etc
-		// Dispatch to have the CBUS module working only once connected.
-		//
-		MhlCbusIsr();
-	}
-
-	Int1RsenIsr();
-
-}
-///////////////////////////////////////////////////////////////////////////////
-//
-// SiiMhlTxDriverTmdsControl
-//
-// Control the TMDS output. MhlTx uses this to support RAP content on and off.
-//
-void	SiiMhlTxDrvTmdsControl( bool enable )
-{
-	if( enable )
-	{
-		SET_BIT(SA_TX_Page0_Primary, 0x80, 4);
-		TX_DEBUG_PRINT(("Drv: TMDS Output Enabled\n"));
-	}
-	else
-	{
-		CLR_BIT(SA_TX_Page0_Primary, 0x80, 4);
-		TX_DEBUG_PRINT(("Drv: TMDS Ouput Disabled\n"));
-	}
-}
-///////////////////////////////////////////////////////////////////////////////
-//
-// SiiMhlTxDrvNotifyEdidChange
-//
-// MhlTx may need to inform upstream device of a EDID change. This can be
-// achieved by toggling the HDMI HPD signal or by simply calling EDID read
-// function.
-//
-void	SiiMhlTxDrvNotifyEdidChange ( void )
-{
-	TX_DEBUG_PRINT(("Drv: SiiMhlTxDrvNotifyEdidChange\n"));
-	//
-	// Prepare to toggle HPD to upstream
-	//
-	// set reg_hpd_out_ovr_en to first control the hpd
-	SET_BIT(SA_TX_Page0_Primary, 0x79, 4);
-
-	// reg_hpd_out_ovr_val = LOW to force the HPD low
-	CLR_BIT(SA_TX_Page0_Primary, 0x79, 5);
-
-	// wait a bit
-	DelayMS(110);
-
-	// release HPD back to high by reg_hpd_out_ovr_val = HIGH
-	SET_BIT(SA_TX_Page0_Primary, 0x79, 5);
-
-}
-//------------------------------------------------------------------------------
-// Function:    SiiMhlTxDrvSendCbusCommand
-//
-// Write the specified Sideband Channel command to the CBUS.
-// Command can be a MSC_MSG command (RCP/RAP/RCPK/RCPE/RAPK), or another command 
-// such as READ_DEVCAP, SET_INT, WRITE_STAT, etc.
-//
-// Parameters:  
-//              pReq    - Pointer to a cbus_req_t structure containing the 
-//                        command to write
-// Returns:     TRUE    - successful write
-//              FALSE   - write failed
-//------------------------------------------------------------------------------
-
-bool SiiMhlTxDrvSendCbusCommand ( cbus_req_t *pReq  )
-{
-	bool  success = TRUE;
-
-	byte i, startbit;
-
-	//
-	// If not connected, return with error
-	//
-	//if( (TX_POWER_STATE_D0_MHL != fwPowerState ) || (0 == ReadByteCBUS(0x0a) || mscCmdInProgress))
-  if( (TX_POWER_STATE_D0_MHL != fwPowerState ) || (mscCmdInProgress))
-	{
-	    TX_DEBUG_PRINT(("Error: Drv: fwPowerState: %02X, CBUS[0x0A]: %02X or mscCmdInProgress = %d\n",
-
-				(int) fwPowerState,
-
-					(int) ReadByteCBUS(0x0a),
-					(int) mscCmdInProgress));
-
-		return FALSE;
-	}
-	// Now we are getting busy
-	mscCmdInProgress	= TRUE;
-
-	TX_DEBUG_PRINT(("Drv: Sending MSC command %02X, %02X, %02X, %02X\n",
-				(int)pReq->command,
-				(int)(pReq->offsetData),
-				(int)pReq->msgData[0],
-				(int)pReq->msgData[1]));
-
-	/****************************************************************************************/
-	/* Setup for the command - write appropriate registers and determine the correct        */
-	/*                         start bit.                                                   */
-	/****************************************************************************************/
-
-	// Set the offset and outgoing data byte right away
-	WriteByteCBUS( 0x13, pReq->offsetData); 	// set offset
-	WriteByteCBUS( 0x14, pReq->msgData[0] );
-
-	startbit = 0x00;
-	switch ( pReq->command )
-	{
-		case MHL_SET_INT:	// Set one interrupt register = 0x60
-			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->offsetData + 0x20 ); 	// set offset
-			startbit = MSC_START_BIT_WRITE_REG;
-			break;
-
-		case MHL_WRITE_STAT:	// Write one status register = 0x60 | 0x80
-			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->offsetData + 0x30 ); 	// set offset
-			startbit = MSC_START_BIT_WRITE_REG;
-			break;
-
-		case MHL_READ_DEVCAP:	// Read one device capability register = 0x61
-			startbit = MSC_START_BIT_READ_REG;
-			break;
-
-		case MHL_GET_STATE:			// 0x62 -
-		case MHL_GET_VENDOR_ID:		// 0x63 - for vendor id	
-		case MHL_SET_HPD:			// 0x64	- Set Hot Plug Detect in follower
-		case MHL_CLR_HPD:			// 0x65	- Clear Hot Plug Detect in follower
-		case MHL_GET_SC1_ERRORCODE:		// 0x69	- Get channel 1 command error code
-		//case MHL_GET_DDC_ERRORCODE:		// 0x6A	- Get DDC channel command error code.
-		case MHL_GET_MSC_ERRORCODE:		// 0x6B	- Get MSC command error code.
-		case MHL_GET_SC3_ERRORCODE:		// 0x6D	- Get channel 3 command error code.
-			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->command );
-			startbit = MSC_START_BIT_MSC_CMD;
-			break;
-    		case MHL_GET_DDC_ERRORCODE:		// 0x6A	- Get DDC channel command error code.
-			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), 0x00 );
-            		startbit = MSC_START_BIT_MSC_CMD;
-            break;
-
-		case MHL_MSC_MSG:
-			WriteByteCBUS( (REG_CBUS_PRI_WR_DATA_2ND & 0xFF), pReq->msgData[1] );
-			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->command );
-			startbit = MSC_START_BIT_VS_CMD;
-			break;
-
-		case MHL_WRITE_BURST:
-			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->offsetData + 0x40 );
-			WriteByteCBUS( (REG_MSC_WRITE_BURST_LEN & 0xFF), pReq->length -1 );
-
-			// Now copy all bytes from array to local scratchpad
-			for ( i = 0; i < pReq->length; i++ )
-			{
-				WriteByteCBUS( (REG_CBUS_SCRATCHPAD_0 & 0xFF) + i, pReq->msgData[i] );
-			}
-			startbit = MSC_START_BIT_WRITE_BURST;
-			break;
-
-		default:
-			success = FALSE;
-			break;
-	}
-
-	/****************************************************************************************/
-	/* Trigger the CBUS command transfer using the determined start bit.                    */
-	/****************************************************************************************/
-
-	if ( success )
-	{
-		WriteByteCBUS( REG_CBUS_PRI_START & 0xFF, startbit );
-	}
-
-	return( success );
-}
-////////////////////////////////////////////////////////////////////
-//
-// L O C A L    F U N C T I O N S
-//
-////////////////////////////////////////////////////////////////////
-// Int1RsenIsr
-//
-// This interrupt is used only to decide if the MHL is disconnected
-// The disconnection is determined by looking at RSEN LOW and applying
-// all MHL compliant disconnect timings and deglitch logic.
-//
-//	Look for interrupts on INTR_1 (Register 0x71)
-//		7 = RSVD		(reserved)
-//		6 = MDI_HPD		(interested)
-//		5 = RSEN CHANGED(interested)	
-//		4 = RSVD		(reserved)
-//		3 = RSVD		(reserved)
-//		2 = RSVD		(reserved)
-//		1 = RSVD		(reserved)
-//		0 = RSVD		(reserved)
-////////////////////////////////////////////////////////////////////
-void	Int1RsenIsr( void )
-{
-	byte		reg71 = I2C_ReadByte(SA_TX_Page0_Primary, 0x71);
-	byte		rsen  = I2C_ReadByte(SA_TX_Page0_Primary, 0x09) & BIT_2;
-
-	// Look at RSEN interrupt
-	if(reg71 & BIT_5)
-	{
-		TX_DEBUG_PRINT (("Drv: Got INTR_1: reg71 = %02X, rsen = %02X\n", (int) reg71, (int) rsen));
-		//pinCBusToggle = 1;	// for debug measurements. RSEN intr
-		//
-		// RSEN becomes LOW in SYS_STAT register 0x72:0x09[2]
-		// SYS_STAT	==> bit 7 = VLOW, 6:4 = MSEL, 3 = TSEL, 2 = RSEN, 1 = HPD, 0 = TCLK STABLE
-		//
-		// Start countdown timer for deglitch
-		// Allow RSEN to stay low this much before reacting
-		//
-		if(rsen == 0x00)
-		{
-	      		if(TX_POWER_STATE_D0_MHL != fwPowerState)
-	      		{
-				TX_DEBUG_PRINT (("Drv: Got1 INTR_1: reg71 = %02X, rsen = %02X\n", (int) reg71, (int) rsen));
-				I2C_WriteByte(SA_TX_Page0_Primary, 0x71, reg71);
-				return ;
-	      		}
-			if(mhl_cable_status & MHL_1K_IMPEDANCE_VERIFIED)
-#if 1
-      			{
-        			TX_DEBUG_PRINT((KERN_ERR "RSEN Low and 1K impedance\n"));
-				DelayMS(120);
-
-         			if((I2C_ReadByte(SA_TX_Page0_Primary, 0x09) & BIT_2) == 0x00)
-         			{
-
-			           TX_DEBUG_PRINT((KERN_ERR "Really RSEN Low\n"));
-					//mhl_cable_status =MHL_INIT_POWER_OFF;
-          
-
-					mhl_cable_status = MHL_TV_OFF_CABLE_CONNECT;
-#if defined(CONFIG_S5PC110_DEMPSEY_BOARD)
-	FSA9480_MhlSwitchSel(0);
-#endif
-					MHL_On(0);
-         			}
-        		 	else
-        			{
-         				TX_DEBUG_PRINT((KERN_ERR "RSEN Stable\n"));
-        			}
-
-      			}
-#else
-			{
-			mhl_cable_status =MHL_TV_OFF_CABLE_CONNECT;
-			printk(KERN_ERR "MHL Connection Fail Power off ###\n");
-			SiI9234_HW_Reset();
-			For_check_resen_int();
-			fwPowerState = TX_POWER_STATE_D3;
-
-
-			return ;
-		      	}
-#endif
-      			else
-	      		{
-				printk(KERN_ERR "%s: MHL Cable disconnect### 2\n", __func__);
-				mhl_cable_status =MHL_INIT_POWER_OFF;
-				MHL_On(0);
-			}
-
-			return ;
-
-			//NAGSM_Android_SEL_Kernel_Aakash_20101214
-
-		}
-
-		else if(rsen == 0x04)
-		{
-  			mhl_cable_status |= MHL_RSEN_VERIFIED;
-			printk("MHL Cable Connection ###\n");
-		}
-		// Clear MDI_RSEN interrupt
-
-	}
-
-	if(reg71 & BIT_6)
-	{
-		byte cbusInt;
-		//HPD
-		printk(KERN_ERR "HPD \n");
-		//
-		// Check if a SET_HPD came from the downstream device.
-		//
-		cbusInt = ReadByteCBUS(0x0D);
-
-		// CBUS_HPD status bit
-		if((BIT_6 & cbusInt) != dsHpdStatus)
-		{
-			// Inform upper layer of change in Downstream HPD
-			SiiMhlTxNotifyDsHpdChange( cbusInt );
-			TX_DEBUG_PRINT(("Drv: Downstream HPD changed to: %02X\n", (int) cbusInt));
-
-			// Remember
-			dsHpdStatus = (BIT_6 & cbusInt);
-		}
-
-	}
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x71, reg71);
-
-}
-//////////////////////////////////////////////////////////////////////////////
-//
-// DeglitchRsenLow
-//
-// This function looks at the RSEN signal if it is low.
-//
-// The disconnection will be performed only if we were in fully MHL connected
-// state for more than 400ms AND a 150ms deglitch from last interrupt on RSEN
-// has expired.
-//
-// If MHL connection was never established but RSEN was low, we unconditionally
-// and instantly process disconnection.
-//
-/*
-static void DeglitchRsenLow(void)
-{
-	TX_DEBUG_PRINT(("Drv: DeglitchRsenLow RSEN <72:09[2]> = %02X\n", (int) (I2C_ReadByte(SA_TX_Page0_Primary, 0x09)) ));
-	if((I2C_ReadByte(SA_TX_Page0_Primary, 0x09) & BIT_2) == 0x00)
-
-	if((I2C_ReadByte(PAGE_0_0X72, 0x09) & BIT_2) == 0x00)
-	{
-		TX_DEBUG_PRINT(("Drv: RSEN is Low.\n"));
-		//
-		// If no MHL cable is connected or RSEN deglitch timer has started,
-		// we may not receive interrupts for RSEN.
-		// Monitor the status of RSEN here.
-		//
-		// 
-		// First check means we have not received any interrupts and just started
-		// but RSEN is low. Case of "nothing" connected on MHL receptacle
-		//
-		if(TX_POWER_STATE_D0_MHL == fwPowerState)
-    //if((TX_POWER_STATE_D0_MHL == fwPowerState)    && HalTimerExpired(TIMER_TO_DO_RSEN_DEGLITCH) )      
-
-		{
-			// Second condition means we were fully operational, then a RSEN LOW interrupt
-			// occured and a DEGLITCH_TIMER per MHL specs started and completed.
-			// We can disconnect now.
-			//
-			TX_DEBUG_PRINT(("Drv: Disconnection due to RSEN Low\n"));
-
-			deglitchingRsenNow = FALSE;
-
-			//pinCBusToggle = 0;	// for debug measurements - disconnected due to RSEN
-
-			// FP1226: Toggle MHL discovery to level the voltage to deterministic vale.
-			DISABLE_DISCOVERY;
-			ENABLE_DISCOVERY;
-			//
-			// We got here coz cable was never connected
-			//
-			MhlTxDrvProcessDisconnection();
-		}
-	}
-	else
-	{
-		//
-		// Deglitch here:
-		// RSEN is not low anymore. Reset the flag.
-		// This flag will be now set on next interrupt.
-		//
-		// Stay connected
-		//
-		deglitchingRsenNow = FALSE;
-	}
-}
-*/
-///////////////////////////////////////////////////////////////////////////
-// WriteInitialRegisterValues
-//
-//
-///////////////////////////////////////////////////////////////////////////
-void WriteInitialRegisterValues ( void )
-{
-	TX_DEBUG_PRINT(("Drv: WriteInitialRegisterValues\n"));
-	// Power Up
-	I2C_WriteByte(SA_TX_Page1_Primary, 0x3D, 0x3F);	// Power up CVCC 1.2V core
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x11, 0x01);	// Enable TxPLL Clock
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x12, 0x15);	// Enable Tx Clock Path & Equalizer
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x08, 0x35);	// Power Up TMDS Tx Core
-
-	// Analog PLL Control
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x10, 0xC1);	// bits 5:4 = 2b00 as per characterization team.
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x17, 0x03);	// PLL Calrefsel
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x1A, 0x20);	// VCO Cal
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x22, 0x8A);	// Auto EQ
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x23, 0x6A);	// Auto EQ
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x24, 0xAA);	// Auto EQ
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x25, 0xCA);	// Auto EQ
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x26, 0xEA);	// Auto EQ
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x4C, 0xA0);	// Manual zone control
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x4D, 0x00);	// PLL Mode Value
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x80, 0x34);	// Enable Rx PLL Clock Value
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x45, 0x44);	// Rx PLL BW value from I2C
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x31, 0x0A);	// Rx PLL BW ~ 4MHz
-	I2C_WriteByte(SA_TX_Page0_Primary, 0xA0, 0xD0);
-	I2C_WriteByte(SA_TX_Page0_Primary, 0xA1, 0xFC);	// Disable internal MHL driver
-#ifdef CONFIG_TARGET_LOCALE_KOR
-//	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEE);
-	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEB); // changed by yoking.im
-#else
-	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEB);
-#endif
-	I2C_WriteByte(SA_TX_Page0_Primary, 0xA6, 0x0C);
-
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x2B, 0x01);	// Enable HDCP Compliance safety
-
-	//
-	// CBUS & Discovery
-	// CBUS discovery cycle time for each drive and float = 150us
-	//
-	ReadModifyWriteTPI(0x90, BIT_3 | BIT_2, BIT_3);
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x91, 0xA5);		// Clear bit 6 (reg_skip_rgnd)
-
-
-	// Changed from 66 to 65 for 94[1:0] = 01 = 5k reg_cbusmhl_pup_sel
-	//I2C_WriteByte(SA_TX_Page0_Primary, 0x94, 0x65);			// 1.8V CBUS VTH & GND threshold
-    I2C_WriteByte(SA_TX_Page0_Primary, 0x94, 0x75);			// 1.8V CBUS VTH & GND threshold
-
-	//set bit 2 and 3, which is Initiator Timeout
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x31, I2C_ReadByte(SA_TX_CBUS_Primary, 0x31) | 0x0c);
-
-	//I2C_WriteByte(SA_TX_Page0_Primary, 0xA5, 0xAC);			// RGND Hysterisis.
-    I2C_WriteByte(SA_TX_Page0_Primary, 0xA5, 0xA0);			
-	TX_DEBUG_PRINT(("Drv: MHL 1.0 Compliant Clock\n"));
-
-	// RGND & single discovery attempt (RGND blocking)
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x95, 0x31);
-
-	// use 1K and 2K setting
-	//I2C_WriteByte(SA_TX_Page0_Primary, 0x96, 0x22);
-	// Use VBUS path of discovery state machine
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x97, 0x00);
-
-	ReadModifyWriteTPI(0x95, BIT_6, BIT_6);		// Force USB ID switch to open
-
-	//
-	// For MHL compliance we need the following settings for register 93 and 94
-	// Bug 20686
-	//
-	// To allow RGND engine to operate correctly.
-	//
-	// When moving the chip from D2 to D0 (power up, init regs) the values should be
-	// 94[1:0] = 01  reg_cbusmhl_pup_sel[1:0] should be set for 5k
-	// 93[7:6] = 10  reg_cbusdisc_pup_sel[1:0] should be set for 10k (default)
-	// 93[5:4] = 00  reg_cbusidle_pup_sel[1:0] = open (default)
-	//
-
-	WriteByteTPI(0x92, 0x86);				//
-	// change from CC to 8C to match 5K
-	WriteByteTPI(0x93, 0x8C);				// Disable CBUS pull-up during RGND measurement
-
-	//NAGSM_Android_SEL_Kernel_Aakash_20101214
- 	//ReadModifyWriteTPI(0x79, BIT_5 | BIT_4, BIT_4);	// Force upstream HPD to 0 when not in MHL mode.
-	ReadModifyWriteTPI(0x79, BIT_1 | BIT_2, 0); //Set interrupt active high
-
-	DelayMS(25);
-	ReadModifyWriteTPI(0x95, BIT_6, 0x00);		// Release USB ID switch
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x27);			// Enable CBUS discovery
-
-	//if (settingMode9290 != pin9290_938x) {
-	// Reset CBus to clear state
-	CbusReset();
-	//}
-
-	InitCBusRegs();
-
-	// Enable Auto soft reset on SCDT = 0
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x05, 0x04);
-
-	// HDMI Transcode mode enable
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x0D, 0x1C);
-
- 	//I2C_WriteByte(SA_TX_Page0_Primary, 0x78, RGND_RDY_EN);
-}
-///////////////////////////////////////////////////////////////////////////
-//
-//
-///////////////////////////////////////////////////////////////////////////
-#define MHL_DEVICE_CATEGORY             0x02 //(MHL_DEV_CAT_SOURCE)
-#define	MHL_LOGICAL_DEVICE_MAP			(MHL_DEV_LD_AUDIO | MHL_DEV_LD_VIDEO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_GUI )
-
-static void InitCBusRegs( void )
-{
-	byte		regval;
-
-	TX_DEBUG_PRINT(("Drv: InitCBusRegs\n"));
-	// Increase DDC translation layer timer
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x07, 0x36);
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x40, 0x03); 			// CBUS Drive Strength
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x42, 0x06); 			// CBUS DDC interface ignore segment pointer
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x36, 0x0C);
-
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x3D, 0xFD);	
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x1C, 0x00);
-
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x44, 0x02);
-
-	// Setup our devcap
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x80, MHL_DEV_ACTIVE);
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x81, MHL_VERSION);
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x82, MHL_DEVICE_CATEGORY);
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x83, 0);  						
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x84, 0);						
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x85, (MHL_DEV_VID_LINK_SUPPRGB444|MHL_DEV_VID_LINK_SUPPYCBCR444));
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x86, MHL_DEV_AUD_LINK_2CH);
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x87, 0);										// not for source
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x88, MHL_LOGICAL_DEVICE_MAP);
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x89, 0x0F);										// not for source
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8A, MHL_FEATURE_RCP_SUPPORT | MHL_FEATURE_RAP_SUPPORT|MHL_FEATURE_SP_SUPPORT);
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8B, 0);
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8C, 0);										// reserved
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8D, MHL_SCRATCHPAD_SIZE);
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8E, 0x44 ); //MHL_INT_AND_STATUS_SIZE);
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8F, 0);										//reserved
-
-	// Make bits 2,3 (initiator timeout) to 1,1 for register CBUS_LINK_CONTROL_2
-	regval = I2C_ReadByte(SA_TX_CBUS_Primary, REG_CBUS_LINK_CONTROL_2 );
-	regval = (regval | 0x0C);
-	I2C_WriteByte(SA_TX_CBUS_Primary,REG_CBUS_LINK_CONTROL_2, regval);
-
-	// Clear legacy bit on Wolverine TX.
-    regval = I2C_ReadByte(SA_TX_CBUS_Primary, REG_MSC_TIMEOUT_LIMIT);
-    I2C_WriteByte(SA_TX_CBUS_Primary, REG_MSC_TIMEOUT_LIMIT, (regval & MSC_TIMEOUT_LIMIT_MSB_MASK));
-
-	// Set NMax to 1
-	I2C_WriteByte(SA_TX_CBUS_Primary, REG_CBUS_LINK_CONTROL_1, 0x01);
-
-}
-
-///////////////////////////////////////////////////////////////////////////
-//
-// ForceUsbIdSwitchOpen
-//
-///////////////////////////////////////////////////////////////////////////
-static void ForceUsbIdSwitchOpen ( void )
-{
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x26);		// Disable CBUS discovery
-	ReadModifyWriteTPI(0x95, BIT_6, BIT_6);	// Force USB ID switch to open
-	WriteByteTPI(0x92, 0x86);
-	// Force HPD to 0 when not in MHL mode.
-	ReadModifyWriteTPI(0x79, BIT_5 | BIT_4, BIT_4);
-
-}
-///////////////////////////////////////////////////////////////////////////
-//
-// ReleaseUsbIdSwitchOpen
-//
-///////////////////////////////////////////////////////////////////////////
-static void ReleaseUsbIdSwitchOpen ( void )
-{
-	DelayMS(50);
-
-	// Release USB ID switch
-	ReadModifyWriteTPI(0x95, BIT_6, 0x00);
-
-	ENABLE_DISCOVERY;
-}
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// FUNCTION     :   CbusWakeUpPulseGenerator ()
-//
-// PURPOSE      :   Generate Cbus Wake up pulse sequence using GPIO or I2C method.
-//
-// INPUT PARAMS :   None
-//
-// OUTPUT PARAMS:   None
-//
-// GLOBALS USED :   None
-//
-// RETURNS      :   None
-//
-//////////////////////////////////////////////////////////////////////////////
-
-void CbusWakeUpPulseGenerator(void)
-{	
-	TX_DEBUG_PRINT(("Drv: CbusWakeUpPulseGenerator\n"));
-
-	if (!hrtimer_initialized) {
-		hrtimer_init(&hr_wake_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-		hr_wake_timer.function = &hrtimer_wakeup_callback;
-		hrtimer_initialized = true;
-		first_timer = true;
-	}
-		
-	//
-	// I2C method
-	//
-	//I2C_WriteByte(SA_TX_Page0_Primary, 0x92, (I2C_ReadByte(SA_TX_Page0_Primary, 0x92) | 0x10));
-
-	// Start the pulse
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) | 0xC0));
-//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_1 );	// adjust for code path
-	start_hrtimer_ms(19);
-	wait_event_interruptible(wake_wq, wakeup_time_expired);
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) & 0x3F));
-//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_1 );	// adjust for code path
-	start_hrtimer_ms(19);
-	wait_event_interruptible(wake_wq, wakeup_time_expired);
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) | 0xC0));
-//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_1 );	// adjust for code path
-	start_hrtimer_ms(19);
-	wait_event_interruptible(wake_wq, wakeup_time_expired);
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) & 0x3F));
-//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_2 );	// adjust for code path
-	start_hrtimer_ms(60);
-	wait_event_interruptible(wake_wq, wakeup_time_expired);
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) | 0xC0));
-//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_1 );	// adjust for code path
-	start_hrtimer_ms(19);
-	wait_event_interruptible(wake_wq, wakeup_time_expired);
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) & 0x3F));
-//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_1 );	// adjust for code path
-	start_hrtimer_ms(19);
-	wait_event_interruptible(wake_wq, wakeup_time_expired);
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) | 0xC0));
-	//DelayMS(21);
-//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_1 );	// adjust for code path
-	start_hrtimer_ms(19);
-	wait_event_interruptible(wake_wq, wakeup_time_expired);
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) & 0x3F));
-
-//	DelayMS(T_SRC_WAKE_TO_DISCOVER);
-	start_hrtimer_ms(T_SRC_WAKE_TO_DISCOVER);
-	wait_event_interruptible(wake_wq, wakeup_time_expired);
-
-	//
-	// Toggle MHL discovery bit
-	// 
-	//I2C_WriteByte(SA_TX_Page0_Primary, 0x92, (I2C_ReadByte(SA_TX_Page0_Primary, 0x92) & 0xEF));
-
-	//DISABLE_DISCOVERY;
-	//ENABLE_DISCOVERY;
-
-
-}
-///////////////////////////////////////////////////////////////////////////
-//
-// ApplyDdcAbortSafety
-//
-///////////////////////////////////////////////////////////////////////////
-static	void	ApplyDdcAbortSafety()
-{
-	byte		bTemp, bPost;
-
-	/*	TX_DEBUG_PRINT(("[%d] Drv: Do we need DDC Abort Safety\n",
-		(int) (HalTimerElapsed( ELAPSED_TIMER ) * MONITORING_PERIOD)));*/
-
-	WriteByteCBUS(0x29, 0xFF);
-	bTemp = ReadByteCBUS(0x29);
-	DelayMS(3);
-	bPost = ReadByteCBUS(0x29);
-
-	if ((bPost > (bTemp + 50)))
-	{
-		TX_DEBUG_PRINT(("Drv: Applying DDC Abort Safety(SWWA 18958)\n"));
-
-		SET_BIT(SA_TX_Page0_Primary, 0x05, 3);
-		CLR_BIT(SA_TX_Page0_Primary, 0x05, 3);
-
-		InitCBusRegs();
-
-		// Why do we do these?
-		ForceUsbIdSwitchOpen();
-		ReleaseUsbIdSwitchOpen();
-
-		MhlTxDrvProcessDisconnection();
-	}
-}
-///////////////////////////////////////////////////////////////////////////
-// ProcessRgnd
-//
-// H/W has detected impedance change and interrupted.
-// We look for appropriate impedance range to call it MHL and enable the
-// hardware MHL discovery logic. If not, disable MHL discovery to allow
-// USB to work appropriately.
-//
-// In current chip a firmware driven slow wake up pulses are sent to the
-// sink to wake that and setup ourselves for full D0 operation.
-///////////////////////////////////////////////////////////////////////////
-void	ProcessRgnd( void )
-{
-	byte		reg99RGNDRange;
-	//
-	// Impedance detection has completed - process interrupt
-	//
-	reg99RGNDRange = I2C_ReadByte(SA_TX_Page0_Primary, 0x99) & 0x03;
-	TX_DEBUG_PRINT(("Drv: RGND Reg 99 = %02X : ", (int)reg99RGNDRange));
-#if defined(CONFIG_S5PC110_DEMPSEY_BOARD)
-        DisableFSA9480Interrupts(); //Test
-#endif
-	//
-	// Reg 0x99
-	// 00 or 11 means USB.
-	// 10 means 1K impedance (MHL)
-	// 01 means 2K impedance (MHL)
-	//
-	if (reg99RGNDRange == 0x00 || reg99RGNDRange == 0x03)
-	{
-		TX_DEBUG_PRINT((" : USB impedance. Disable MHL discovery.\n", (int)reg99RGNDRange));
-
-		CLR_BIT(SA_TX_Page0_Primary, 0x95, 5);
-		mhl_cable_status =MHL_INIT_POWER_OFF;
-		MHL_On(0); 
-		
-#if defined(CONFIG_S5PC110_DEMPSEY_BOARD)
-		FSA9480_CheckAndHookAudioDock(); //Rajucm: Audio Dock Detection Algorithm
-#endif
-	}
-	else
-	{
-		mhl_cable_status |= MHL_1K_IMPEDANCE_VERIFIED;
-		if(0x01==reg99RGNDRange)
-		{
-			TX_DEBUG_PRINT(("MHL 2K\n"));
-      mhl_cable_status =MHL_TV_OFF_CABLE_CONNECT;
-      printk(KERN_ERR "MHL Connection Fail Power off ###\n");
-			MHL_On(0);
-	  
-      #if defined(CONFIG_S5PC110_DEMPSEY_BOARD)
-        FSA9480_MhlTvOff();//Rajucm: Mhl cable handling when TV Off 
-      #endif
-
-      return ;
-		}
-		else if(0x02==reg99RGNDRange)
-		{
-			TX_DEBUG_PRINT(("MHL 1K\n"));
-
-	DelayMS(T_SRC_VBUS_CBUS_TO_STABLE);
-
-	// Discovery enabled
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x25);
-
-	//
-	// Send slow wake up pulse using GPIO or I2C
-	//
-	CbusWakeUpPulseGenerator();
-}
-	}
-}
-
-////////////////////////////////////////////////////////////////////
-// SwitchToD0
-// This function performs s/w as well as h/w state transitions.
-//
-// Chip comes up in D2. Firmware must first bring it to full operation
-// mode in D0.
-////////////////////////////////////////////////////////////////////
-void	SwitchToD0( void )
-{
-	//
-	// WriteInitialRegisterValues switches the chip to full power mode.
-	//
-	WriteInitialRegisterValues();
-
-	// Setup interrupt masks for all those we are interested.
-#if 0
-	//UNMASK_INTR_4_INTERRUPTS;
-	UNMASK_INT4_INTERRUPTS;
-	//UNMASK_CBUS1_INTERRUPTS;
-	//UNMASK_CBUS2_INTERRUPTS;
-#else
-	//MASK_INTR_4_INTERRUPTS;
-	MASK_INTR_1_INTERRUPTS;
-	//MASK_CBUS1_INTERRUPTS;
-	//MASK_CBUS2_INTERRUPTS;
-#endif
-
-	// Force Power State to ON
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x25);
-
-	fwPowerState = TX_POWER_STATE_D0_NO_MHL;
-  	mhl_cable_status =MHL_POWER_ON;
-}
-////////////////////////////////////////////////////////////////////
-// SwitchToD3
-//
-// This function performs s/w as well as h/w state transitions.
-//
-////////////////////////////////////////////////////////////////////
-void	SwitchToD3( void )
-{
-	//
-	// To allow RGND engine to operate correctly.
-	// So when moving the chip from D0 MHL connected to D3 the values should be
-	// 94[1:0] = 00  reg_cbusmhl_pup_sel[1:0] should be set for open
-	// 93[7:6] = 00  reg_cbusdisc_pup_sel[1:0] should be set for open
-	// 93[5:4] = 00  reg_cbusidle_pup_sel[1:0] = open (default)
-	//
-	// Disable CBUS pull-up during RGND measurement
-	//I2C_WriteByte(SA_TX_Page0_Primary, 0x93, 0x04);
-
-    ReadModifyWriteTPI(0x93, BIT_7 | BIT_6 | BIT_5 | BIT_4, 0);
-
-		ReadModifyWriteTPI(0x94, BIT_1 | BIT_0, 0);
-
-
-	// 1.8V CBUS VTH & GND threshold
-	//I2C_WriteByte(SA_TX_Page0_Primary, 0x94, 0x64);
-
-        ReleaseUsbIdSwitchOpen();
-        printk(KERN_ERR "POWER_STATE_D3\n");
-
-	// Change TMDS termination to high impedance on disconnection
-	// Bits 1:0 set to 11
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x01, 0x03);
-	//
-
-	// Change state to D3 by clearing bit 0 of 3D (SW_TPI, Page 1) register
-	// ReadModifyWriteIndexedRegister(INDEXED_PAGE_1, 0x3D, BIT_0, 0x00);
-	//
-	CLR_BIT(SA_TX_Page1_Primary, 0x3D, 0);
-
-	fwPowerState = TX_POWER_STATE_D3;
-
-}
-
-/*===========================================================================
-  FUNCTION For_check_resen_int
-
-  DESCRIPTION
-  For_check_resen_int
-
-  DEPENDENCIES
-  None
-
-  RETURN VALUE
-  None
-
-  SIDE EFFECTS
-  None
-===========================================================================*/
-static void For_check_resen_int (void) 
-{
-
-	// Power Up
-	I2C_WriteByte(SA_TX_Page1_Primary, 0x3D, 0x3F);			// Power up CVCC 1.2V core
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x11, 0x01);			// Enable TxPLL Clock
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x12, 0x15);			// Enable Tx Clock Path & Equalizer
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x08, 0x35);			// Power Up TMDS Tx Core
-
-	// Analog PLL Control
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x17, 0x03);			// PLL Calrefsel
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x1A, 0x20);			// VCO Cal
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x22, 0x8A);			// Auto EQ
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x23, 0x6A);			// Auto EQ
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x24, 0xAA);			// Auto EQ
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x25, 0xCA);			// Auto EQ
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x26, 0xEA);			// Auto EQ
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x4C, 0xA0);			// Manual zone control
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x4D, 0x00);			// PLL Mode Value
-
-	//I2C_WriteByte(SA_TX_Page0_Primary, 0x80, 0x34);			// Enable Rx PLL Clock Value
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x80, 0x24);			// Enable Rx PLL Clock Value	
-
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x45, 0x44);			// Rx PLL BW value from I2C
-	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x31, 0x0A);			// Rx PLL BW ~ 4MHz
-	I2C_WriteByte(SA_TX_Page0_Primary, 0xA0, 0xD0);
-	I2C_WriteByte(SA_TX_Page0_Primary, 0xA1, 0xFC);			// Disable internal Mobile HD driver
-
-#ifdef CONFIG_TARGET_LOCALE_KOR
-//	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEE);
-//	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xED); // changed by yoking.im
-	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEB); // changed by yoking.im
-#else
-	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEB);
-#endif
-	I2C_WriteByte(SA_TX_Page0_Primary, 0xA6, 0x0C);
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x2B, 0x01);			// Enable HDCP Compliance workaround
-
-	// CBUS & Discovery
-	ReadModifyWriteTPI(0x90, BIT_3 | BIT_2, BIT_3);	// CBUS discovery cycle time for each drive and float = 150us
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x91, 0xA5);
-	
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x94, 0x66);			// 1.8V CBUS VTH & GND threshold
-
-	//set bit 2 and 3, which is Initiator Timeout
-	I2C_WriteByte(SA_TX_CBUS_Primary, 0x31, I2C_ReadByte(SA_TX_CBUS_Primary, 0x31) | 0x0c);
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0xA5, 0xAC);			// RGND Hysterisis.
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x95, 0x31);			// RGND & single discovery attempt (RGND blocking)
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, 0x22);			// use 1K and 2K setting
-//	I2C_WriteByte(SA_TX_Page0_Primary, 0x97, 0x03);			// Auto Heartbeat failure enable
-
-	ReadModifyWriteTPI(0x95, BIT_6, BIT_6);		// Force USB ID switch to open
-
-	WriteByteTPI(0x92, 0x86);				//
-	WriteByteTPI(0x93, 0xCC);				// Disable CBUS pull-up during RGND measurement
-
-	DelayMS(25);
-	ReadModifyWriteTPI(0x95, BIT_6, 0x00);		// Release USB ID switch
-
-  ReadModifyWriteTPI(0x79, BIT_1 | BIT_2, 0); //Set interrupt active high
-
-  I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x27);			// Enable CBUS discovery
-
-	// Reset CBus to clear HPD
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x05, 0x08);
-	DelayMS(2);
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x05, 0x00);
-
-  I2C_WriteByte(SA_TX_CBUS_Primary, 0x1F, 0x02); 			// Heartbeat Max Fail Enable
-  I2C_WriteByte(SA_TX_CBUS_Primary, 0x07, DDC_XLTN_TIMEOUT_MAX_VAL | 0x06); 			// Increase DDC translation layer timer
-  I2C_WriteByte(SA_TX_CBUS_Primary, 0x40, 0x03); 			// CBUS Drive Strength
-  I2C_WriteByte(SA_TX_CBUS_Primary, 0x42, 0x06); 			// CBUS DDC interface ignore segment pointer
-  I2C_WriteByte(SA_TX_CBUS_Primary, 0x36, 0x0C);
-
-  I2C_WriteByte(SA_TX_CBUS_Primary, 0x3D, 0xFD);	
-  I2C_WriteByte(SA_TX_CBUS_Primary, 0x1C, 0x00);
-
-  I2C_WriteByte(SA_TX_CBUS_Primary, 0x44, 0x02);
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x05, 0x04); 		// Enable Auto soft reset on SCDT = 0
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0x0D, 0x1C); 			// HDMI Transcode mode enable
-
-UNMASK_INTR_4_INTERRUPTS;
-
-//I2C_WriteByte(SA_TX_Page0_Primary, 0x78, BIT_6) 
-  SiI9234_startTPI();
-WriteByteTPI(TPI_INTERRUPT_ENABLE_REG, 0x02);
-  //ReadModifyWriteTPI(TPI_INTERRUPT_ENABLE_REG, 0x03, 	0x03);	 //enable HPD and RSEN interrupt
-  
-}
-
-
-////////////////////////////////////////////////////////////////////
-// Int4Isr
-//
-//
-//	Look for interrupts on INTR4 (Register 0x74)
-//		7 = RSVD		(reserved)
-//		6 = RGND Rdy	(interested)
-//		5 = VBUS Low	(ignore)	
-//		4 = CBUS LKOUT	(interested)
-//		3 = USB EST		(interested)
-//		2 = MHL EST		(interested)
-//		1 = RPWR5V Change	(ignore)
-//		0 = SCDT Change	(interested during D0)
-////////////////////////////////////////////////////////////////////
-static	void	Int4Isr( void )
-{
-	byte		reg74;
-
-	reg74 = I2C_ReadByte(SA_TX_Page0_Primary, (0x74));	// read status
-
-	printk(KERN_ERR "[MHL] Int4Isr : REG74 : %x\n",(int)reg74);
-
-	// When I2C is inoperational (say in D3) and a previous interrupt brought us here, do nothing.
-	if(0xFF == reg74)
-	{
-		printk(KERN_ERR "RETURN (0xFF == reg74)\n");
-		return;
-	}
-
-	if(reg74 & BIT_2) // MHL_EST_INT
-	{
-		if((I2C_ReadByte(SA_TX_Page0_Primary, 0x09) & BIT_2) == 0x00) {
-			printk(KERN_ERR "[MHL] RSEN is low - status incorrect\n");
-			MHL_On(0);
-			return;
-		}
-    	        MASK_CBUS1_INTERRUPTS; 
-    	        MASK_CBUS2_INTERRUPTS;
-		//fwPowerState = TX_POWER_STATE_D0_MHL;
-		//EnableFSA9480Interrupts(); //daniel 
-		MhlTxDrvProcessConnection(); 
-	}
-
-	// process USB_EST interrupt
-	else if(reg74 & BIT_3) // MHL_DISC_FAIL_INT
-	{
-    if(mhl_cable_status == (MHL_1K_IMPEDANCE_VERIFIED|MHL_POWER_ON))//|MHL_RSEN_VERIFIED))
-    {
-      mhl_cable_status =MHL_TV_OFF_CABLE_CONNECT;
-      printk(KERN_ERR "MHL Connection Fail Power off ###\n");
-	MHL_On(0);
-      #if defined(CONFIG_S5PC110_DEMPSEY_BOARD)
-        FSA9480_MhlTvOff();//Rajucm: Mhl cable handling when TV Off 
-      #endif
-    }
-    else
-    {
-		MhlTxDrvProcessDisconnection();
-    }
-		return;
-	}
-
-	if((TX_POWER_STATE_D3 == fwPowerState) && (reg74 & BIT_6))
-
-	{
-		// process RGND interrupt
-
-		// Switch to full power mode.
-		SwitchToD0();
-
-		//
-		// If a sink is connected but not powered on, this interrupt can keep coming
-		// Determine when to go back to sleep. Say after 1 second of this state.
-		//
-		// Check RGND register and send wake up pulse to the peer
-		//
-		ProcessRgnd();
-	}
-
-	// CBUS Lockout interrupt?
-	if (reg74 & BIT_4)
-	{
-		TX_DEBUG_PRINT(("Drv: CBus Lockout\n"));
-
-		ForceUsbIdSwitchOpen();
-		ReleaseUsbIdSwitchOpen();
-	}
-	I2C_WriteByte(SA_TX_Page0_Primary, (0x74), reg74);	// clear all interrupts
-
-}
-///////////////////////////////////////////////////////////////////////////
-//
-// MhlTxDrvProcessConnection
-//
-///////////////////////////////////////////////////////////////////////////
-void MhlTxDrvProcessConnection ( void )
-{
-	bool	mhlConnected = TRUE;
-
-	TX_DEBUG_PRINT (("Drv: MHL Cable Connected. CBUS:0x0A = %02X\n", (int) ReadByteCBUS(0x0a)));
-
-	if( TX_POWER_STATE_D0_MHL == fwPowerState )
-	{
-		TX_DEBUG_PRINT(("POWER_STATE_D0_MHL == fwPowerState\n"));
-		return;
-	}
-
-	//
-	// Discovery over-ride: reg_disc_ovride	
-	//
-	I2C_WriteByte(SA_TX_Page0_Primary, 0xA0, 0x10);
-	fwPowerState = TX_POWER_STATE_D0_MHL;
-
-
-
-	// Increase DDC translation layer timer (byte mode)
-	// Setting DDC Byte Mode
-	//
-	WriteByteCBUS(0x07, 0x32);
-
-	// Enable segment pointer safety
-	SET_BIT(SA_TX_CBUS_Primary, 0x44, 1);
-
-
-	// Un-force HPD (it was kept low, now propagate to source
-	CLR_BIT(SA_TX_Page0_Primary, 0x79, 4);
-
-	// Enable TMDS
-	SiiMhlTxDrvTmdsControl( TRUE );
-
-	// Keep the discovery enabled. Need RGND interrupt
-	// SET_BIT(SA_TX_Page0_Primary, 0x90, 0);
-	ENABLE_DISCOVERY;
-
-	// Notify upper layer of cable connection
-	SiiMhlTxNotifyConnection(mhlConnected = TRUE);
-}
-///////////////////////////////////////////////////////////////////////////
-//
-// MhlTxDrvProcessDisconnection
-//
-///////////////////////////////////////////////////////////////////////////
-void MhlTxDrvProcessDisconnection ( void )
-{
-	bool	mhlConnected = FALSE;
-
-	TX_DEBUG_PRINT (("Drv: MhlTxDrvProcessDisconnection\n"));
-
-	// clear all interrupts
-	I2C_WriteByte(SA_TX_Page0_Primary, (0x74), I2C_ReadByte(SA_TX_Page0_Primary, (0x74)));
-
-	I2C_WriteByte(SA_TX_Page0_Primary, 0xA0, 0xD0);
-
-	//
-	// Reset CBus to clear register contents
-	// This may need some key reinitializations
-	//
-	CbusReset();
-
-	// Disable TMDS
-	SiiMhlTxDrvTmdsControl( FALSE );
-
-	if( TX_POWER_STATE_D0_MHL == fwPowerState )
-	{
-		// Notify upper layer of cable connection
-		SiiMhlTxNotifyConnection(mhlConnected = FALSE);
-	}
-
-	// Now put chip in sleep mode
-	SwitchToD3();
-}
-///////////////////////////////////////////////////////////////////////////
-//
-// CbusReset
-//
-///////////////////////////////////////////////////////////////////////////
-void	CbusReset()
-{
-	SET_BIT(SA_TX_Page0_Primary, 0x05, 3);
-	DelayMS(2);
-	CLR_BIT(SA_TX_Page0_Primary, 0x05, 3);
-
-	mscCmdInProgress = FALSE;
-
-	// Adjust interrupt mask everytime reset is performed.
-	UNMASK_CBUS1_INTERRUPTS;
-	UNMASK_CBUS2_INTERRUPTS;
-}
-///////////////////////////////////////////////////////////////////////////
-//
-// CBusProcessErrors
-//
-//
-///////////////////////////////////////////////////////////////////////////
-static byte CBusProcessErrors( byte intStatus )
-{
-	byte result          = 0;
-	byte mscAbortReason  = 0;
-	byte ddcAbortReason  = 0;
-
-	/* At this point, we only need to look at the abort interrupts. */
-
-	intStatus &=  (BIT_MSC_ABORT | BIT_MSC_XFR_ABORT);
-
-	if ( intStatus )
-	{
-		//      result = ERROR_CBUS_ABORT;		// No Retry will help
-
-		/* If transfer abort or MSC abort, clear the abort reason register. */
-		if( intStatus & BIT_DDC_ABORT )
-		{
-			result = ddcAbortReason = ReadByteCBUS((byte) REG_DDC_ABORT_REASON );
-			TX_DEBUG_PRINT( ("CBUS DDC ABORT happened, reason:: %02X\n", (int)(ddcAbortReason)));
-		}
-
-		if ( intStatus & BIT_MSC_XFR_ABORT )
-		{
-			result = mscAbortReason = ReadByteCBUS((byte) REG_PRI_XFR_ABORT_REASON );
-
-			TX_DEBUG_PRINT( ("CBUS:: MSC Transfer ABORTED. Clearing 0x0D\n"));
-			WriteByteCBUS((byte) REG_PRI_XFR_ABORT_REASON, 0xFF );
-		}
-		if ( intStatus & BIT_MSC_ABORT )
-		{
-			TX_DEBUG_PRINT( ("CBUS:: MSC Peer sent an ABORT. Clearing 0x0E\n"));
-			WriteByteCBUS((byte) REG_CBUS_PRI_FWR_ABORT_REASON, 0xFF );
-		}
-
-		// Now display the abort reason.
-
-		if ( mscAbortReason != 0 )
-		{
-			TX_DEBUG_PRINT( ("CBUS:: Reason for ABORT is ....0x%02X = ", (int)mscAbortReason ));
-
-			if ( mscAbortReason & CBUSABORT_BIT_REQ_MAXFAIL)
-			{
-				TX_DEBUG_PRINT( ("Requestor MAXFAIL - retry threshold exceeded\n"));
-			}
-			if ( mscAbortReason & CBUSABORT_BIT_PROTOCOL_ERROR)
-			{
-				TX_DEBUG_PRINT( ("Protocol Error\n"));
-			}
-			if ( mscAbortReason & CBUSABORT_BIT_REQ_TIMEOUT)
-			{
-				TX_DEBUG_PRINT( ("Requestor translation layer timeout\n"));
-			}
-			if ( mscAbortReason & CBUSABORT_BIT_PEER_ABORTED)
-			{
-				TX_DEBUG_PRINT( ("Peer sent an abort\n"));
-			}
-			if ( mscAbortReason & CBUSABORT_BIT_UNDEFINED_OPCODE)
-			{
-				TX_DEBUG_PRINT( ("Undefined opcode\n"));
-			}
-		}
-	}
-	return( result );
-}
-
-///////////////////////////////////////////////////////////////////////////
-//
-// MhlCbusIsr
-//
-// Only when MHL connection has been established. This is where we have the
-// first looks on the CBUS incoming commands or returned data bytes for the
-// previous outgoing command.
-//
-// It simply stores the event and allows application to pick up the event
-// and respond at leisure.
-//
-// Look for interrupts on CBUS:CBUS_INTR_STATUS [0xC8:0x08]
-//		7 = RSVD			(reserved)
-//		6 = MSC_RESP_ABORT	(interested)
-//		5 = MSC_REQ_ABORT	(interested)	
-//		4 = MSC_REQ_DONE	(interested)
-//		3 = MSC_MSG_RCVD	(interested)
-//		2 = DDC_ABORT		(interested)
-//		1 = RSVD			(reserved)
-//		0 = rsvd			(reserved)
-///////////////////////////////////////////////////////////////////////////
-static void MhlCbusIsr( void )
-{
-	byte		cbusInt;
-	byte     gotData[4];	// Max four status and int registers.
-	byte		i;
-
-	//
-	// Main CBUS interrupts on CBUS_INTR_STATUS
-	//
-	cbusInt = ReadByteCBUS(0x08);
-
-	// When I2C is inoperational (say in D3) and a previous interrupt brought us here, do nothing.
-	if(cbusInt == 0xFF)
-	{
-		return;
-	}
-	if( cbusInt )
-	{
-		TX_DEBUG_PRINT(("Drv: CBUS INTR_1: %d\n", (int) cbusInt));
-	}
-
-	// Look for DDC_ABORT
-	if (cbusInt & BIT_2)
-	{
-		ApplyDdcAbortSafety();
-	}
-	// MSC_MSG (RCP/RAP)
-	if((cbusInt & BIT_3))
-	{
-		TX_DEBUG_PRINT(("Drv: MSC_MSG Received: %02X\n", (int) cbusInt));
-		//
-		// Two bytes arrive at registers 0x18 and 0x19
-		//
-		SiiMhlTxGotMhlMscMsg( ReadByteCBUS( 0x18 ), ReadByteCBUS( 0x19 ) );
-	}
-	// MSC_REQ_DONE received.
-	if(cbusInt & BIT_4)
-	{
-		TX_DEBUG_PRINT(("Drv: MSC_REQ_DONE: %02X\n", (int) cbusInt));
-
-		mscCmdInProgress = FALSE;
-
-		SiiMhlTxMscCommandDone( ReadByteCBUS( 0x16 ) );
-	}
-	if((cbusInt & BIT_5) || (cbusInt & BIT_6))	// MSC_REQ_ABORT or MSC_RESP_ABORT
-	{
-		gotData[0] = CBusProcessErrors(cbusInt);
-	}
-	if(cbusInt)
-	{
-		//
-		// Clear all interrupts that were raised even if we did not process
-		//
-		WriteByteCBUS(0x08, cbusInt);
-
-		TX_DEBUG_PRINT(("Drv: Clear CBUS INTR_1: %02X\n", (int) cbusInt));
-	}
-	//
-	// Clear all interrupts that were raised even if we did not process
-	//
-
-	//
-	// Now look for interrupts on register 0x1E. CBUS_MSC_INT2
-	// 7:4 = Reserved
-	//   3 = msc_mr_write_state = We got a WRITE_STAT
-	//   2 = msc_mr_set_int. We got a SET_INT
-	//   1 = reserved
-	//   0 = msc_mr_write_burst. We received WRITE_BURST
-	//
-	cbusInt = ReadByteCBUS(0x1E);
-	if( cbusInt )
-	{
-		TX_DEBUG_PRINT(("Drv: CBUS INTR_2: %x\n", (int) cbusInt));
-	}
-	if(cbusInt & BIT_2)
-	{
-		TX_DEBUG_PRINT(("Drv: INT Received: %x\n", (int) cbusInt));
-
-		// We are interested only in first two bytes.
-		SiiMhlTxGotMhlIntr( ReadByteCBUS( 0xA0 ), ReadByteCBUS( 0xA1) );
-
-		for(i = 0; i < 4; i++)
-		{
-			// Clear all
-			WriteByteCBUS( (0xA0 + i), ReadByteCBUS( 0xA0 + i ));
-		}
-	}
-	if(cbusInt & BIT_3)
-	{
-		TX_DEBUG_PRINT(("Drv: STATUS Received: %x\n", (int) cbusInt));
-
-		// We are interested only in first two bytes.
-		SiiMhlTxGotMhlStatus( ReadByteCBUS( 0xB0 ), ReadByteCBUS( 0xB1) );
-
-		for(i = 0; i < 4; i++)
-		{
-			// Clear all
-			WriteByteCBUS( (0xB0 + i), ReadByteCBUS( 0xB0 + i ));
-		}
-	}
-	if(cbusInt)
-	{
-		//
-		// Clear all interrupts that were raised even if we did not process
-		//
-		WriteByteCBUS(0x1E, cbusInt);
-
-		TX_DEBUG_PRINT(("Drv: Clear CBUS INTR_2: %02X\n", (int) cbusInt));
-	}
-
-#if 0
-	//
-	// Check if a SET_HPD came from the downstream device.
-	//
-	cbusInt = ReadByteCBUS(0x0D);
-
-	// CBUS_HPD status bit
-	if((BIT_6 & cbusInt) != dsHpdStatus)
-	{
-		// Inform upper layer of change in Downstream HPD
-		SiiMhlTxNotifyDsHpdChange( cbusInt );
-		TX_DEBUG_PRINT(("Drv: Downstream HPD changed to: %02X\n", (int) cbusInt));
-
-		// Remember
-		dsHpdStatus = (BIT_6 & cbusInt);
-	}
-#endif
-}
-
-
-
-
-///////////////////////////////////////////////////////////////////////////////
-// sii_mhl_tx_init
-//
-// Sets the transmitter component firmware up for operation, brings up chip
-// into power on state first and then back to reduced-power mode D3 to conserve
-// power until an MHL cable connection has been established. If the MHL port is
-// used for USB operation, the chip and firmware continue to stay in D3 mode.
-// Only a small circuit in the chip observes the impedance variations to see if
-// processor should be interrupted to continue MHL discovery process or not.
-//
-// interruptDriven		If TRUE, MhlTx component will not look at its status
-//						registers in a polled manner from timer handler 
-//						(SiiMhlTxGetEvents). It will expect that all device 
-//						events will result in call to the function 
-//						SiiMhlTxDeviceIsr() by host's hardware or software 
-//						(a master interrupt handler in host software can call
-//						it directly). interruptDriven == TRUE also implies that
-//						the MhlTx component shall make use of AppDisableInterrupts()
-//						and AppRestoreInterrupts() for any critical section work to
-//						prevent concurrency issues.
-//
-//						When interruptDriven == FALSE, MhlTx component will do
-//						all chip status analysis via looking at its register
-//						when called periodically into the function
-//						SiiMhlTxGetEvents() described below.
-//
-// pollIntervalMs		This number should be higher than 0 and lower than 
-//						51 milliseconds for effective operation of the firmware.
-//						A higher number will only imply a slower response to an 
-//						event on MHL side which can lead to violation of a 
-//						connection disconnection related timing or a slower 
-//						response to RCP messages.
-//
-//
-//
-//
-//void sii_mhl_tx_init( bool interruptDriven, byte pollIntervalMs )
-void sii_mhl_tx_init( void )
-{
-	TX_DEBUG_PRINT( ("MhlTx: sii_mhl_tx_init\n") );
-
-	MhlTxResetStates( );
-
-	SiiMhlTxChipInitialize ();
-	mhl_cable_status =MHL_POWER_ON;			//NAGSM_Android_SEL_Kernel_Aakash_20101214
-}
-
-
-///////////////////////////////////////////////////////////////////////////////
-// 
-// SiiMhlTxGetEvents
-//
-// This is a function in MhlTx that must be called by application in a periodic
-// fashion. The accuracy of frequency (adherence to the parameter pollIntervalMs)
-// will determine adherence to some timings in the MHL specifications, however,
-// MhlTx component keeps a tolerance of up to 50 milliseconds for most of the
-// timings and deploys interrupt disabled mode of operation (applicable only to
-// Sii 9244) for creating precise pulse of smaller duration such as 20 ms.
-//
-// This function does not return anything but it does modify the contents of the
-// two pointers passed as parameter.
-//
-// It is advantageous for application to call this function in task context so
-// that interrupt nesting or concurrency issues do not arise. In addition, by
-// collecting the events in the same periodic polling mechanism prevents a call
-// back from the MhlTx which can result in sending yet another MHL message.
-//
-// An example of this is responding back to an RCP message by another message
-// such as RCPK or RCPE.
-//
-//
-// *event		MhlTx returns a value in this field when function completes execution.
-// 				If this field is 0, the next parameter is undefined.
-//				The following values may be returned.
-//
-//
-void SiiMhlTxGetEvents( byte *event, byte *eventParameter )
-{
-
-	SiiMhlTxDeviceIsr();
-
-	if(mhl_cable_status == MHL_TV_OFF_CABLE_CONNECT)
-	{
-		return ;
-	}
-
-	MhlTxDriveStates( );
-
-	*event = MHL_TX_EVENT_NONE;
-	*eventParameter = 0;
-
-	if( mhlTxConfig.mhlConnectionEvent )
-	{
-		TX_DEBUG_PRINT( ("MhlTx: SiiMhlTxGetEvents mhlConnectionEvent\n") );
-
-		// Consume the message
-		mhlTxConfig.mhlConnectionEvent = FALSE;
-
-		//
-		// Let app know the connection went away.
-		//
-		*event          = mhlTxConfig.mhlConnected;
-		*eventParameter	= mhlTxConfig.mscFeatureFlag;
-
-		// If connection has been lost, reset all state flags.
-		if(MHL_TX_EVENT_DISCONNECTION == mhlTxConfig.mhlConnected)
-		{
-			MhlTxResetStates( );
-		}
-	}
-	else if( mhlTxConfig.mscMsgArrived )
-	{
-		TX_DEBUG_PRINT( ("MhlTx: SiiMhlTxGetEvents MSC MSG Arrived\n") );
-
-		// Consume the message
-		mhlTxConfig.mscMsgArrived = FALSE;
-
-		//
-		// Map sub-command to an event id
-		//
-		switch(mhlTxConfig.mscMsgSubCommand)
-		{
-			case	MHL_MSC_MSG_RAP:
-				// RAP is fully handled here.
-				//
-				// Handle RAP sub-commands here itself
-				//
-				if( MHL_RAP_CONTENT_ON == mhlTxConfig.mscMsgData)
-				{
-					SiiMhlTxDrvTmdsControl( TRUE );
-				}
-				else if( MHL_RAP_CONTENT_OFF == mhlTxConfig.mscMsgData)
-				{
-					SiiMhlTxDrvTmdsControl( FALSE );
-
-				}
-				// Always RAPK to the peer
-				SiiMhlTxRapkSend( );
-				break;
-
-			case	MHL_MSC_MSG_RCP:
-
-				// If we get a RCP key that we do NOT support, send back RCPE
-				// Do not notify app layer.
-				if(MHL_LOGICAL_DEVICE_MAP & rcpSupportTable [mhlTxConfig.mscMsgData] )
-				{
-				*event          = MHL_TX_EVENT_RCP_RECEIVED;
-				*eventParameter = mhlTxConfig.mscMsgData; // key code
-#if 1	// xmoondash :: compile error
-/* jinho96.kim 2011.01.06 */
-				rcp_cbus_uevent(*eventParameter);	//MHL v1 //NAGSM_Android_SEL_Kernel_Aakash_20101126
-#endif
-
-				printk(KERN_ERR "Key Code:%x \n",(int)mhlTxConfig.mscMsgData);
-                                }
-else
-				{
-  				printk("Key Code Error:%x \n",(int)mhlTxConfig.mscMsgData);
-					SiiMhlTxRcpeSend( 0x01 );
-				}
-				break;
-
-			case	MHL_MSC_MSG_RCPK:
-				*event = MHL_TX_EVENT_RCPK_RECEIVED;
-        *eventParameter = mhlTxConfig.mscMsgData; // key code
-				break;
-
-			case	MHL_MSC_MSG_RCPE:
-				*event = MHL_TX_EVENT_RCPE_RECEIVED;
-        *eventParameter = mhlTxConfig.mscMsgData; // status code
-				break;
-
-			case	MHL_MSC_MSG_RAPK:
-				// Do nothing if RAPK comes
-				break;
-
-			default:
-				// Any freak value here would continue with no event to app
-				break;
-		}
-
-	}
-}
-///////////////////////////////////////////////////////////////////////////////
-//
-// MhlTxDriveStates
-//
-// This is an internal function to move the MSC engine to do the next thing
-// before allowing the application to run RCP APIs.
-//
-// It is called in interrupt context to meet some MHL specified timings, therefore,
-// it should not have to call app layer and do negligible processing, no printks.
-//
-static	void	MhlTxDriveStates( void )
-{
-
-	switch( mhlTxConfig.mscState )
-	{
-		case MSC_STATE_BEGIN:
-			printk(KERN_ERR "MSC_STATE_BEGIN \n");
-			SiiMhlTxReadDevcap( MHL_DEV_CATEGORY_OFFSET );
-			break;
-		case MSC_STATE_POW_DONE:
-			//
-			// Send out Read Devcap for MHL_DEV_FEATURE_FLAG_OFFSET
-			// to check if it supports RCP/RAP etc
-			//
-			printk(KERN_ERR "MSC_STATE_POW_DONE \n");
-			SiiMhlTxReadDevcap( MHL_DEV_FEATURE_FLAG_OFFSET );
-			break;
-		case MSC_STATE_IDLE:
-		case MSC_STATE_RCP_READY:
-			break;
-		default:
-			break;
-
-	}
-}
-///////////////////////////////////////////////////////////////////////////////
-//
-// SiiMhlTxMscCommandDone
-//
-// This function is called by the driver to inform of completion of last command.
-//
-// It is called in interrupt context to meet some MHL specified timings, therefore,
-// it should not have to call app layer and do negligible processing, no printks.
-//
-void	SiiMhlTxMscCommandDone( byte data1 )
-{
-	TX_DEBUG_PRINT( ("MhlTx: SiiMhlTxMscCommandDone. data1 = %02X\n", (int) data1) );
-
-	if(( MHL_READ_DEVCAP == mhlTxConfig.mscLastCommand ) && 
-			(MHL_DEV_CATEGORY_OFFSET == mhlTxConfig.mscLastOffset))
-	{
-		// We are done reading POW. Next we read Feature Flag
-		mhlTxConfig.mscState	= MSC_STATE_POW_DONE;
-
-		AppVbusControl( (bool) ( data1 & MHL_DEV_CATEGORY_POW_BIT) );
-
-		//
-		// Send out Read Devcap for MHL_DEV_FEATURE_FLAG_OFFSET
-		// to check if it supports RCP/RAP etc
-		//
-		//		SiiMhlTxReadDevcap( MHL_DEV_FEATURE_FLAG_OFFSET );
-
-		//		MhlTxDriveStates( );
-	}
-	else if((MHL_READ_DEVCAP == mhlTxConfig.mscLastCommand) &&
-			(MHL_DEV_FEATURE_FLAG_OFFSET == mhlTxConfig.mscLastOffset))
-	{
-		// We are done reading Feature Flag. Let app know we are done.
-		mhlTxConfig.mscState	= MSC_STATE_RCP_READY;
-
-		// Remember features of the peer
-		mhlTxConfig.mscFeatureFlag	= data1;
-
-		// Now we can entertain App commands for RCP
-		// Let app know this state
-		mhlTxConfig.mhlConnectionEvent = TRUE;
-		mhlTxConfig.mhlConnected = MHL_TX_EVENT_RCP_READY;
-
-		// These variables are used to remember if we issued a READ_DEVCAP
-		// Since we are done, reset them.
-		mhlTxConfig.mscLastCommand = 0;
-		mhlTxConfig.mscLastOffset  = 0;
-
-		TX_DEBUG_PRINT( ("MhlTx: Peer's Feature Flag = %02X\n\n", (int) data1) );
-	}
-	else if(MHL_MSC_MSG_RCPE == mhlTxConfig.mscMsgLastCommand)
-	{
-		//
-		// RCPE is always followed by an RCPK with original key code that came.
-		//
-		if( SiiMhlTxRcpkSend( mhlTxConfig.mscSaveRcpKeyCode ) )
-		{
-			// Once the command has been sent out successfully, forget this case.
-			mhlTxConfig.mscMsgLastCommand = 0;
-			mhlTxConfig.mscMsgLastData    = 0;
-		}
-}
-}
-///////////////////////////////////////////////////////////////////////////////
-//
-// SiiMhlTxGotMhlMscMsg
-//
-// This function is called by the driver to inform of arrival of a MHL MSC_MSG
-// such as RCP, RCPK, RCPE. To quickly return back to interrupt, this function
-// remembers the event (to be picked up by app later in task context).
-//
-// It is called in interrupt context to meet some MHL specified timings, therefore,
-// it should not have to call app layer and do negligible processing of its own,
-//
-// No printks.
-//
-// Application shall not call this function.
-//
-void	SiiMhlTxGotMhlMscMsg( byte subCommand, byte cmdData )
-{
-	// Remeber the event.
-	mhlTxConfig.mscMsgArrived		= TRUE;
-	mhlTxConfig.mscMsgSubCommand	= subCommand;
-	mhlTxConfig.mscMsgData			= cmdData;
-}
-///////////////////////////////////////////////////////////////////////////////
-//
-// SiiMhlTxGotMhlIntr
-//
-// This function is called by the driver to inform of arrival of a MHL INTERRUPT.
-//
-// It is called in interrupt context to meet some MHL specified timings, therefore,
-// it should not have to call app layer and do negligible processing, no printks.
-//
-void	SiiMhlTxGotMhlIntr( byte intr_0, byte intr_1 )
-{
-	TX_DEBUG_PRINT( ("MhlTx: INTERRUPT Arrived. %02X, %02X\n", (int) intr_0, (int) intr_1) );
-
-	//
-	// Handle DCAP_CHG INTR here
-	//
-	if(MHL_INT_DCAP_CHG & intr_0)
-	{
-		SiiMhlTxReadDevcap( MHL_DEV_CATEGORY_OFFSET );
-		//		MhlTxDriveStates( );
-	}
-	else if(MHL_INT_EDID_CHG & intr_1)
-	{
-		// force upstream source to read the EDID again.
-		// Most likely by appropriate togggling of HDMI HPD
-		SiiMhlTxDrvNotifyEdidChange ( );
-	}
-}
-///////////////////////////////////////////////////////////////////////////////
-//
-// SiiMhlTxGotMhlStatus
-//
-// This function is called by the driver to inform of arrival of a MHL STATUS.
-//
-// It is called in interrupt context to meet some MHL specified timings, therefore,
-// it should not have to call app layer and do negligible processing, no printks.
-//
-void	SiiMhlTxGotMhlStatus( byte status_0, byte status_1 )
-{
-	TX_DEBUG_PRINT( ("MhlTx: STATUS Arrived. %02X, %02X\n", (int) status_0, (int) status_1) );
-	//
-	// Handle DCAP_RDY STATUS here itself
-	//
-	if(MHL_STATUS_DCAP_RDY & status_0)
-	{
-		//		MhlTxDriveStates( );
-		//		SiiMhlTxReadDevcap( MHL_DEV_CATEGORY_OFFSET );
-    mhlTxConfig.mscState	 = MSC_STATE_BEGIN;
-	}
-	// status_1 has the PATH_EN etc. Not yet implemented
-	// Remeber the event.
-	mhlTxConfig.status_0 = status_0;
-	mhlTxConfig.status_1 = status_1;
-}
-///////////////////////////////////////////////////////////////////////////////
-//
-// SiiMhlTxRcpSend
-//
-// This function checks if the peer device supports RCP and sends rcpKeyCode. The
-// function will return a value of TRUE if it could successfully send the RCP
-// subcommand and the key code. Otherwise FALSE.
-//
-// The followings are not yet utilized.
-// 
-// (MHL_FEATURE_RAP_SUPPORT & mhlTxConfig.mscFeatureFlag))
-// (MHL_FEATURE_SP_SUPPORT & mhlTxConfig.mscFeatureFlag))
-//
-//
-bool SiiMhlTxRcpSend( byte rcpKeyCode )
-{
-	//
-	// If peer does not support do not send RCP or RCPK/RCPE commands
-	//
-	if((0 == (MHL_FEATURE_RCP_SUPPORT & mhlTxConfig.mscFeatureFlag)) ||
-			(MSC_STATE_RCP_READY != mhlTxConfig.mscState))
-	{
-		return	FALSE;
-	}
-	return	( MhlTxSendMscMsg ( MHL_MSC_MSG_RCP, rcpKeyCode ) );
-}
-
-///////////////////////////////////////////////////////////////////////////////
-//
-// SiiMhlTxRcpkSend
-//
-// This function sends RCPK to the peer device. 
-//
-bool SiiMhlTxRcpkSend( byte rcpKeyCode )
-{
-	return	( MhlTxSendMscMsg ( MHL_MSC_MSG_RCPK, rcpKeyCode ) );
-}
-
-///////////////////////////////////////////////////////////////////////////////
-//
-// SiiMhlTxRapkSend
-//
-// This function sends RAPK to the peer device. 
-//
-static	bool SiiMhlTxRapkSend( void )
-{
-	return	( MhlTxSendMscMsg ( MHL_MSC_MSG_RAPK, 0 ) );
-}
-
-///////////////////////////////////////////////////////////////////////////////
-//
-// SiiMhlTxRcpeSend
-//
-// The function will return a value of true if it could successfully send the RCPE
-// subcommand. Otherwise false.
-//
-// When successful, MhlTx internally sends RCPK with original (last known)
-// keycode.
-//
-bool SiiMhlTxRcpeSend( byte rcpeErrorCode )
-{
-	return( MhlTxSendMscMsg ( MHL_MSC_MSG_RCPE, rcpeErrorCode ) );
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-//
-
-// SiiMhlTxReadDevcap
-//
-// This function sends a READ DEVCAP MHL command to the peer.
-// It  returns TRUE if successful in doing so.
-//
-// The value of devcap should be obtained by making a call to SiiMhlTxGetEvents()
-//
-// offset		Which byte in devcap register is required to be read. 0..0x0E
-//
-bool SiiMhlTxReadDevcap( byte offset )
-{
-	cbus_req_t	req;
-	//
-	// Send MHL_READ_DEVCAP command
-	//
-	req.command     = mhlTxConfig.mscLastCommand = MHL_READ_DEVCAP;
-	req.offsetData  = mhlTxConfig.mscLastOffset  = offset;
-	return(SiiMhlTxDrvSendCbusCommand( &req  ));
-}
-
-///////////////////////////////////////////////////////////////////////////////
-//
-// MhlTxSendMscMsg
-//
-// This function sends a MSC_MSG command to the peer.
-// It  returns TRUE if successful in doing so.
-//
-// The value of devcap should be obtained by making a call to SiiMhlTxGetEvents()
-//
-// offset		Which byte in devcap register is required to be read. 0..0x0E
-//
-static bool MhlTxSendMscMsg ( byte command, byte cmdData )
-{
-	cbus_req_t	req;
-	byte		ccode;
-
-	//
-	// Send MSC_MSG command
-	//
-	req.command     = MHL_MSC_MSG;
-	req.msgData[0]  = mhlTxConfig.mscMsgLastCommand = command;
-	req.msgData[1]  = mhlTxConfig.mscMsgLastData    = cmdData;
-
-
-
-	ccode = SiiMhlTxDrvSendCbusCommand( &req  );
-	return( (bool) ccode );
-
-}
-///////////////////////////////////////////////////////////////////////////////
-// 
-// SiiMhlTxNotifyConnection
-//
-//
-void	SiiMhlTxNotifyConnection( bool mhlConnected )
-{
-	//	printk(KERN_ERR "SiiMhlTxNotifyConnection %01X\n", (int) mhlConnected );
-
-	mhlTxConfig.mhlConnectionEvent = TRUE;
-
-  mhlTxConfig.mscState	 = MSC_STATE_IDLE;
-	if(mhlConnected)
-	{
-		mhlTxConfig.mhlConnected = MHL_TX_EVENT_CONNECTION;
-	}
-	else
-	{
-		mhlTxConfig.mhlConnected = MHL_TX_EVENT_DISCONNECTION;
-	}
-}
-///////////////////////////////////////////////////////////////////////////////
-//
-// SiiMhlTxNotifyDsHpdChange
-// Driver tells about arrival of SET_HPD or CLEAR_HPD by calling this function.
-//
-// Turn the content off or on based on what we got.
-//
-void	SiiMhlTxNotifyDsHpdChange( byte dsHpdStatus )
-{
-	if( 0 == dsHpdStatus )
-	{
-		TX_DEBUG_PRINT(("MhlTx: Disable TMDS\n"));
-		SiiMhlTxDrvTmdsControl( FALSE );
-	}
-	else
-	{
-		TX_DEBUG_PRINT(("MhlTx: Enable TMDS\n"));
-		SiiMhlTxDrvTmdsControl( TRUE );
-	}
-}
-///////////////////////////////////////////////////////////////////////////////
-//
-// MhlTxResetStates
-//
-// Application picks up mhl connection and rcp events at periodic intervals.
-// Interrupt handler feeds these variables. Reset them on disconnection. 
-//
-static void	MhlTxResetStates( void )
-{
-	mhlTxConfig.mhlConnectionEvent	= FALSE;
-	mhlTxConfig.mhlConnected		= MHL_TX_EVENT_DISCONNECTION;
-	mhlTxConfig.mscMsgArrived		= FALSE;
-	mhlTxConfig.mscState			= MSC_STATE_IDLE;
-}
-
-#define	APP_DEMO_RCP_SEND_KEY_CODE 0x44
-
-///////////////////////////////////////////////////////////////////////////////
-//
-// AppRcpDemo
-//
-// This function is supposed to provide a demo code to elicit how to call RCP
-// API function.
-//
-void	AppRcpDemo( byte event, byte eventParameter)
-{
-	byte		rcpKeyCode;
-
-	//	printk(KERN_ERR "App: Got event = %02X, eventParameter = %02X\n", (int)event, (int)eventParameter);
-
-	switch( event )
-	{
-		case	MHL_TX_EVENT_DISCONNECTION:
-			printk(KERN_ERR "App: Got event = MHL_TX_EVENT_DISCONNECTION\n");
-			break;
-
-		case	MHL_TX_EVENT_CONNECTION:
-			printk(KERN_ERR "App: Got event = MHL_TX_EVENT_CONNECTION\n");
-			break;
-
-		case	MHL_TX_EVENT_RCP_READY:
-
-			// Demo RCP key code PLAY
-			rcpKeyCode = APP_DEMO_RCP_SEND_KEY_CODE;
-
-			printk(KERN_ERR "App: Got event = MHL_TX_EVENT_RCP_READY...Sending RCP (%02X)\n", (int) rcpKeyCode);
-
-#if 0
-			if( (0 == (MHL_FEATURE_RCP_SUPPORT & eventParameter)) )
-			{
-				printk(KERN_ERR  "App: Peer does NOT support RCP\n" );
-			}
-			if( (0 == (MHL_FEATURE_RAP_SUPPORT & eventParameter)) )
-			{
-				printk(KERN_ERR  "App: Peer does NOT support RAP\n" );
-			}
-			if( (0 == (MHL_FEATURE_SP_SUPPORT & eventParameter)) )
-			{
-				printk(KERN_ERR  "App: Peer does NOT support WRITE_BURST\n" );
-			}
-
-
-			//
-			// If RCP engine is ready, send one code
-			//
-			if( SiiMhlTxRcpSend( rcpKeyCode ))
-			{
-				printk(KERN_ERR "App: SiiMhlTxRcpSend (%02X)\n", (int) rcpKeyCode);
-			}
-			else
-			{
-				printk(KERN_ERR "App: SiiMhlTxRcpSend (%02X) Returned Failure.\n", (int) rcpKeyCode);
-			}
-#endif
-
-			break;
-
-		case	MHL_TX_EVENT_RCP_RECEIVED:
-			//
-			// Check if we got an RCP. Application can perform the operation here
-			// and send RCPK or RCPE. For now, we send the RCPK
-			//
-			printk(KERN_ERR "App: Received an RCP key code = %02X\n", eventParameter );
-
-			switch(eventParameter)
-			{
-
-				case MHD_RCP_CMD_SELECT:
-					TX_DEBUG_PRINT(( "\nSelect received = %02x\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_UP:
-					TX_DEBUG_PRINT(( "\nUp received = %02x\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_DOWN:
-					TX_DEBUG_PRINT(( "\nDown received = %02x\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_LEFT:
-					TX_DEBUG_PRINT(( "\nLeft received = %02x\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_RIGHT:
-					TX_DEBUG_PRINT(( "\nRight received = %02x\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_RIGHT_UP:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_RIGHT_UP = %02x\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_RIGHT_DOWN:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_RIGHT_DOWN = %02x\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_LEFT_UP:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_LEFT_UP = %02x\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_LEFT_DOWN:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_LEFT_DOWN\n\n", (int)eventParameter ));
-					break;      
-
-				case MHD_RCP_CMD_ROOT_MENU:
-					TX_DEBUG_PRINT(( "\nRoot Menu received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_SETUP_MENU:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_SETUP_MENU\n\n", (int)eventParameter ));
-					break;      
-
-				case MHD_RCP_CMD_CONTENTS_MENU:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_CONTENTS_MENU\n\n", (int)eventParameter ));
-					break;      
-
-				case MHD_RCP_CMD_FAVORITE_MENU:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_FAVORITE_MENU\n\n", (int)eventParameter ));
-					break;            
-
-				case MHD_RCP_CMD_EXIT:
-					TX_DEBUG_PRINT(( "\nExit received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_NUM_0:
-					TX_DEBUG_PRINT(( "\nNumber 0 received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_NUM_1:
-					TX_DEBUG_PRINT(( "\nNumber 1 received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_NUM_2:
-					TX_DEBUG_PRINT(( "\nNumber 2 received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_NUM_3:
-					TX_DEBUG_PRINT(( "\nNumber 3 received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_NUM_4:
-					TX_DEBUG_PRINT(( "\nNumber 4 received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_NUM_5:
-					TX_DEBUG_PRINT(( "\nNumber 5 received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_NUM_6:
-					TX_DEBUG_PRINT(( "\nNumber 6 received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_NUM_7:
-					TX_DEBUG_PRINT(( "\nNumber 7 received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_NUM_8:
-					TX_DEBUG_PRINT(( "\nNumber 8 received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_NUM_9:
-					TX_DEBUG_PRINT(( "\nNumber 9 received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_DOT:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_DOT\n\n", (int)eventParameter ));
-					break;          
-
-				case MHD_RCP_CMD_ENTER:
-					TX_DEBUG_PRINT(( "\nEnter received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_CLEAR:
-					TX_DEBUG_PRINT(( "\nClear received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_CH_UP:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_CH_UP\n\n", (int)eventParameter ));
-					break; 
-
-				case MHD_RCP_CMD_CH_DOWN:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_CH_DOWN\n\n", (int)eventParameter ));
-					break;       
-
-				case MHD_RCP_CMD_PRE_CH:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_PRE_CH\n\n", (int)eventParameter ));
-					break;           
-
-				case MHD_RCP_CMD_SOUND_SELECT:
-					TX_DEBUG_PRINT(( "\nSound Select received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_INPUT_SELECT:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_INPUT_SELECT\n\n", (int)eventParameter ));
-					break;    
-
-				case MHD_RCP_CMD_SHOW_INFO:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_SHOW_INFO\n\n", (int)eventParameter ));
-					break;     
-
-				case MHD_RCP_CMD_HELP:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_HELP\n\n", (int)eventParameter ));
-					break;   
-
-				case MHD_RCP_CMD_PAGE_UP:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_PAGE_UP\n\n", (int)eventParameter ));
-					break;  
-
-				case MHD_RCP_CMD_PAGE_DOWN:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_PAGE_DOWN\n\n", (int)eventParameter ));
-					break;             
-
-				case MHD_RCP_CMD_VOL_UP:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_VOL_UP\n\n", (int)eventParameter ));
-					break;             
-
-				case MHD_RCP_CMD_VOL_DOWN:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_VOL_DOWN\n\n", (int)eventParameter ));
-					break;             
-
-				case MHD_RCP_CMD_MUTE:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_MUTE\n\n", (int)eventParameter ));
-					break;             
-
-				case MHD_RCP_CMD_PLAY:
-					TX_DEBUG_PRINT(( "\nPlay received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_STOP:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_STOP\n\n", (int)eventParameter ));
-					break;   
-
-				case MHD_RCP_CMD_PAUSE:
-					TX_DEBUG_PRINT(( "\nPause received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_RECORD:
-					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_RECORD\n\n", (int)eventParameter ));
-					break;   
-
-				case MHD_RCP_CMD_FAST_FWD:
-					TX_DEBUG_PRINT(( "\nFastfwd received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_REWIND:
-					TX_DEBUG_PRINT(( "\nRewind received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_EJECT:
-					TX_DEBUG_PRINT(( "\nEject received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_FWD:
-					TX_DEBUG_PRINT(( "\nForward received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_BKWD:
-					TX_DEBUG_PRINT(( "\nBackward received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_PLAY_FUNC:
-					TX_DEBUG_PRINT(( "\nPlay Function received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_PAUSE_PLAY_FUNC:
-					TX_DEBUG_PRINT(( "\nPause_Play Function received\n\n", (int)eventParameter ));
-					break;
-
-				case MHD_RCP_CMD_STOP_FUNC:
-					TX_DEBUG_PRINT(( "\nStop Function received\n\n", (int)eventParameter ));
-					break;
-
-				default:
-
-					break;
-			}
-
-      
-rcpKeyCode = eventParameter;
-			SiiMhlTxRcpkSend(rcpKeyCode);
-			break;
-
-		case	MHL_TX_EVENT_RCPK_RECEIVED:
-			printk(KERN_ERR "App: Received an RCPK = \n");
-			break;
-
-		case	MHL_TX_EVENT_RCPE_RECEIVED:
-			printk(KERN_ERR "App: Received an RCPE = \n");
-			break;
-
-		default:
-			break;
-	}
-}
-
-///////////////////////////////////////////////////////////////////////////////
-//
-// AppVbusControl
-//
-// This function or macro is invoked from MhlTx driver to ask application to
-// control the VBUS power. If powerOn is sent as non-zero, one should assume
-// peer does not need power so quickly remove VBUS power.
-//
-// if value of "powerOn" is 0, then application must turn the VBUS power on
-// within 50ms of this call to meet MHL specs timing.
-//
-// Application module must provide this function.
-//
-void	AppVbusControl( bool powerOn )
-{
-	if( powerOn )
-	{
-		printk(KERN_ERR "App: Peer's POW bit is set. Turn the VBUS power OFF here.\n");
-	}
-	else
-	{
-		printk(KERN_ERR "App: Peer's POW bit is cleared. Turn the VBUS power ON here.\n");
-	}
-}
-
-
-/*===========================================================================
-  FUNCTION sii9234_interrupt_event
-
-  DESCRIPTION
-  When SiI9234 H/W interrupt happen, call this event function
-
-  DEPENDENCIES
-  None
-
-  RETURN VALUE
-  None
-
-  SIDE EFFECTS
-  None
-  ===========================================================================*/
-void sii9234_interrupt_event(void)
-{
-	byte	event;
-	byte	eventParameter;
-	byte	flag;
-	//int	loop_try = 0;
-
-	//TX_DEBUG_PRINT(("Start PinTxInt Pin Init : %d \n",(int)PinTxInt));
-
-	do {
-		//
-		// Look for any events that might have occurred.
-		//
-
-		flag = 0;
-		SiiMhlTxGetEvents( &event, &eventParameter );
-		if( MHL_TX_EVENT_NONE != event )
-		{
-			AppRcpDemo( event, eventParameter);
-		}
-
-    	if(mhl_cable_status == MHL_TV_OFF_CABLE_CONNECT)
-		{
-			byte tmp;
-    		tmp = I2C_ReadByte(SA_TX_Page0_Primary, (0x74));   // read status
-    		I2C_WriteByte(SA_TX_Page0_Primary, (0x74), tmp);   // clear all interrupts
-    		tmp = I2C_ReadByte(SA_TX_Page0_Primary, 0x71);
-    		I2C_WriteByte(SA_TX_Page0_Primary, 0x71, tmp);
-
-    		tmp = ReadByteCBUS(0x08);
-    		WriteByteCBUS(0x08, tmp);  
-
-    		tmp = ReadByteCBUS(0x1E);
-    		WriteByteCBUS(0x1E, tmp);    
-		TX_DEBUG_PRINT(("mhl_cable_status == MHL_TV_OFF_CABLE_CONNECT\n"));
-    		return ;
-
-    	}
-    	else if(((fwPowerState == TX_POWER_STATE_D0_MHL)||(fwPowerState == TX_POWER_STATE_D0_NO_MHL))&& 
-        mhl_cable_status) //NAGSM_Android_SEL_Kernel_Aakash_20101214
-      {
-
-          byte tmp;
-
-          tmp = I2C_ReadByte(SA_TX_Page0_Primary, (0x74));   // read status
-	        flag |= (tmp&INTR_4_DESIRED_MASK);	  
-          printk("#1 (0x74) flag: %x\n",(int) flag );
-
-          //I2C_WriteByte(SA_TX_Page0_Primary, (0x74), tmp);   // clear all interrupts
-
-          tmp = I2C_ReadByte(SA_TX_Page0_Primary, 0x71);
-          //I2C_WriteByte(SA_TX_Page0_Primary, 0x71, tmp);
-          flag |= (tmp&INTR_1_DESIRED_MASK);
-          printk("#1 (0x71) flag: %x\n",(int) flag );
-
-          if(mhlTxConfig.mhlConnected == MHL_TX_EVENT_DISCONNECTION)//(mhlTxConfig_status()== MHL_TX_EVENT_DISCONNECTION)//
-          {
-            tmp = ReadByteCBUS(0x08);
-            printk("#2 (ReadByteCBUS(0x08)) Temp: %x\n",(int) tmp );
-            WriteByteCBUS(0x08, tmp);  
-
-            tmp = ReadByteCBUS(0x1E);
-            printk("#2 (ReadByteCBUS(0x1E)) Temp: %x\n",(int) tmp );
-            WriteByteCBUS(0x1E, tmp);    
-
-          }
-          else
-          {
-			tmp = ReadByteCBUS(0x08);
-            flag |= (tmp&INTR_CBUS1_DESIRED_MASK);
-            printk("#1 (ReadByteCBUS(0x08)) Temp: %x\n",(int) flag );
-
-			tmp = ReadByteCBUS(0x1E);
-            flag |= (tmp&INTR_CBUS2_DESIRED_MASK);
-            printk("#1 (ReadByteCBUS(0x1E)) Temp: %x\n",(int) flag );              
-          }
-
-			if((flag == 0xFA)||(flag == 0xFF))
-
-				flag = 0;
-
-		}
-
-	}while(flag);
-
-	printk(KERN_ERR "[MHL]sii9234_interrupt_event :: flag: %x\n",(int) flag );
-}
-EXPORT_SYMBOL(sii9234_interrupt_event);
-
-
-/*===========================================================================
-  FUNCTION sii9234_unmaks_interrupt
-
-  DESCRIPTION
-  Unmask interrupt, we add this function to prevent interrupt before sii9234 power on
-
-  DEPENDENCIES
-  None
-
-  RETURN VALUE
-  None
-
-  SIDE EFFECTS
-  None
-  ===========================================================================*/
-void sii9234_unmaks_interrupt(void)
-{
-	UNMASK_INTR_4_INTERRUPTS;
-	UNMASK_INTR_1_INTERRUPTS;
-
-	return;
-}
-
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <plat/pm.h>
+#include <asm/irq.h>
+#include <linux/delay.h>
+#include <plat/gpio-cfg.h>
+#include <mach/regs-gpio.h>
+#include <mach/regs-clock.h>
+
+#include <linux/syscalls.h> 
+#include <linux/fcntl.h> 
+#include <asm/uaccess.h> 
+#include <plat/gpio-core.h>
+
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#include "SiI9234_Reg.h"
+#include "Common_Def.h"
+#include "SiI9234_I2C_master.h"
+#include "SiI9234_I2C_slave_add.h"
+#include "si_cbusDefs.h"
+#include "si_cbus_regs.h"
+#include "si_cbus.h"
+#include "si_apiCbus.h"
+
+/*===========================================================================
+  Definition
+  ===========================================================================*/
+#define TX_HW_RESET_PERIOD      200
+
+#define SiI_DEVICE_ID           0xB0
+
+#define DDC_XLTN_TIMEOUT_MAX_VAL		0x30
+
+#define INDEXED_PAGE_0		0x01
+#define INDEXED_PAGE_1		0x02
+#define INDEXED_PAGE_2		0x03
+
+#define ASR_VALUE 0x04
+
+
+
+#define	TX_POWER_STATE_D0_NO_MHL		TX_POWER_STATE_D2
+
+#define	TX_POWER_STATE_D0_MHL			TX_POWER_STATE_D0
+
+#define	TX_POWER_STATE_FIRST_INIT		0xFF
+
+#define MHL_INIT_POWER_OFF        0x00
+#define MHL_POWER_ON              0x01
+#define MHL_1K_IMPEDANCE_VERIFIED 0x02
+#define MHL_RSEN_VERIFIED         0x04
+#define MHL_TV_OFF_CABLE_CONNECT 0x08
+
+#define TX_DEBUG_PRINT(x) printk x
+
+
+#define	I2C_READ_MODIFY_WRITE(saddr,offset,mask)	I2C_WriteByte(saddr, offset, I2C_ReadByte(saddr, offset) | (mask));
+
+#define	SET_BIT(saddr,offset,bitnumber)		I2C_READ_MODIFY_WRITE(saddr,offset, (1<<bitnumber))
+#define	CLR_BIT(saddr,offset,bitnumber)		I2C_WriteByte(saddr, offset, I2C_ReadByte(saddr, offset) & ~(1<<bitnumber))
+//
+// 90[0] = Enable / Disable MHL Discovery on MHL link
+//
+#define	DISABLE_DISCOVERY				CLR_BIT(SA_TX_Page0_Primary, 0x90, 0);
+#define	ENABLE_DISCOVERY				SET_BIT(SA_TX_Page0_Primary, 0x90, 0);
+//
+//	Look for interrupts on INTR_4 (Register 0x74)
+//		7 = PVT_HTBT(reserved)
+//		6 = RGND RDY		(interested)
+//		5 = VBUS low(interested)	
+//		4 = CBUS LKOUT		(reserved)
+//		3 = USB EST		(reserved)
+//		2 = MHL EST		(reserved)
+//		1 = RPWR5V CHANGE		(reserved)
+//		0 = SCDT CHANGE		(reserved)
+#define	INTR_4_DESIRED_MASK				( BIT_2 | BIT_3 | BIT_4 | BIT_6) 
+#define	UNMASK_INTR_4_INTERRUPTS		I2C_WriteByte(SA_TX_Page0_Primary, 0x78, 0x00) 
+#define	MASK_INTR_4_INTERRUPTS	I2C_WriteByte(SA_TX_Page0_Primary, 0x78, INTR_4_DESIRED_MASK)		
+
+//	Look for interrupts on INTR_1 (Register 0x71)
+//		7 = RSVD		(reserved)
+//		6 = MDI_HPD		(interested)
+//		5 = RSEN CHANGED(interested)
+//		4 = RSVD		(reserved)
+//		3 = RSVD		(reserved)
+//		2 = RSVD		(reserved)
+//		1 = RSVD		(reserved)
+//		0 = RSVD		(reserved)
+
+#define	INTR_1_DESIRED_MASK				(BIT_5|BIT_6) 
+#define	UNMASK_INTR_1_INTERRUPTS		I2C_WriteByte(SA_TX_Page0_Primary, 0x75, 0x00)
+#define	MASK_INTR_1_INTERRUPTS			I2C_WriteByte(SA_TX_Page0_Primary, 0x75, INTR_1_DESIRED_MASK)
+
+//	Look for interrupts on CBUS:CBUS_INTR_STATUS [0xC8:0x08]
+//		7 = RSVD			(reserved)
+//		6 = MSC_RESP_ABORT	(interested)
+//		5 = MSC_REQ_ABORT	(interested)	
+//		4 = MSC_REQ_DONE	(interested)
+//		3 = MSC_MSG_RCVD	(interested)
+//		2 = DDC_ABORT		(interested)
+//		1 = RSVD			(reserved)
+//		0 = rsvd			(reserved)
+#define	INTR_CBUS1_DESIRED_MASK			(BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6)
+#define	UNMASK_CBUS1_INTERRUPTS		I2C_WriteByte(SA_TX_CBUS_Primary, 0x09, 0x00)	
+#define	MASK_CBUS1_INTERRUPTS			I2C_WriteByte(SA_TX_CBUS_Primary, 0x09, INTR_CBUS1_DESIRED_MASK)
+
+#define	INTR_CBUS2_DESIRED_MASK			(BIT_2 | BIT_3)
+#define	UNMASK_CBUS2_INTERRUPTS		 I2C_WriteByte(SA_TX_CBUS_Primary, 0x1F, 0x00)	
+#define	MASK_CBUS2_INTERRUPTS			 I2C_WriteByte(SA_TX_CBUS_Primary, 0x1F, INTR_CBUS2_DESIRED_MASK)
+
+
+#define		MHL_TX_EVENT_NONE			0x00	/* No event worth reporting.  */
+#define		MHL_TX_EVENT_DISCONNECTION	0x01	/* MHL connection has been lost */
+#define		MHL_TX_EVENT_CONNECTION		0x02	/* MHL connection has been established */
+#define		MHL_TX_EVENT_RCP_READY		0x03	/* MHL connection is ready for RCP */
+//
+#define		MHL_TX_EVENT_RCP_RECEIVED	0x04	/* Received an RCP. Key Code in "eventParameter" */
+#define		MHL_TX_EVENT_RCPK_RECEIVED	0x05	/* Received an RCPK message */
+#define		MHL_TX_EVENT_RCPE_RECEIVED	0x06	/* Received an RCPE message .*/
+
+/* To use hrtimer*/
+#define	MS_TO_NS(x)	(x * 1000000)
+
+DECLARE_WAIT_QUEUE_HEAD(wake_wq);
+
+static struct hrtimer hr_wake_timer;
+
+static bool wakeup_time_expired;
+
+static bool hrtimer_initialized;
+static bool first_timer;
+
+enum hrtimer_restart hrtimer_wakeup_callback(struct hrtimer *timer)
+{
+	wake_up(&wake_wq);
+	wakeup_time_expired = true;
+//	hrtimer_cancel(&hr_wake_timer);
+	return HRTIMER_NORESTART;
+}
+
+
+void start_hrtimer_ms(unsigned long delay_in_ms)
+{
+	ktime_t ktime;
+	ktime = ktime_set(0, MS_TO_NS(delay_in_ms));
+
+	wakeup_time_expired = false;
+//	hrtimer_init(&hr_wake_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	if (first_timer)
+		first_timer = false;
+	else
+		hrtimer_cancel(&hr_wake_timer);
+
+//	hr_wake_timer.function = &hrtimer_wakeup_callback;
+	hrtimer_start(&hr_wake_timer, ktime, HRTIMER_MODE_REL);
+}
+
+//wait_queue_head_t wake_wq;
+
+
+
+/*===========================================================================
+
+  ===========================================================================*/
+
+//
+// To remember the current power state.
+//
+byte	fwPowerState = TX_POWER_STATE_FIRST_INIT;
+
+//
+// When MHL Fifo underrun or overrun happens, we set this flag
+// to avoid calling a function in recursive manner. The monitoring loop
+// would look at this flag and call appropriate function and clear this flag.
+//
+//static	bool	gotFifoUnderRunOverRun = FALSE;
+
+//
+// This flag is set to TRUE as soon as a INT1 RSEN CHANGE interrupt arrives and
+// a deglitch timer is started.
+//
+// We will not get any further interrupt so the RSEN LOW status needs to be polled
+// until this timer expires.
+//
+/* static	bool	deglitchingRsenNow = FALSE; */
+
+//
+// To serialize the RCP commands posted to the CBUS engine, this flag
+// is maintained by the function SiiMhlTxDrvSendCbusCommand()
+//
+static	bool		mscCmdInProgress;	// FALSE when it is okay to send a new command
+//
+// Preserve Downstream HPD status
+//
+static	byte	dsHpdStatus = 0;
+
+
+
+byte mhl_cable_status =MHL_INIT_POWER_OFF;			//NAGSM_Android_SEL_Kernel_Aakash_20101214
+
+#define	MHL_MAX_RCP_KEY_CODE	(0x7F + 1)	// inclusive
+byte		rcpSupportTable [MHL_MAX_RCP_KEY_CODE] = {
+	(MHL_DEV_LD_GUI),		// 0x00 = Select
+	(MHL_DEV_LD_GUI),		// 0x01 = Up
+	(MHL_DEV_LD_GUI),		// 0x02 = Down
+	(MHL_DEV_LD_GUI),		// 0x03 = Left
+	(MHL_DEV_LD_GUI),		// 0x04 = Right
+	0, 0, 0, 0,				// 05-08 Reserved
+	(MHL_DEV_LD_GUI),		// 0x09 = Root Menu
+	0, 0, 0,				// 0A-0C Reserved
+	(MHL_DEV_LD_GUI),		// 0x0D = Select
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	// 0E-1F Reserved
+	0,//(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),	// Numeric keys 0x20-0x29
+	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
+	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
+	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
+	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
+	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
+	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
+	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
+	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
+	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),
+	0,						// 0x2A = Dot
+	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),	// Enter key = 0x2B
+	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_TUNER),	// Clear key = 0x2C
+	0, 0, 0,				// 2D-2F Reserved
+	0,//	(MHL_DEV_LD_TUNER),		// 0x30 = Channel Up
+	0,//	(MHL_DEV_LD_TUNER),		// 0x31 = Channel Dn
+	0,//	(MHL_DEV_LD_TUNER),		// 0x32 = Previous Channel
+	0,//	(MHL_DEV_LD_AUDIO),		// 0x33 = Sound Select
+	0,						// 0x34 = Input Select
+	0,						// 0x35 = Show Information
+	0,						// 0x36 = Help
+	0,						// 0x37 = Page Up
+	0,						// 0x38 = Page Down
+	0, 0, 0, 0, 0, 0, 0,	// 0x39-0x3F Reserved
+	0,						// 0x40 = Undefined
+
+	0,//	(MHL_DEV_LD_SPEAKER),	// 0x41 = Volume Up
+	0,//	(MHL_DEV_LD_SPEAKER),	// 0x42 = Volume Down
+	0,//	(MHL_DEV_LD_SPEAKER),	// 0x43 = Mute
+	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),	// 0x44 = Play
+	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_RECORD),	// 0x45 = Stop
+	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_RECORD),	// 0x46 = Pause
+	0,//	(MHL_DEV_LD_RECORD),	// 0x47 = Record
+	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),	// 0x48 = Rewind
+	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),	// 0x49 = Fast Forward
+	0,//	(MHL_DEV_LD_MEDIA),		// 0x4A = Eject
+	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA),	// 0x4B = Forward
+	0,//	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_MEDIA),	// 0x4C = Backward
+	0, 0, 0,				// 4D-4F Reserved
+	0,						// 0x50 = Angle
+	0,						// 0x51 = Subpicture
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 52-5F Reserved
+	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),	// 0x60 = Play Function
+	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),	// 0x61 = Pause the Play Function
+	0,//	(MHL_DEV_LD_RECORD),	// 0x62 = Record Function
+	0,//	(MHL_DEV_LD_RECORD),	// 0x63 = Pause the Record Function
+	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_RECORD),	// 0x64 = Stop Function
+
+	0,//	(MHL_DEV_LD_SPEAKER),	// 0x65 = Mute Function
+	0,//	(MHL_DEV_LD_SPEAKER),	// 0x66 = Restore Mute Function
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	// Undefined or reserved
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 		// Undefined or reserved
+};
+
+/*===========================================================================
+  FUNCTION DEFINITIONS
+  ===========================================================================*/
+static	void	Int4Isr(void);
+static	void	Int1RsenIsr(void);
+static	void	MhlCbusIsr(void);
+/* static	void 	DeglitchRsenLow(void); */
+
+void	CbusReset(void);
+void	SwitchToD0(void);
+void	SwitchToD3(void);
+void	WriteInitialRegisterValues(void);
+static	void	InitCBusRegs(void);
+static	void	ForceUsbIdSwitchOpen(void);
+static	void	ReleaseUsbIdSwitchOpen(void);
+void	MhlTxDrvProcessConnection(void);
+void	MhlTxDrvProcessDisconnection(void);
+static	void	ApplyDdcAbortSafety(void);
+
+
+//
+// Store global config info here. This is shared by the driver.
+//
+//
+//
+// structure to hold operating information of MhlTx component
+//
+static	mhlTx_config_t	mhlTxConfig;
+//
+// Functions used internally.
+//
+static	bool 		SiiMhlTxRapkSend( void );
+static	void		MhlTxDriveStates( void );
+static	void		MhlTxResetStates( void );
+static	bool		MhlTxSendMscMsg ( byte command, byte cmdData );
+void	SiiMhlTxNotifyConnection( bool mhlConnected );
+void	AppVbusControl( bool powerOn );
+void	AppRcpDemo( byte event, byte eventParameter);
+void	SiiMhlTxNotifyDsHpdChange( byte dsHpdStatus );
+bool SiiMhlTxReadDevcap( byte offset );
+bool SiiMhlTxRcpkSend( byte );
+
+void	SiiMhlTxGotMhlStatus( byte status_0, byte status_1 );
+void	SiiMhlTxGotMhlIntr( byte intr_0, byte intr_1 );
+void	SiiMhlTxGotMhlMscMsg( byte subCommand, byte cmdData );
+void	SiiMhlTxMscCommandDone( byte data1 );
+void SiiMhlTxGetEvents( byte *event, byte *eventParameter );
+//void SiiMhlTxInitialize( void );
+
+bool SiiMhlTxRcpeSend( byte rcpeErrorCode );
+
+void DelayMS(word msec);
+
+void sii9234_hw_reset(void);
+void sii_mhl_tx_init( void );
+
+
+
+Bool sii9234_init(void);
+void sii9234_interrupt_event(void);
+
+void	ProcessRgnd( void );
+/* jinho96.kim 2011.01.06 */
+extern void rcp_cbus_uevent(u8);		//Subhransu
+
+
+
+/*======================================================================*/
+
+
+/*===========================================================================
+  FUNCTION DelayMS
+
+  DESCRIPTION
+
+
+  DEPENDENCIES
+  None
+
+  RETURN VALUE
+  None
+
+  SIDE EFFECTS
+  None
+  ===========================================================================*/
+void DelayMS(word msec)
+{
+	msleep(msec);
+}
+
+
+/*===========================================================================
+  FUNCTION sii9234_hw_reset
+
+  DESCRIPTION
+  SiI9024A HW reset
+
+  DEPENDENCIES
+  None
+
+  RETURN VALUE
+  None
+
+  SIDE EFFECTS
+  None
+  ===========================================================================*/
+void sii9234_hw_reset(void)
+{
+	printk(KERN_ERR ">>TxHW_Reset()\n");
+
+	s3c_gpio_setpull(GPIO_MHL_RST, S3C_GPIO_PULL_NONE);
+	gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_LOW);
+	//PinTxHwReset = LOW;
+	DelayMS(TX_HW_RESET_PERIOD);
+	gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_HIGH);
+	printk(KERN_ERR ">>TxHW_Reset() done\n");
+}
+
+/*===========================================================================
+  FUNCTION SiI9234_startTPI
+
+  DESCRIPTION
+  Change the TPI mode (SW->H/W TPI mode)
+
+  DEPENDENCIES
+  None
+
+  RETURN VALUE
+  None
+
+  SIDE EFFECTS
+  None
+  ===========================================================================*/
+Bool SiI9234_startTPI(void)
+{
+	byte devID = 0x00;
+
+	printk(KERN_ERR ">>StartTPI()\n");
+
+	WriteByteTPI(TPI_ENABLE, 0x00);            // Write "0" to 72:C7 to start HW TPI mode
+	DelayMS(10);
+
+	devID = ReadByteTPI(TPI_DEVICE_ID);
+
+	if (devID == SiI_DEVICE_ID) 
+	{
+		printk(KERN_ERR "######## Subhransu: Silicon Device Id: %x\n", devID);
+		return TRUE;
+	}
+
+	printk(KERN_ERR "Unsupported TX\n");
+	return FALSE;
+}
+
+
+/*===========================================================================
+  FUNCTION sii9234_init
+
+  DESCRIPTION
+  SiI9234 initialization function.
+
+  DEPENDENCIES
+  None
+
+  RETURN VALUE
+  None
+
+  SIDE EFFECTS
+  None
+  ===========================================================================*/
+Bool sii9234_init(void)
+{
+	printk(KERN_ERR "# SiI9234 initialization start~ \n"); 
+
+	//sii9234_hw_reset();
+
+	sii_mhl_tx_init();
+
+	return TRUE;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// SiiMhlTxChipInitialize
+//
+// Chip specific initialization.
+// This function is for SiI 9244 Initialization: HW Reset, Interrupt enable.
+//
+//
+//////////////////////////////////////////////////////////////////////////////
+
+bool SiiMhlTxChipInitialize ( void )
+{
+	TX_DEBUG_PRINT( ("Drv: SiiMhlTxChipInitialize: %02X44\n", (int)I2C_ReadByte(SA_TX_Page0_Primary, 0x03)) );
+
+	// setup device registers. Ensure RGND interrupt would happen.
+	WriteInitialRegisterValues();
+
+	// Setup interrupt masks for all those we are interested.
+	MASK_INTR_4_INTERRUPTS;
+	MASK_INTR_1_INTERRUPTS;
+	//MASK_CBUS1_INTERRUPTS; 
+	//MASK_CBUS2_INTERRUPTS;
+
+	SwitchToD3();
+
+	return TRUE;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// SiiMhlTxDeviceIsr
+//
+// This function must be called from a master interrupt handler or any polling
+// loop in the host software if during initialization call the parameter
+// interruptDriven was set to TRUE. SiiMhlTxGetEvents will not look at these
+// events assuming firmware is operating in interrupt driven mode. MhlTx component
+// performs a check of all its internal status registers to see if a hardware event
+// such as connection or disconnection has happened or an RCP message has been
+// received from the connected device. Due to the interruptDriven being TRUE,
+// MhlTx code will ensure concurrency by asking the host software and hardware to
+// disable interrupts and restore when completed. Device interrupts are cleared by
+// the MhlTx component before returning back to the caller. Any handling of
+// programmable interrupt controller logic if present in the host will have to
+// be done by the caller after this function returns back.
+
+// This function has no parameters and returns nothing.
+//
+// This is the master interrupt handler for 9244. It calls sub handlers
+// of interest. Still couple of status would be required to be picked up
+// in the monitoring routine (Sii9244TimerIsr)
+//
+// To react in least amount of time hook up this ISR to processor's
+// interrupt mechanism.
+//
+// Just in case environment does not provide this, set a flag so we
+// call this from our monitor (Sii9244TimerIsr) in periodic fashion.
+//
+// Device Interrupts we would look at
+//		RGND		= to wake up from D3
+//		MHL_EST 	= connection establishment
+//		CBUS_LOCKOUT= Service USB switch
+//		RSEN_LOW	= Disconnection deglitcher
+//		CBUS 		= responder to peer messages
+//					  Especially for DCAP etc time based events
+//
+void 	SiiMhlTxDeviceIsr( void )
+{
+	byte tmp;		//NAGSM_Android_SEL_Kernel_Aakash_20101214
+	if( TX_POWER_STATE_D0_MHL != fwPowerState )
+	{  
+		//
+		// Check important RGND, MHL_EST, CBUS_LOCKOUT and SCDT interrupts
+		// During D3 we only get RGND but same ISR can work for both states
+		//
+		Int4Isr();
+
+		if(mhl_cable_status == MHL_TV_OFF_CABLE_CONNECT)
+		{
+			return ;
+		}
+                //NAGSM_Android_SEL_Kernel_Aakash_20101214
+
+		tmp = ReadByteCBUS(0x08);
+		WriteByteCBUS(0x08, tmp);
+		tmp = ReadByteCBUS(0x1E);
+		WriteByteCBUS(0x1E, tmp);    
+
+                //NAGSM_Android_SEL_Kernel_Aakash_20101214
+
+	}
+	else if( TX_POWER_STATE_D0_MHL == fwPowerState ) //NAGSM_Android_SEL_Kernel_Aakash_20101214
+	{
+
+		//
+		// Check for any peer messages for DCAP_CHG etc
+		// Dispatch to have the CBUS module working only once connected.
+		//
+		MhlCbusIsr();
+	}
+
+	Int1RsenIsr();
+
+}
+///////////////////////////////////////////////////////////////////////////////
+//
+// SiiMhlTxDriverTmdsControl
+//
+// Control the TMDS output. MhlTx uses this to support RAP content on and off.
+//
+void	SiiMhlTxDrvTmdsControl( bool enable )
+{
+	if( enable )
+	{
+		SET_BIT(SA_TX_Page0_Primary, 0x80, 4);
+		TX_DEBUG_PRINT(("Drv: TMDS Output Enabled\n"));
+	}
+	else
+	{
+		CLR_BIT(SA_TX_Page0_Primary, 0x80, 4);
+		TX_DEBUG_PRINT(("Drv: TMDS Ouput Disabled\n"));
+	}
+}
+///////////////////////////////////////////////////////////////////////////////
+//
+// SiiMhlTxDrvNotifyEdidChange
+//
+// MhlTx may need to inform upstream device of a EDID change. This can be
+// achieved by toggling the HDMI HPD signal or by simply calling EDID read
+// function.
+//
+void	SiiMhlTxDrvNotifyEdidChange ( void )
+{
+	TX_DEBUG_PRINT(("Drv: SiiMhlTxDrvNotifyEdidChange\n"));
+	//
+	// Prepare to toggle HPD to upstream
+	//
+	// set reg_hpd_out_ovr_en to first control the hpd
+	SET_BIT(SA_TX_Page0_Primary, 0x79, 4);
+
+	// reg_hpd_out_ovr_val = LOW to force the HPD low
+	CLR_BIT(SA_TX_Page0_Primary, 0x79, 5);
+
+	// wait a bit
+	DelayMS(110);
+
+	// release HPD back to high by reg_hpd_out_ovr_val = HIGH
+	SET_BIT(SA_TX_Page0_Primary, 0x79, 5);
+
+}
+//------------------------------------------------------------------------------
+// Function:    SiiMhlTxDrvSendCbusCommand
+//
+// Write the specified Sideband Channel command to the CBUS.
+// Command can be a MSC_MSG command (RCP/RAP/RCPK/RCPE/RAPK), or another command 
+// such as READ_DEVCAP, SET_INT, WRITE_STAT, etc.
+//
+// Parameters:  
+//              pReq    - Pointer to a cbus_req_t structure containing the 
+//                        command to write
+// Returns:     TRUE    - successful write
+//              FALSE   - write failed
+//------------------------------------------------------------------------------
+
+bool SiiMhlTxDrvSendCbusCommand ( cbus_req_t *pReq  )
+{
+	bool  success = TRUE;
+
+	byte i, startbit;
+
+	//
+	// If not connected, return with error
+	//
+	//if( (TX_POWER_STATE_D0_MHL != fwPowerState ) || (0 == ReadByteCBUS(0x0a) || mscCmdInProgress))
+  if( (TX_POWER_STATE_D0_MHL != fwPowerState ) || (mscCmdInProgress))
+	{
+	    TX_DEBUG_PRINT(("Error: Drv: fwPowerState: %02X, CBUS[0x0A]: %02X or mscCmdInProgress = %d\n",
+
+				(int) fwPowerState,
+
+					(int) ReadByteCBUS(0x0a),
+					(int) mscCmdInProgress));
+
+		return FALSE;
+	}
+	// Now we are getting busy
+	mscCmdInProgress	= TRUE;
+
+	TX_DEBUG_PRINT(("Drv: Sending MSC command %02X, %02X, %02X, %02X\n",
+				(int)pReq->command,
+				(int)(pReq->offsetData),
+				(int)pReq->msgData[0],
+				(int)pReq->msgData[1]));
+
+	/****************************************************************************************/
+	/* Setup for the command - write appropriate registers and determine the correct        */
+	/*                         start bit.                                                   */
+	/****************************************************************************************/
+
+	// Set the offset and outgoing data byte right away
+	WriteByteCBUS( 0x13, pReq->offsetData); 	// set offset
+	WriteByteCBUS( 0x14, pReq->msgData[0] );
+
+	startbit = 0x00;
+	switch ( pReq->command )
+	{
+		case MHL_SET_INT:	// Set one interrupt register = 0x60
+			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->offsetData + 0x20 ); 	// set offset
+			startbit = MSC_START_BIT_WRITE_REG;
+			break;
+
+		case MHL_WRITE_STAT:	// Write one status register = 0x60 | 0x80
+			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->offsetData + 0x30 ); 	// set offset
+			startbit = MSC_START_BIT_WRITE_REG;
+			break;
+
+		case MHL_READ_DEVCAP:	// Read one device capability register = 0x61
+			startbit = MSC_START_BIT_READ_REG;
+			break;
+
+		case MHL_GET_STATE:			// 0x62 -
+		case MHL_GET_VENDOR_ID:		// 0x63 - for vendor id	
+		case MHL_SET_HPD:			// 0x64	- Set Hot Plug Detect in follower
+		case MHL_CLR_HPD:			// 0x65	- Clear Hot Plug Detect in follower
+		case MHL_GET_SC1_ERRORCODE:		// 0x69	- Get channel 1 command error code
+		//case MHL_GET_DDC_ERRORCODE:		// 0x6A	- Get DDC channel command error code.
+		case MHL_GET_MSC_ERRORCODE:		// 0x6B	- Get MSC command error code.
+		case MHL_GET_SC3_ERRORCODE:		// 0x6D	- Get channel 3 command error code.
+			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->command );
+			startbit = MSC_START_BIT_MSC_CMD;
+			break;
+    		case MHL_GET_DDC_ERRORCODE:		// 0x6A	- Get DDC channel command error code.
+			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), 0x00 );
+            		startbit = MSC_START_BIT_MSC_CMD;
+            break;
+
+		case MHL_MSC_MSG:
+			WriteByteCBUS( (REG_CBUS_PRI_WR_DATA_2ND & 0xFF), pReq->msgData[1] );
+			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->command );
+			startbit = MSC_START_BIT_VS_CMD;
+			break;
+
+		case MHL_WRITE_BURST:
+			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->offsetData + 0x40 );
+			WriteByteCBUS( (REG_MSC_WRITE_BURST_LEN & 0xFF), pReq->length -1 );
+
+			// Now copy all bytes from array to local scratchpad
+			for ( i = 0; i < pReq->length; i++ )
+			{
+				WriteByteCBUS( (REG_CBUS_SCRATCHPAD_0 & 0xFF) + i, pReq->msgData[i] );
+			}
+			startbit = MSC_START_BIT_WRITE_BURST;
+			break;
+
+		default:
+			success = FALSE;
+			break;
+	}
+
+	/****************************************************************************************/
+	/* Trigger the CBUS command transfer using the determined start bit.                    */
+	/****************************************************************************************/
+
+	if ( success )
+	{
+		WriteByteCBUS( REG_CBUS_PRI_START & 0xFF, startbit );
+	}
+
+	return( success );
+}
+////////////////////////////////////////////////////////////////////
+//
+// L O C A L    F U N C T I O N S
+//
+////////////////////////////////////////////////////////////////////
+// Int1RsenIsr
+//
+// This interrupt is used only to decide if the MHL is disconnected
+// The disconnection is determined by looking at RSEN LOW and applying
+// all MHL compliant disconnect timings and deglitch logic.
+//
+//	Look for interrupts on INTR_1 (Register 0x71)
+//		7 = RSVD		(reserved)
+//		6 = MDI_HPD		(interested)
+//		5 = RSEN CHANGED(interested)	
+//		4 = RSVD		(reserved)
+//		3 = RSVD		(reserved)
+//		2 = RSVD		(reserved)
+//		1 = RSVD		(reserved)
+//		0 = RSVD		(reserved)
+////////////////////////////////////////////////////////////////////
+void	Int1RsenIsr( void )
+{
+	byte		reg71 = I2C_ReadByte(SA_TX_Page0_Primary, 0x71);
+	byte		rsen  = I2C_ReadByte(SA_TX_Page0_Primary, 0x09) & BIT_2;
+
+	// Look at RSEN interrupt
+	if(reg71 & BIT_5)
+	{
+		TX_DEBUG_PRINT (("Drv: Got INTR_1: reg71 = %02X, rsen = %02X\n", (int) reg71, (int) rsen));
+		//pinCBusToggle = 1;	// for debug measurements. RSEN intr
+		//
+		// RSEN becomes LOW in SYS_STAT register 0x72:0x09[2]
+		// SYS_STAT	==> bit 7 = VLOW, 6:4 = MSEL, 3 = TSEL, 2 = RSEN, 1 = HPD, 0 = TCLK STABLE
+		//
+		// Start countdown timer for deglitch
+		// Allow RSEN to stay low this much before reacting
+		//
+		if(rsen == 0x00)
+		{
+	      		if(TX_POWER_STATE_D0_MHL != fwPowerState)
+	      		{
+				TX_DEBUG_PRINT (("Drv: Got1 INTR_1: reg71 = %02X, rsen = %02X\n", (int) reg71, (int) rsen));
+				I2C_WriteByte(SA_TX_Page0_Primary, 0x71, reg71);
+				return ;
+	      		}
+			if(mhl_cable_status & MHL_1K_IMPEDANCE_VERIFIED)
+#if 1
+      			{
+        			TX_DEBUG_PRINT((KERN_ERR "RSEN Low and 1K impedance\n"));
+				DelayMS(120);
+
+         			if((I2C_ReadByte(SA_TX_Page0_Primary, 0x09) & BIT_2) == 0x00)
+         			{
+
+			           TX_DEBUG_PRINT((KERN_ERR "Really RSEN Low\n"));
+					//mhl_cable_status =MHL_INIT_POWER_OFF;
+          
+
+					mhl_cable_status = MHL_TV_OFF_CABLE_CONNECT;
+#if defined(CONFIG_S5PC110_DEMPSEY_BOARD)
+	FSA9480_MhlSwitchSel(0);
+#endif
+					MHL_On(0);
+         			}
+        		 	else
+        			{
+         				TX_DEBUG_PRINT((KERN_ERR "RSEN Stable\n"));
+        			}
+
+      			}
+#else
+			{
+			mhl_cable_status =MHL_TV_OFF_CABLE_CONNECT;
+			printk(KERN_ERR "MHL Connection Fail Power off ###\n");
+			SiI9234_HW_Reset();
+			For_check_resen_int();
+			fwPowerState = TX_POWER_STATE_D3;
+
+
+			return ;
+		      	}
+#endif
+      			else
+	      		{
+				printk(KERN_ERR "%s: MHL Cable disconnect### 2\n", __func__);
+				mhl_cable_status =MHL_INIT_POWER_OFF;
+				MHL_On(0);
+			}
+
+			return ;
+
+			//NAGSM_Android_SEL_Kernel_Aakash_20101214
+
+		}
+
+		else if(rsen == 0x04)
+		{
+  			mhl_cable_status |= MHL_RSEN_VERIFIED;
+			printk("MHL Cable Connection ###\n");
+		}
+		// Clear MDI_RSEN interrupt
+
+	}
+
+	if(reg71 & BIT_6)
+	{
+		byte cbusInt;
+		//HPD
+		printk(KERN_ERR "HPD \n");
+		//
+		// Check if a SET_HPD came from the downstream device.
+		//
+		cbusInt = ReadByteCBUS(0x0D);
+
+		// CBUS_HPD status bit
+		if((BIT_6 & cbusInt) != dsHpdStatus)
+		{
+			// Inform upper layer of change in Downstream HPD
+			SiiMhlTxNotifyDsHpdChange( cbusInt );
+			TX_DEBUG_PRINT(("Drv: Downstream HPD changed to: %02X\n", (int) cbusInt));
+
+			// Remember
+			dsHpdStatus = (BIT_6 & cbusInt);
+		}
+
+	}
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x71, reg71);
+
+}
+//////////////////////////////////////////////////////////////////////////////
+//
+// DeglitchRsenLow
+//
+// This function looks at the RSEN signal if it is low.
+//
+// The disconnection will be performed only if we were in fully MHL connected
+// state for more than 400ms AND a 150ms deglitch from last interrupt on RSEN
+// has expired.
+//
+// If MHL connection was never established but RSEN was low, we unconditionally
+// and instantly process disconnection.
+//
+/*
+static void DeglitchRsenLow(void)
+{
+	TX_DEBUG_PRINT(("Drv: DeglitchRsenLow RSEN <72:09[2]> = %02X\n", (int) (I2C_ReadByte(SA_TX_Page0_Primary, 0x09)) ));
+	if((I2C_ReadByte(SA_TX_Page0_Primary, 0x09) & BIT_2) == 0x00)
+
+	if((I2C_ReadByte(PAGE_0_0X72, 0x09) & BIT_2) == 0x00)
+	{
+		TX_DEBUG_PRINT(("Drv: RSEN is Low.\n"));
+		//
+		// If no MHL cable is connected or RSEN deglitch timer has started,
+		// we may not receive interrupts for RSEN.
+		// Monitor the status of RSEN here.
+		//
+		// 
+		// First check means we have not received any interrupts and just started
+		// but RSEN is low. Case of "nothing" connected on MHL receptacle
+		//
+		if(TX_POWER_STATE_D0_MHL == fwPowerState)
+    //if((TX_POWER_STATE_D0_MHL == fwPowerState)    && HalTimerExpired(TIMER_TO_DO_RSEN_DEGLITCH) )      
+
+		{
+			// Second condition means we were fully operational, then a RSEN LOW interrupt
+			// occured and a DEGLITCH_TIMER per MHL specs started and completed.
+			// We can disconnect now.
+			//
+			TX_DEBUG_PRINT(("Drv: Disconnection due to RSEN Low\n"));
+
+			deglitchingRsenNow = FALSE;
+
+			//pinCBusToggle = 0;	// for debug measurements - disconnected due to RSEN
+
+			// FP1226: Toggle MHL discovery to level the voltage to deterministic vale.
+			DISABLE_DISCOVERY;
+			ENABLE_DISCOVERY;
+			//
+			// We got here coz cable was never connected
+			//
+			MhlTxDrvProcessDisconnection();
+		}
+	}
+	else
+	{
+		//
+		// Deglitch here:
+		// RSEN is not low anymore. Reset the flag.
+		// This flag will be now set on next interrupt.
+		//
+		// Stay connected
+		//
+		deglitchingRsenNow = FALSE;
+	}
+}
+*/
+///////////////////////////////////////////////////////////////////////////
+// WriteInitialRegisterValues
+//
+//
+///////////////////////////////////////////////////////////////////////////
+void WriteInitialRegisterValues ( void )
+{
+	TX_DEBUG_PRINT(("Drv: WriteInitialRegisterValues\n"));
+	// Power Up
+	I2C_WriteByte(SA_TX_Page1_Primary, 0x3D, 0x3F);	// Power up CVCC 1.2V core
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x11, 0x01);	// Enable TxPLL Clock
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x12, 0x15);	// Enable Tx Clock Path & Equalizer
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x08, 0x35);	// Power Up TMDS Tx Core
+
+	// Analog PLL Control
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x10, 0xC1);	// bits 5:4 = 2b00 as per characterization team.
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x17, 0x03);	// PLL Calrefsel
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x1A, 0x20);	// VCO Cal
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x22, 0x8A);	// Auto EQ
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x23, 0x6A);	// Auto EQ
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x24, 0xAA);	// Auto EQ
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x25, 0xCA);	// Auto EQ
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x26, 0xEA);	// Auto EQ
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x4C, 0xA0);	// Manual zone control
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x4D, 0x00);	// PLL Mode Value
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x80, 0x34);	// Enable Rx PLL Clock Value
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x45, 0x44);	// Rx PLL BW value from I2C
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x31, 0x0A);	// Rx PLL BW ~ 4MHz
+	I2C_WriteByte(SA_TX_Page0_Primary, 0xA0, 0xD0);
+	I2C_WriteByte(SA_TX_Page0_Primary, 0xA1, 0xFC);	// Disable internal MHL driver
+#ifdef CONFIG_TARGET_LOCALE_KOR
+//	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEE);
+	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEB); // changed by yoking.im
+#else
+	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEB);
+#endif
+	I2C_WriteByte(SA_TX_Page0_Primary, 0xA6, 0x0C);
+
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x2B, 0x01);	// Enable HDCP Compliance safety
+
+	//
+	// CBUS & Discovery
+	// CBUS discovery cycle time for each drive and float = 150us
+	//
+	ReadModifyWriteTPI(0x90, BIT_3 | BIT_2, BIT_3);
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x91, 0xA5);		// Clear bit 6 (reg_skip_rgnd)
+
+
+	// Changed from 66 to 65 for 94[1:0] = 01 = 5k reg_cbusmhl_pup_sel
+	//I2C_WriteByte(SA_TX_Page0_Primary, 0x94, 0x65);			// 1.8V CBUS VTH & GND threshold
+    I2C_WriteByte(SA_TX_Page0_Primary, 0x94, 0x75);			// 1.8V CBUS VTH & GND threshold
+
+	//set bit 2 and 3, which is Initiator Timeout
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x31, I2C_ReadByte(SA_TX_CBUS_Primary, 0x31) | 0x0c);
+
+	//I2C_WriteByte(SA_TX_Page0_Primary, 0xA5, 0xAC);			// RGND Hysterisis.
+    I2C_WriteByte(SA_TX_Page0_Primary, 0xA5, 0xA0);			
+	TX_DEBUG_PRINT(("Drv: MHL 1.0 Compliant Clock\n"));
+
+	// RGND & single discovery attempt (RGND blocking)
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x95, 0x31);
+
+	// use 1K and 2K setting
+	//I2C_WriteByte(SA_TX_Page0_Primary, 0x96, 0x22);
+	// Use VBUS path of discovery state machine
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x97, 0x00);
+
+	ReadModifyWriteTPI(0x95, BIT_6, BIT_6);		// Force USB ID switch to open
+
+	//
+	// For MHL compliance we need the following settings for register 93 and 94
+	// Bug 20686
+	//
+	// To allow RGND engine to operate correctly.
+	//
+	// When moving the chip from D2 to D0 (power up, init regs) the values should be
+	// 94[1:0] = 01  reg_cbusmhl_pup_sel[1:0] should be set for 5k
+	// 93[7:6] = 10  reg_cbusdisc_pup_sel[1:0] should be set for 10k (default)
+	// 93[5:4] = 00  reg_cbusidle_pup_sel[1:0] = open (default)
+	//
+
+	WriteByteTPI(0x92, 0x86);				//
+	// change from CC to 8C to match 5K
+	WriteByteTPI(0x93, 0x8C);				// Disable CBUS pull-up during RGND measurement
+
+	//NAGSM_Android_SEL_Kernel_Aakash_20101214
+ 	//ReadModifyWriteTPI(0x79, BIT_5 | BIT_4, BIT_4);	// Force upstream HPD to 0 when not in MHL mode.
+	ReadModifyWriteTPI(0x79, BIT_1 | BIT_2, 0); //Set interrupt active high
+
+	DelayMS(25);
+	ReadModifyWriteTPI(0x95, BIT_6, 0x00);		// Release USB ID switch
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x27);			// Enable CBUS discovery
+
+	//if (settingMode9290 != pin9290_938x) {
+	// Reset CBus to clear state
+	CbusReset();
+	//}
+
+	InitCBusRegs();
+
+	// Enable Auto soft reset on SCDT = 0
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x05, 0x04);
+
+	// HDMI Transcode mode enable
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x0D, 0x1C);
+
+ 	//I2C_WriteByte(SA_TX_Page0_Primary, 0x78, RGND_RDY_EN);
+}
+///////////////////////////////////////////////////////////////////////////
+//
+//
+///////////////////////////////////////////////////////////////////////////
+#define MHL_DEVICE_CATEGORY             0x02 //(MHL_DEV_CAT_SOURCE)
+#define	MHL_LOGICAL_DEVICE_MAP			(MHL_DEV_LD_AUDIO | MHL_DEV_LD_VIDEO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_GUI )
+
+static void InitCBusRegs( void )
+{
+	byte		regval;
+
+	TX_DEBUG_PRINT(("Drv: InitCBusRegs\n"));
+	// Increase DDC translation layer timer
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x07, 0x36);
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x40, 0x03); 			// CBUS Drive Strength
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x42, 0x06); 			// CBUS DDC interface ignore segment pointer
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x36, 0x0C);
+
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x3D, 0xFD);	
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x1C, 0x00);
+
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x44, 0x02);
+
+	// Setup our devcap
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x80, MHL_DEV_ACTIVE);
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x81, MHL_VERSION);
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x82, MHL_DEVICE_CATEGORY);
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x83, 0);  						
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x84, 0);						
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x85, (MHL_DEV_VID_LINK_SUPPRGB444|MHL_DEV_VID_LINK_SUPPYCBCR444));
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x86, MHL_DEV_AUD_LINK_2CH);
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x87, 0);										// not for source
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x88, MHL_LOGICAL_DEVICE_MAP);
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x89, 0x0F);										// not for source
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8A, MHL_FEATURE_RCP_SUPPORT | MHL_FEATURE_RAP_SUPPORT|MHL_FEATURE_SP_SUPPORT);
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8B, 0);
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8C, 0);										// reserved
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8D, MHL_SCRATCHPAD_SIZE);
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8E, 0x44 ); //MHL_INT_AND_STATUS_SIZE);
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8F, 0);										//reserved
+
+	// Make bits 2,3 (initiator timeout) to 1,1 for register CBUS_LINK_CONTROL_2
+	regval = I2C_ReadByte(SA_TX_CBUS_Primary, REG_CBUS_LINK_CONTROL_2 );
+	regval = (regval | 0x0C);
+	I2C_WriteByte(SA_TX_CBUS_Primary,REG_CBUS_LINK_CONTROL_2, regval);
+
+	// Clear legacy bit on Wolverine TX.
+    regval = I2C_ReadByte(SA_TX_CBUS_Primary, REG_MSC_TIMEOUT_LIMIT);
+    I2C_WriteByte(SA_TX_CBUS_Primary, REG_MSC_TIMEOUT_LIMIT, (regval & MSC_TIMEOUT_LIMIT_MSB_MASK));
+
+	// Set NMax to 1
+	I2C_WriteByte(SA_TX_CBUS_Primary, REG_CBUS_LINK_CONTROL_1, 0x01);
+
+}
+
+///////////////////////////////////////////////////////////////////////////
+//
+// ForceUsbIdSwitchOpen
+//
+///////////////////////////////////////////////////////////////////////////
+static void ForceUsbIdSwitchOpen ( void )
+{
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x26);		// Disable CBUS discovery
+	ReadModifyWriteTPI(0x95, BIT_6, BIT_6);	// Force USB ID switch to open
+	WriteByteTPI(0x92, 0x86);
+	// Force HPD to 0 when not in MHL mode.
+	ReadModifyWriteTPI(0x79, BIT_5 | BIT_4, BIT_4);
+
+}
+///////////////////////////////////////////////////////////////////////////
+//
+// ReleaseUsbIdSwitchOpen
+//
+///////////////////////////////////////////////////////////////////////////
+static void ReleaseUsbIdSwitchOpen ( void )
+{
+	DelayMS(50);
+
+	// Release USB ID switch
+	ReadModifyWriteTPI(0x95, BIT_6, 0x00);
+
+	ENABLE_DISCOVERY;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   CbusWakeUpPulseGenerator ()
+//
+// PURPOSE      :   Generate Cbus Wake up pulse sequence using GPIO or I2C method.
+//
+// INPUT PARAMS :   None
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   None
+//
+//////////////////////////////////////////////////////////////////////////////
+
+void CbusWakeUpPulseGenerator(void)
+{	
+	TX_DEBUG_PRINT(("Drv: CbusWakeUpPulseGenerator\n"));
+
+	if (!hrtimer_initialized) {
+		hrtimer_init(&hr_wake_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		hr_wake_timer.function = &hrtimer_wakeup_callback;
+		hrtimer_initialized = true;
+		first_timer = true;
+	}
+		
+	//
+	// I2C method
+	//
+	//I2C_WriteByte(SA_TX_Page0_Primary, 0x92, (I2C_ReadByte(SA_TX_Page0_Primary, 0x92) | 0x10));
+
+	// Start the pulse
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) | 0xC0));
+//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_1 );	// adjust for code path
+	start_hrtimer_ms(19);
+	wait_event_interruptible(wake_wq, wakeup_time_expired);
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) & 0x3F));
+//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_1 );	// adjust for code path
+	start_hrtimer_ms(19);
+	wait_event_interruptible(wake_wq, wakeup_time_expired);
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) | 0xC0));
+//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_1 );	// adjust for code path
+	start_hrtimer_ms(19);
+	wait_event_interruptible(wake_wq, wakeup_time_expired);
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) & 0x3F));
+//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_2 );	// adjust for code path
+	start_hrtimer_ms(60);
+	wait_event_interruptible(wake_wq, wakeup_time_expired);
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) | 0xC0));
+//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_1 );	// adjust for code path
+	start_hrtimer_ms(19);
+	wait_event_interruptible(wake_wq, wakeup_time_expired);
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) & 0x3F));
+//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_1 );	// adjust for code path
+	start_hrtimer_ms(19);
+	wait_event_interruptible(wake_wq, wakeup_time_expired);
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) | 0xC0));
+	//DelayMS(21);
+//	DelayMS(T_SRC_WAKE_PULSE_WIDTH_1 );	// adjust for code path
+	start_hrtimer_ms(19);
+	wait_event_interruptible(wake_wq, wakeup_time_expired);
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) & 0x3F));
+
+//	DelayMS(T_SRC_WAKE_TO_DISCOVER);
+	start_hrtimer_ms(T_SRC_WAKE_TO_DISCOVER);
+	wait_event_interruptible(wake_wq, wakeup_time_expired);
+
+	//
+	// Toggle MHL discovery bit
+	// 
+	//I2C_WriteByte(SA_TX_Page0_Primary, 0x92, (I2C_ReadByte(SA_TX_Page0_Primary, 0x92) & 0xEF));
+
+	//DISABLE_DISCOVERY;
+	//ENABLE_DISCOVERY;
+
+
+}
+///////////////////////////////////////////////////////////////////////////
+//
+// ApplyDdcAbortSafety
+//
+///////////////////////////////////////////////////////////////////////////
+static	void	ApplyDdcAbortSafety()
+{
+	byte		bTemp, bPost;
+
+	/*	TX_DEBUG_PRINT(("[%d] Drv: Do we need DDC Abort Safety\n",
+		(int) (HalTimerElapsed( ELAPSED_TIMER ) * MONITORING_PERIOD)));*/
+
+	WriteByteCBUS(0x29, 0xFF);
+	bTemp = ReadByteCBUS(0x29);
+	DelayMS(3);
+	bPost = ReadByteCBUS(0x29);
+
+	if ((bPost > (bTemp + 50)))
+	{
+		TX_DEBUG_PRINT(("Drv: Applying DDC Abort Safety(SWWA 18958)\n"));
+
+		SET_BIT(SA_TX_Page0_Primary, 0x05, 3);
+		CLR_BIT(SA_TX_Page0_Primary, 0x05, 3);
+
+		InitCBusRegs();
+
+		// Why do we do these?
+		ForceUsbIdSwitchOpen();
+		ReleaseUsbIdSwitchOpen();
+
+		MhlTxDrvProcessDisconnection();
+	}
+}
+///////////////////////////////////////////////////////////////////////////
+// ProcessRgnd
+//
+// H/W has detected impedance change and interrupted.
+// We look for appropriate impedance range to call it MHL and enable the
+// hardware MHL discovery logic. If not, disable MHL discovery to allow
+// USB to work appropriately.
+//
+// In current chip a firmware driven slow wake up pulses are sent to the
+// sink to wake that and setup ourselves for full D0 operation.
+///////////////////////////////////////////////////////////////////////////
+void	ProcessRgnd( void )
+{
+	byte		reg99RGNDRange;
+	//
+	// Impedance detection has completed - process interrupt
+	//
+	reg99RGNDRange = I2C_ReadByte(SA_TX_Page0_Primary, 0x99) & 0x03;
+	TX_DEBUG_PRINT(("Drv: RGND Reg 99 = %02X : ", (int)reg99RGNDRange));
+#if defined(CONFIG_S5PC110_DEMPSEY_BOARD)
+        DisableFSA9480Interrupts(); //Test
+#endif
+	//
+	// Reg 0x99
+	// 00 or 11 means USB.
+	// 10 means 1K impedance (MHL)
+	// 01 means 2K impedance (MHL)
+	//
+	if (reg99RGNDRange == 0x00 || reg99RGNDRange == 0x03)
+	{
+		TX_DEBUG_PRINT((" : USB impedance. Disable MHL discovery.\n", (int)reg99RGNDRange));
+
+		CLR_BIT(SA_TX_Page0_Primary, 0x95, 5);
+		mhl_cable_status =MHL_INIT_POWER_OFF;
+		MHL_On(0); 
+		
+#if defined(CONFIG_S5PC110_DEMPSEY_BOARD)
+		FSA9480_CheckAndHookAudioDock(); //Rajucm: Audio Dock Detection Algorithm
+#endif
+	}
+	else
+	{
+		mhl_cable_status |= MHL_1K_IMPEDANCE_VERIFIED;
+		if(0x01==reg99RGNDRange)
+		{
+			TX_DEBUG_PRINT(("MHL 2K\n"));
+      mhl_cable_status =MHL_TV_OFF_CABLE_CONNECT;
+      printk(KERN_ERR "MHL Connection Fail Power off ###\n");
+			MHL_On(0);
+	  
+      #if defined(CONFIG_S5PC110_DEMPSEY_BOARD)
+        FSA9480_MhlTvOff();//Rajucm: Mhl cable handling when TV Off 
+      #endif
+
+      return ;
+		}
+		else if(0x02==reg99RGNDRange)
+		{
+			TX_DEBUG_PRINT(("MHL 1K\n"));
+
+	DelayMS(T_SRC_VBUS_CBUS_TO_STABLE);
+
+	// Discovery enabled
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x25);
+
+	//
+	// Send slow wake up pulse using GPIO or I2C
+	//
+	CbusWakeUpPulseGenerator();
+}
+	}
+}
+
+////////////////////////////////////////////////////////////////////
+// SwitchToD0
+// This function performs s/w as well as h/w state transitions.
+//
+// Chip comes up in D2. Firmware must first bring it to full operation
+// mode in D0.
+////////////////////////////////////////////////////////////////////
+void	SwitchToD0( void )
+{
+	//
+	// WriteInitialRegisterValues switches the chip to full power mode.
+	//
+	WriteInitialRegisterValues();
+
+	// Setup interrupt masks for all those we are interested.
+#if 0
+	//UNMASK_INTR_4_INTERRUPTS;
+	UNMASK_INT4_INTERRUPTS;
+	//UNMASK_CBUS1_INTERRUPTS;
+	//UNMASK_CBUS2_INTERRUPTS;
+#else
+	//MASK_INTR_4_INTERRUPTS;
+	MASK_INTR_1_INTERRUPTS;
+	//MASK_CBUS1_INTERRUPTS;
+	//MASK_CBUS2_INTERRUPTS;
+#endif
+
+	// Force Power State to ON
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x25);
+
+	fwPowerState = TX_POWER_STATE_D0_NO_MHL;
+  	mhl_cable_status =MHL_POWER_ON;
+}
+////////////////////////////////////////////////////////////////////
+// SwitchToD3
+//
+// This function performs s/w as well as h/w state transitions.
+//
+////////////////////////////////////////////////////////////////////
+void	SwitchToD3( void )
+{
+	//
+	// To allow RGND engine to operate correctly.
+	// So when moving the chip from D0 MHL connected to D3 the values should be
+	// 94[1:0] = 00  reg_cbusmhl_pup_sel[1:0] should be set for open
+	// 93[7:6] = 00  reg_cbusdisc_pup_sel[1:0] should be set for open
+	// 93[5:4] = 00  reg_cbusidle_pup_sel[1:0] = open (default)
+	//
+	// Disable CBUS pull-up during RGND measurement
+	//I2C_WriteByte(SA_TX_Page0_Primary, 0x93, 0x04);
+
+    ReadModifyWriteTPI(0x93, BIT_7 | BIT_6 | BIT_5 | BIT_4, 0);
+
+		ReadModifyWriteTPI(0x94, BIT_1 | BIT_0, 0);
+
+
+	// 1.8V CBUS VTH & GND threshold
+	//I2C_WriteByte(SA_TX_Page0_Primary, 0x94, 0x64);
+
+        ReleaseUsbIdSwitchOpen();
+        printk(KERN_ERR "POWER_STATE_D3\n");
+
+	// Change TMDS termination to high impedance on disconnection
+	// Bits 1:0 set to 11
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x01, 0x03);
+	//
+
+	// Change state to D3 by clearing bit 0 of 3D (SW_TPI, Page 1) register
+	// ReadModifyWriteIndexedRegister(INDEXED_PAGE_1, 0x3D, BIT_0, 0x00);
+	//
+	CLR_BIT(SA_TX_Page1_Primary, 0x3D, 0);
+
+	fwPowerState = TX_POWER_STATE_D3;
+
+}
+
+/*===========================================================================
+  FUNCTION For_check_resen_int
+
+  DESCRIPTION
+  For_check_resen_int
+
+  DEPENDENCIES
+  None
+
+  RETURN VALUE
+  None
+
+  SIDE EFFECTS
+  None
+===========================================================================*/
+static void For_check_resen_int (void) 
+{
+
+	// Power Up
+	I2C_WriteByte(SA_TX_Page1_Primary, 0x3D, 0x3F);			// Power up CVCC 1.2V core
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x11, 0x01);			// Enable TxPLL Clock
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x12, 0x15);			// Enable Tx Clock Path & Equalizer
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x08, 0x35);			// Power Up TMDS Tx Core
+
+	// Analog PLL Control
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x17, 0x03);			// PLL Calrefsel
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x1A, 0x20);			// VCO Cal
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x22, 0x8A);			// Auto EQ
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x23, 0x6A);			// Auto EQ
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x24, 0xAA);			// Auto EQ
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x25, 0xCA);			// Auto EQ
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x26, 0xEA);			// Auto EQ
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x4C, 0xA0);			// Manual zone control
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x4D, 0x00);			// PLL Mode Value
+
+	//I2C_WriteByte(SA_TX_Page0_Primary, 0x80, 0x34);			// Enable Rx PLL Clock Value
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x80, 0x24);			// Enable Rx PLL Clock Value	
+
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x45, 0x44);			// Rx PLL BW value from I2C
+	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x31, 0x0A);			// Rx PLL BW ~ 4MHz
+	I2C_WriteByte(SA_TX_Page0_Primary, 0xA0, 0xD0);
+	I2C_WriteByte(SA_TX_Page0_Primary, 0xA1, 0xFC);			// Disable internal Mobile HD driver
+
+#ifdef CONFIG_TARGET_LOCALE_KOR
+//	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEE);
+//	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xED); // changed by yoking.im
+	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEB); // changed by yoking.im
+#else
+	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEB);
+#endif
+	I2C_WriteByte(SA_TX_Page0_Primary, 0xA6, 0x0C);
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x2B, 0x01);			// Enable HDCP Compliance workaround
+
+	// CBUS & Discovery
+	ReadModifyWriteTPI(0x90, BIT_3 | BIT_2, BIT_3);	// CBUS discovery cycle time for each drive and float = 150us
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x91, 0xA5);
+	
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x94, 0x66);			// 1.8V CBUS VTH & GND threshold
+
+	//set bit 2 and 3, which is Initiator Timeout
+	I2C_WriteByte(SA_TX_CBUS_Primary, 0x31, I2C_ReadByte(SA_TX_CBUS_Primary, 0x31) | 0x0c);
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0xA5, 0xAC);			// RGND Hysterisis.
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x95, 0x31);			// RGND & single discovery attempt (RGND blocking)
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, 0x22);			// use 1K and 2K setting
+//	I2C_WriteByte(SA_TX_Page0_Primary, 0x97, 0x03);			// Auto Heartbeat failure enable
+
+	ReadModifyWriteTPI(0x95, BIT_6, BIT_6);		// Force USB ID switch to open
+
+	WriteByteTPI(0x92, 0x86);				//
+	WriteByteTPI(0x93, 0xCC);				// Disable CBUS pull-up during RGND measurement
+
+	DelayMS(25);
+	ReadModifyWriteTPI(0x95, BIT_6, 0x00);		// Release USB ID switch
+
+  ReadModifyWriteTPI(0x79, BIT_1 | BIT_2, 0); //Set interrupt active high
+
+  I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x27);			// Enable CBUS discovery
+
+	// Reset CBus to clear HPD
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x05, 0x08);
+	DelayMS(2);
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x05, 0x00);
+
+  I2C_WriteByte(SA_TX_CBUS_Primary, 0x1F, 0x02); 			// Heartbeat Max Fail Enable
+  I2C_WriteByte(SA_TX_CBUS_Primary, 0x07, DDC_XLTN_TIMEOUT_MAX_VAL | 0x06); 			// Increase DDC translation layer timer
+  I2C_WriteByte(SA_TX_CBUS_Primary, 0x40, 0x03); 			// CBUS Drive Strength
+  I2C_WriteByte(SA_TX_CBUS_Primary, 0x42, 0x06); 			// CBUS DDC interface ignore segment pointer
+  I2C_WriteByte(SA_TX_CBUS_Primary, 0x36, 0x0C);
+
+  I2C_WriteByte(SA_TX_CBUS_Primary, 0x3D, 0xFD);	
+  I2C_WriteByte(SA_TX_CBUS_Primary, 0x1C, 0x00);
+
+  I2C_WriteByte(SA_TX_CBUS_Primary, 0x44, 0x02);
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x05, 0x04); 		// Enable Auto soft reset on SCDT = 0
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0x0D, 0x1C); 			// HDMI Transcode mode enable
+
+UNMASK_INTR_4_INTERRUPTS;
+
+//I2C_WriteByte(SA_TX_Page0_Primary, 0x78, BIT_6) 
+  SiI9234_startTPI();
+WriteByteTPI(TPI_INTERRUPT_ENABLE_REG, 0x02);
+  //ReadModifyWriteTPI(TPI_INTERRUPT_ENABLE_REG, 0x03, 	0x03);	 //enable HPD and RSEN interrupt
+  
+}
+
+
+////////////////////////////////////////////////////////////////////
+// Int4Isr
+//
+//
+//	Look for interrupts on INTR4 (Register 0x74)
+//		7 = RSVD		(reserved)
+//		6 = RGND Rdy	(interested)
+//		5 = VBUS Low	(ignore)	
+//		4 = CBUS LKOUT	(interested)
+//		3 = USB EST		(interested)
+//		2 = MHL EST		(interested)
+//		1 = RPWR5V Change	(ignore)
+//		0 = SCDT Change	(interested during D0)
+////////////////////////////////////////////////////////////////////
+static	void	Int4Isr( void )
+{
+	byte		reg74;
+
+	reg74 = I2C_ReadByte(SA_TX_Page0_Primary, (0x74));	// read status
+
+	printk(KERN_ERR "[MHL] Int4Isr : REG74 : %x\n",(int)reg74);
+
+	// When I2C is inoperational (say in D3) and a previous interrupt brought us here, do nothing.
+	if(0xFF == reg74)
+	{
+		printk(KERN_ERR "RETURN (0xFF == reg74)\n");
+		return;
+	}
+
+	if(reg74 & BIT_2) // MHL_EST_INT
+	{
+		if((I2C_ReadByte(SA_TX_Page0_Primary, 0x09) & BIT_2) == 0x00) {
+			printk(KERN_ERR "[MHL] RSEN is low - status incorrect\n");
+			MHL_On(0);
+			return;
+		}
+    	        MASK_CBUS1_INTERRUPTS; 
+    	        MASK_CBUS2_INTERRUPTS;
+		//fwPowerState = TX_POWER_STATE_D0_MHL;
+		//EnableFSA9480Interrupts(); //daniel 
+		MhlTxDrvProcessConnection(); 
+	}
+
+	// process USB_EST interrupt
+	else if(reg74 & BIT_3) // MHL_DISC_FAIL_INT
+	{
+    if(mhl_cable_status == (MHL_1K_IMPEDANCE_VERIFIED|MHL_POWER_ON))//|MHL_RSEN_VERIFIED))
+    {
+      mhl_cable_status =MHL_TV_OFF_CABLE_CONNECT;
+      printk(KERN_ERR "MHL Connection Fail Power off ###\n");
+	MHL_On(0);
+      #if defined(CONFIG_S5PC110_DEMPSEY_BOARD)
+        FSA9480_MhlTvOff();//Rajucm: Mhl cable handling when TV Off 
+      #endif
+    }
+    else
+    {
+		MhlTxDrvProcessDisconnection();
+    }
+		return;
+	}
+
+	if((TX_POWER_STATE_D3 == fwPowerState) && (reg74 & BIT_6))
+
+	{
+		// process RGND interrupt
+
+		// Switch to full power mode.
+		SwitchToD0();
+
+		//
+		// If a sink is connected but not powered on, this interrupt can keep coming
+		// Determine when to go back to sleep. Say after 1 second of this state.
+		//
+		// Check RGND register and send wake up pulse to the peer
+		//
+		ProcessRgnd();
+	}
+
+	// CBUS Lockout interrupt?
+	if (reg74 & BIT_4)
+	{
+		TX_DEBUG_PRINT(("Drv: CBus Lockout\n"));
+
+		ForceUsbIdSwitchOpen();
+		ReleaseUsbIdSwitchOpen();
+	}
+	I2C_WriteByte(SA_TX_Page0_Primary, (0x74), reg74);	// clear all interrupts
+
+}
+///////////////////////////////////////////////////////////////////////////
+//
+// MhlTxDrvProcessConnection
+//
+///////////////////////////////////////////////////////////////////////////
+void MhlTxDrvProcessConnection ( void )
+{
+	bool	mhlConnected = TRUE;
+
+	TX_DEBUG_PRINT (("Drv: MHL Cable Connected. CBUS:0x0A = %02X\n", (int) ReadByteCBUS(0x0a)));
+
+	if( TX_POWER_STATE_D0_MHL == fwPowerState )
+	{
+		TX_DEBUG_PRINT(("POWER_STATE_D0_MHL == fwPowerState\n"));
+		return;
+	}
+
+	//
+	// Discovery over-ride: reg_disc_ovride	
+	//
+	I2C_WriteByte(SA_TX_Page0_Primary, 0xA0, 0x10);
+	fwPowerState = TX_POWER_STATE_D0_MHL;
+
+
+
+	// Increase DDC translation layer timer (byte mode)
+	// Setting DDC Byte Mode
+	//
+	WriteByteCBUS(0x07, 0x32);
+
+	// Enable segment pointer safety
+	SET_BIT(SA_TX_CBUS_Primary, 0x44, 1);
+
+
+	// Un-force HPD (it was kept low, now propagate to source
+	CLR_BIT(SA_TX_Page0_Primary, 0x79, 4);
+
+	// Enable TMDS
+	SiiMhlTxDrvTmdsControl( TRUE );
+
+	// Keep the discovery enabled. Need RGND interrupt
+	// SET_BIT(SA_TX_Page0_Primary, 0x90, 0);
+	ENABLE_DISCOVERY;
+
+	// Notify upper layer of cable connection
+	SiiMhlTxNotifyConnection(mhlConnected = TRUE);
+}
+///////////////////////////////////////////////////////////////////////////
+//
+// MhlTxDrvProcessDisconnection
+//
+///////////////////////////////////////////////////////////////////////////
+void MhlTxDrvProcessDisconnection ( void )
+{
+	bool	mhlConnected = FALSE;
+
+	TX_DEBUG_PRINT (("Drv: MhlTxDrvProcessDisconnection\n"));
+
+	// clear all interrupts
+	I2C_WriteByte(SA_TX_Page0_Primary, (0x74), I2C_ReadByte(SA_TX_Page0_Primary, (0x74)));
+
+	I2C_WriteByte(SA_TX_Page0_Primary, 0xA0, 0xD0);
+
+	//
+	// Reset CBus to clear register contents
+	// This may need some key reinitializations
+	//
+	CbusReset();
+
+	// Disable TMDS
+	SiiMhlTxDrvTmdsControl( FALSE );
+
+	if( TX_POWER_STATE_D0_MHL == fwPowerState )
+	{
+		// Notify upper layer of cable connection
+		SiiMhlTxNotifyConnection(mhlConnected = FALSE);
+	}
+
+	// Now put chip in sleep mode
+	SwitchToD3();
+}
+///////////////////////////////////////////////////////////////////////////
+//
+// CbusReset
+//
+///////////////////////////////////////////////////////////////////////////
+void	CbusReset()
+{
+	SET_BIT(SA_TX_Page0_Primary, 0x05, 3);
+	DelayMS(2);
+	CLR_BIT(SA_TX_Page0_Primary, 0x05, 3);
+
+	mscCmdInProgress = FALSE;
+
+	// Adjust interrupt mask everytime reset is performed.
+	UNMASK_CBUS1_INTERRUPTS;
+	UNMASK_CBUS2_INTERRUPTS;
+}
+///////////////////////////////////////////////////////////////////////////
+//
+// CBusProcessErrors
+//
+//
+///////////////////////////////////////////////////////////////////////////
+static byte CBusProcessErrors( byte intStatus )
+{
+	byte result          = 0;
+	byte mscAbortReason  = 0;
+	byte ddcAbortReason  = 0;
+
+	/* At this point, we only need to look at the abort interrupts. */
+
+	intStatus &=  (BIT_MSC_ABORT | BIT_MSC_XFR_ABORT);
+
+	if ( intStatus )
+	{
+		//      result = ERROR_CBUS_ABORT;		// No Retry will help
+
+		/* If transfer abort or MSC abort, clear the abort reason register. */
+		if( intStatus & BIT_DDC_ABORT )
+		{
+			result = ddcAbortReason = ReadByteCBUS((byte) REG_DDC_ABORT_REASON );
+			TX_DEBUG_PRINT( ("CBUS DDC ABORT happened, reason:: %02X\n", (int)(ddcAbortReason)));
+		}
+
+		if ( intStatus & BIT_MSC_XFR_ABORT )
+		{
+			result = mscAbortReason = ReadByteCBUS((byte) REG_PRI_XFR_ABORT_REASON );
+
+			TX_DEBUG_PRINT( ("CBUS:: MSC Transfer ABORTED. Clearing 0x0D\n"));
+			WriteByteCBUS((byte) REG_PRI_XFR_ABORT_REASON, 0xFF );
+		}
+		if ( intStatus & BIT_MSC_ABORT )
+		{
+			TX_DEBUG_PRINT( ("CBUS:: MSC Peer sent an ABORT. Clearing 0x0E\n"));
+			WriteByteCBUS((byte) REG_CBUS_PRI_FWR_ABORT_REASON, 0xFF );
+		}
+
+		// Now display the abort reason.
+
+		if ( mscAbortReason != 0 )
+		{
+			TX_DEBUG_PRINT( ("CBUS:: Reason for ABORT is ....0x%02X = ", (int)mscAbortReason ));
+
+			if ( mscAbortReason & CBUSABORT_BIT_REQ_MAXFAIL)
+			{
+				TX_DEBUG_PRINT( ("Requestor MAXFAIL - retry threshold exceeded\n"));
+			}
+			if ( mscAbortReason & CBUSABORT_BIT_PROTOCOL_ERROR)
+			{
+				TX_DEBUG_PRINT( ("Protocol Error\n"));
+			}
+			if ( mscAbortReason & CBUSABORT_BIT_REQ_TIMEOUT)
+			{
+				TX_DEBUG_PRINT( ("Requestor translation layer timeout\n"));
+			}
+			if ( mscAbortReason & CBUSABORT_BIT_PEER_ABORTED)
+			{
+				TX_DEBUG_PRINT( ("Peer sent an abort\n"));
+			}
+			if ( mscAbortReason & CBUSABORT_BIT_UNDEFINED_OPCODE)
+			{
+				TX_DEBUG_PRINT( ("Undefined opcode\n"));
+			}
+		}
+	}
+	return( result );
+}
+
+///////////////////////////////////////////////////////////////////////////
+//
+// MhlCbusIsr
+//
+// Only when MHL connection has been established. This is where we have the
+// first looks on the CBUS incoming commands or returned data bytes for the
+// previous outgoing command.
+//
+// It simply stores the event and allows application to pick up the event
+// and respond at leisure.
+//
+// Look for interrupts on CBUS:CBUS_INTR_STATUS [0xC8:0x08]
+//		7 = RSVD			(reserved)
+//		6 = MSC_RESP_ABORT	(interested)
+//		5 = MSC_REQ_ABORT	(interested)	
+//		4 = MSC_REQ_DONE	(interested)
+//		3 = MSC_MSG_RCVD	(interested)
+//		2 = DDC_ABORT		(interested)
+//		1 = RSVD			(reserved)
+//		0 = rsvd			(reserved)
+///////////////////////////////////////////////////////////////////////////
+static void MhlCbusIsr( void )
+{
+	byte		cbusInt;
+	byte     gotData[4];	// Max four status and int registers.
+	byte		i;
+
+	//
+	// Main CBUS interrupts on CBUS_INTR_STATUS
+	//
+	cbusInt = ReadByteCBUS(0x08);
+
+	// When I2C is inoperational (say in D3) and a previous interrupt brought us here, do nothing.
+	if(cbusInt == 0xFF)
+	{
+		return;
+	}
+	if( cbusInt )
+	{
+		TX_DEBUG_PRINT(("Drv: CBUS INTR_1: %d\n", (int) cbusInt));
+	}
+
+	// Look for DDC_ABORT
+	if (cbusInt & BIT_2)
+	{
+		ApplyDdcAbortSafety();
+	}
+	// MSC_MSG (RCP/RAP)
+	if((cbusInt & BIT_3))
+	{
+		TX_DEBUG_PRINT(("Drv: MSC_MSG Received: %02X\n", (int) cbusInt));
+		//
+		// Two bytes arrive at registers 0x18 and 0x19
+		//
+		SiiMhlTxGotMhlMscMsg( ReadByteCBUS( 0x18 ), ReadByteCBUS( 0x19 ) );
+	}
+	// MSC_REQ_DONE received.
+	if(cbusInt & BIT_4)
+	{
+		TX_DEBUG_PRINT(("Drv: MSC_REQ_DONE: %02X\n", (int) cbusInt));
+
+		mscCmdInProgress = FALSE;
+
+		SiiMhlTxMscCommandDone( ReadByteCBUS( 0x16 ) );
+	}
+	if((cbusInt & BIT_5) || (cbusInt & BIT_6))	// MSC_REQ_ABORT or MSC_RESP_ABORT
+	{
+		gotData[0] = CBusProcessErrors(cbusInt);
+	}
+	if(cbusInt)
+	{
+		//
+		// Clear all interrupts that were raised even if we did not process
+		//
+		WriteByteCBUS(0x08, cbusInt);
+
+		TX_DEBUG_PRINT(("Drv: Clear CBUS INTR_1: %02X\n", (int) cbusInt));
+	}
+	//
+	// Clear all interrupts that were raised even if we did not process
+	//
+
+	//
+	// Now look for interrupts on register 0x1E. CBUS_MSC_INT2
+	// 7:4 = Reserved
+	//   3 = msc_mr_write_state = We got a WRITE_STAT
+	//   2 = msc_mr_set_int. We got a SET_INT
+	//   1 = reserved
+	//   0 = msc_mr_write_burst. We received WRITE_BURST
+	//
+	cbusInt = ReadByteCBUS(0x1E);
+	if( cbusInt )
+	{
+		TX_DEBUG_PRINT(("Drv: CBUS INTR_2: %x\n", (int) cbusInt));
+	}
+	if(cbusInt & BIT_2)
+	{
+		TX_DEBUG_PRINT(("Drv: INT Received: %x\n", (int) cbusInt));
+
+		// We are interested only in first two bytes.
+		SiiMhlTxGotMhlIntr( ReadByteCBUS( 0xA0 ), ReadByteCBUS( 0xA1) );
+
+		for(i = 0; i < 4; i++)
+		{
+			// Clear all
+			WriteByteCBUS( (0xA0 + i), ReadByteCBUS( 0xA0 + i ));
+		}
+	}
+	if(cbusInt & BIT_3)
+	{
+		TX_DEBUG_PRINT(("Drv: STATUS Received: %x\n", (int) cbusInt));
+
+		// We are interested only in first two bytes.
+		SiiMhlTxGotMhlStatus( ReadByteCBUS( 0xB0 ), ReadByteCBUS( 0xB1) );
+
+		for(i = 0; i < 4; i++)
+		{
+			// Clear all
+			WriteByteCBUS( (0xB0 + i), ReadByteCBUS( 0xB0 + i ));
+		}
+	}
+	if(cbusInt)
+	{
+		//
+		// Clear all interrupts that were raised even if we did not process
+		//
+		WriteByteCBUS(0x1E, cbusInt);
+
+		TX_DEBUG_PRINT(("Drv: Clear CBUS INTR_2: %02X\n", (int) cbusInt));
+	}
+
+#if 0
+	//
+	// Check if a SET_HPD came from the downstream device.
+	//
+	cbusInt = ReadByteCBUS(0x0D);
+
+	// CBUS_HPD status bit
+	if((BIT_6 & cbusInt) != dsHpdStatus)
+	{
+		// Inform upper layer of change in Downstream HPD
+		SiiMhlTxNotifyDsHpdChange( cbusInt );
+		TX_DEBUG_PRINT(("Drv: Downstream HPD changed to: %02X\n", (int) cbusInt));
+
+		// Remember
+		dsHpdStatus = (BIT_6 & cbusInt);
+	}
+#endif
+}
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+// sii_mhl_tx_init
+//
+// Sets the transmitter component firmware up for operation, brings up chip
+// into power on state first and then back to reduced-power mode D3 to conserve
+// power until an MHL cable connection has been established. If the MHL port is
+// used for USB operation, the chip and firmware continue to stay in D3 mode.
+// Only a small circuit in the chip observes the impedance variations to see if
+// processor should be interrupted to continue MHL discovery process or not.
+//
+// interruptDriven		If TRUE, MhlTx component will not look at its status
+//						registers in a polled manner from timer handler 
+//						(SiiMhlTxGetEvents). It will expect that all device 
+//						events will result in call to the function 
+//						SiiMhlTxDeviceIsr() by host's hardware or software 
+//						(a master interrupt handler in host software can call
+//						it directly). interruptDriven == TRUE also implies that
+//						the MhlTx component shall make use of AppDisableInterrupts()
+//						and AppRestoreInterrupts() for any critical section work to
+//						prevent concurrency issues.
+//
+//						When interruptDriven == FALSE, MhlTx component will do
+//						all chip status analysis via looking at its register
+//						when called periodically into the function
+//						SiiMhlTxGetEvents() described below.
+//
+// pollIntervalMs		This number should be higher than 0 and lower than 
+//						51 milliseconds for effective operation of the firmware.
+//						A higher number will only imply a slower response to an 
+//						event on MHL side which can lead to violation of a 
+//						connection disconnection related timing or a slower 
+//						response to RCP messages.
+//
+//
+//
+//
+//void sii_mhl_tx_init( bool interruptDriven, byte pollIntervalMs )
+void sii_mhl_tx_init( void )
+{
+	TX_DEBUG_PRINT( ("MhlTx: sii_mhl_tx_init\n") );
+
+	MhlTxResetStates( );
+
+	SiiMhlTxChipInitialize ();
+	mhl_cable_status =MHL_POWER_ON;			//NAGSM_Android_SEL_Kernel_Aakash_20101214
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+// 
+// SiiMhlTxGetEvents
+//
+// This is a function in MhlTx that must be called by application in a periodic
+// fashion. The accuracy of frequency (adherence to the parameter pollIntervalMs)
+// will determine adherence to some timings in the MHL specifications, however,
+// MhlTx component keeps a tolerance of up to 50 milliseconds for most of the
+// timings and deploys interrupt disabled mode of operation (applicable only to
+// Sii 9244) for creating precise pulse of smaller duration such as 20 ms.
+//
+// This function does not return anything but it does modify the contents of the
+// two pointers passed as parameter.
+//
+// It is advantageous for application to call this function in task context so
+// that interrupt nesting or concurrency issues do not arise. In addition, by
+// collecting the events in the same periodic polling mechanism prevents a call
+// back from the MhlTx which can result in sending yet another MHL message.
+//
+// An example of this is responding back to an RCP message by another message
+// such as RCPK or RCPE.
+//
+//
+// *event		MhlTx returns a value in this field when function completes execution.
+// 				If this field is 0, the next parameter is undefined.
+//				The following values may be returned.
+//
+//
+void SiiMhlTxGetEvents( byte *event, byte *eventParameter )
+{
+
+	SiiMhlTxDeviceIsr();
+
+	if(mhl_cable_status == MHL_TV_OFF_CABLE_CONNECT)
+	{
+		return ;
+	}
+
+	MhlTxDriveStates( );
+
+	*event = MHL_TX_EVENT_NONE;
+	*eventParameter = 0;
+
+	if( mhlTxConfig.mhlConnectionEvent )
+	{
+		TX_DEBUG_PRINT( ("MhlTx: SiiMhlTxGetEvents mhlConnectionEvent\n") );
+
+		// Consume the message
+		mhlTxConfig.mhlConnectionEvent = FALSE;
+
+		//
+		// Let app know the connection went away.
+		//
+		*event          = mhlTxConfig.mhlConnected;
+		*eventParameter	= mhlTxConfig.mscFeatureFlag;
+
+		// If connection has been lost, reset all state flags.
+		if(MHL_TX_EVENT_DISCONNECTION == mhlTxConfig.mhlConnected)
+		{
+			MhlTxResetStates( );
+		}
+	}
+	else if( mhlTxConfig.mscMsgArrived )
+	{
+		TX_DEBUG_PRINT( ("MhlTx: SiiMhlTxGetEvents MSC MSG Arrived\n") );
+
+		// Consume the message
+		mhlTxConfig.mscMsgArrived = FALSE;
+
+		//
+		// Map sub-command to an event id
+		//
+		switch(mhlTxConfig.mscMsgSubCommand)
+		{
+			case	MHL_MSC_MSG_RAP:
+				// RAP is fully handled here.
+				//
+				// Handle RAP sub-commands here itself
+				//
+				if( MHL_RAP_CONTENT_ON == mhlTxConfig.mscMsgData)
+				{
+					SiiMhlTxDrvTmdsControl( TRUE );
+				}
+				else if( MHL_RAP_CONTENT_OFF == mhlTxConfig.mscMsgData)
+				{
+					SiiMhlTxDrvTmdsControl( FALSE );
+
+				}
+				// Always RAPK to the peer
+				SiiMhlTxRapkSend( );
+				break;
+
+			case	MHL_MSC_MSG_RCP:
+
+				// If we get a RCP key that we do NOT support, send back RCPE
+				// Do not notify app layer.
+				if(MHL_LOGICAL_DEVICE_MAP & rcpSupportTable [mhlTxConfig.mscMsgData] )
+				{
+				*event          = MHL_TX_EVENT_RCP_RECEIVED;
+				*eventParameter = mhlTxConfig.mscMsgData; // key code
+#if 1	// xmoondash :: compile error
+/* jinho96.kim 2011.01.06 */
+				rcp_cbus_uevent(*eventParameter);	//MHL v1 //NAGSM_Android_SEL_Kernel_Aakash_20101126
+#endif
+
+				printk(KERN_ERR "Key Code:%x \n",(int)mhlTxConfig.mscMsgData);
+                                }
+else
+				{
+  				printk("Key Code Error:%x \n",(int)mhlTxConfig.mscMsgData);
+					SiiMhlTxRcpeSend( 0x01 );
+				}
+				break;
+
+			case	MHL_MSC_MSG_RCPK:
+				*event = MHL_TX_EVENT_RCPK_RECEIVED;
+        *eventParameter = mhlTxConfig.mscMsgData; // key code
+				break;
+
+			case	MHL_MSC_MSG_RCPE:
+				*event = MHL_TX_EVENT_RCPE_RECEIVED;
+        *eventParameter = mhlTxConfig.mscMsgData; // status code
+				break;
+
+			case	MHL_MSC_MSG_RAPK:
+				// Do nothing if RAPK comes
+				break;
+
+			default:
+				// Any freak value here would continue with no event to app
+				break;
+		}
+
+	}
+}
+///////////////////////////////////////////////////////////////////////////////
+//
+// MhlTxDriveStates
+//
+// This is an internal function to move the MSC engine to do the next thing
+// before allowing the application to run RCP APIs.
+//
+// It is called in interrupt context to meet some MHL specified timings, therefore,
+// it should not have to call app layer and do negligible processing, no printks.
+//
+static	void	MhlTxDriveStates( void )
+{
+
+	switch( mhlTxConfig.mscState )
+	{
+		case MSC_STATE_BEGIN:
+			printk(KERN_ERR "MSC_STATE_BEGIN \n");
+			SiiMhlTxReadDevcap( MHL_DEV_CATEGORY_OFFSET );
+			break;
+		case MSC_STATE_POW_DONE:
+			//
+			// Send out Read Devcap for MHL_DEV_FEATURE_FLAG_OFFSET
+			// to check if it supports RCP/RAP etc
+			//
+			printk(KERN_ERR "MSC_STATE_POW_DONE \n");
+			SiiMhlTxReadDevcap( MHL_DEV_FEATURE_FLAG_OFFSET );
+			break;
+		case MSC_STATE_IDLE:
+		case MSC_STATE_RCP_READY:
+			break;
+		default:
+			break;
+
+	}
+}
+///////////////////////////////////////////////////////////////////////////////
+//
+// SiiMhlTxMscCommandDone
+//
+// This function is called by the driver to inform of completion of last command.
+//
+// It is called in interrupt context to meet some MHL specified timings, therefore,
+// it should not have to call app layer and do negligible processing, no printks.
+//
+void	SiiMhlTxMscCommandDone( byte data1 )
+{
+	TX_DEBUG_PRINT( ("MhlTx: SiiMhlTxMscCommandDone. data1 = %02X\n", (int) data1) );
+
+	if(( MHL_READ_DEVCAP == mhlTxConfig.mscLastCommand ) && 
+			(MHL_DEV_CATEGORY_OFFSET == mhlTxConfig.mscLastOffset))
+	{
+		// We are done reading POW. Next we read Feature Flag
+		mhlTxConfig.mscState	= MSC_STATE_POW_DONE;
+
+		AppVbusControl( (bool) ( data1 & MHL_DEV_CATEGORY_POW_BIT) );
+
+		//
+		// Send out Read Devcap for MHL_DEV_FEATURE_FLAG_OFFSET
+		// to check if it supports RCP/RAP etc
+		//
+		//		SiiMhlTxReadDevcap( MHL_DEV_FEATURE_FLAG_OFFSET );
+
+		//		MhlTxDriveStates( );
+	}
+	else if((MHL_READ_DEVCAP == mhlTxConfig.mscLastCommand) &&
+			(MHL_DEV_FEATURE_FLAG_OFFSET == mhlTxConfig.mscLastOffset))
+	{
+		// We are done reading Feature Flag. Let app know we are done.
+		mhlTxConfig.mscState	= MSC_STATE_RCP_READY;
+
+		// Remember features of the peer
+		mhlTxConfig.mscFeatureFlag	= data1;
+
+		// Now we can entertain App commands for RCP
+		// Let app know this state
+		mhlTxConfig.mhlConnectionEvent = TRUE;
+		mhlTxConfig.mhlConnected = MHL_TX_EVENT_RCP_READY;
+
+		// These variables are used to remember if we issued a READ_DEVCAP
+		// Since we are done, reset them.
+		mhlTxConfig.mscLastCommand = 0;
+		mhlTxConfig.mscLastOffset  = 0;
+
+		TX_DEBUG_PRINT( ("MhlTx: Peer's Feature Flag = %02X\n\n", (int) data1) );
+	}
+	else if(MHL_MSC_MSG_RCPE == mhlTxConfig.mscMsgLastCommand)
+	{
+		//
+		// RCPE is always followed by an RCPK with original key code that came.
+		//
+		if( SiiMhlTxRcpkSend( mhlTxConfig.mscSaveRcpKeyCode ) )
+		{
+			// Once the command has been sent out successfully, forget this case.
+			mhlTxConfig.mscMsgLastCommand = 0;
+			mhlTxConfig.mscMsgLastData    = 0;
+		}
+}
+}
+///////////////////////////////////////////////////////////////////////////////
+//
+// SiiMhlTxGotMhlMscMsg
+//
+// This function is called by the driver to inform of arrival of a MHL MSC_MSG
+// such as RCP, RCPK, RCPE. To quickly return back to interrupt, this function
+// remembers the event (to be picked up by app later in task context).
+//
+// It is called in interrupt context to meet some MHL specified timings, therefore,
+// it should not have to call app layer and do negligible processing of its own,
+//
+// No printks.
+//
+// Application shall not call this function.
+//
+void	SiiMhlTxGotMhlMscMsg( byte subCommand, byte cmdData )
+{
+	// Remeber the event.
+	mhlTxConfig.mscMsgArrived		= TRUE;
+	mhlTxConfig.mscMsgSubCommand	= subCommand;
+	mhlTxConfig.mscMsgData			= cmdData;
+}
+///////////////////////////////////////////////////////////////////////////////
+//
+// SiiMhlTxGotMhlIntr
+//
+// This function is called by the driver to inform of arrival of a MHL INTERRUPT.
+//
+// It is called in interrupt context to meet some MHL specified timings, therefore,
+// it should not have to call app layer and do negligible processing, no printks.
+//
+void	SiiMhlTxGotMhlIntr( byte intr_0, byte intr_1 )
+{
+	TX_DEBUG_PRINT( ("MhlTx: INTERRUPT Arrived. %02X, %02X\n", (int) intr_0, (int) intr_1) );
+
+	//
+	// Handle DCAP_CHG INTR here
+	//
+	if(MHL_INT_DCAP_CHG & intr_0)
+	{
+		SiiMhlTxReadDevcap( MHL_DEV_CATEGORY_OFFSET );
+		//		MhlTxDriveStates( );
+	}
+	else if(MHL_INT_EDID_CHG & intr_1)
+	{
+		// force upstream source to read the EDID again.
+		// Most likely by appropriate togggling of HDMI HPD
+		SiiMhlTxDrvNotifyEdidChange ( );
+	}
+}
+///////////////////////////////////////////////////////////////////////////////
+//
+// SiiMhlTxGotMhlStatus
+//
+// This function is called by the driver to inform of arrival of a MHL STATUS.
+//
+// It is called in interrupt context to meet some MHL specified timings, therefore,
+// it should not have to call app layer and do negligible processing, no printks.
+//
+void	SiiMhlTxGotMhlStatus( byte status_0, byte status_1 )
+{
+	TX_DEBUG_PRINT( ("MhlTx: STATUS Arrived. %02X, %02X\n", (int) status_0, (int) status_1) );
+	//
+	// Handle DCAP_RDY STATUS here itself
+	//
+	if(MHL_STATUS_DCAP_RDY & status_0)
+	{
+		//		MhlTxDriveStates( );
+		//		SiiMhlTxReadDevcap( MHL_DEV_CATEGORY_OFFSET );
+    mhlTxConfig.mscState	 = MSC_STATE_BEGIN;
+	}
+	// status_1 has the PATH_EN etc. Not yet implemented
+	// Remeber the event.
+	mhlTxConfig.status_0 = status_0;
+	mhlTxConfig.status_1 = status_1;
+}
+///////////////////////////////////////////////////////////////////////////////
+//
+// SiiMhlTxRcpSend
+//
+// This function checks if the peer device supports RCP and sends rcpKeyCode. The
+// function will return a value of TRUE if it could successfully send the RCP
+// subcommand and the key code. Otherwise FALSE.
+//
+// The followings are not yet utilized.
+// 
+// (MHL_FEATURE_RAP_SUPPORT & mhlTxConfig.mscFeatureFlag))
+// (MHL_FEATURE_SP_SUPPORT & mhlTxConfig.mscFeatureFlag))
+//
+//
+bool SiiMhlTxRcpSend( byte rcpKeyCode )
+{
+	//
+	// If peer does not support do not send RCP or RCPK/RCPE commands
+	//
+	if((0 == (MHL_FEATURE_RCP_SUPPORT & mhlTxConfig.mscFeatureFlag)) ||
+			(MSC_STATE_RCP_READY != mhlTxConfig.mscState))
+	{
+		return	FALSE;
+	}
+	return	( MhlTxSendMscMsg ( MHL_MSC_MSG_RCP, rcpKeyCode ) );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// SiiMhlTxRcpkSend
+//
+// This function sends RCPK to the peer device. 
+//
+bool SiiMhlTxRcpkSend( byte rcpKeyCode )
+{
+	return	( MhlTxSendMscMsg ( MHL_MSC_MSG_RCPK, rcpKeyCode ) );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// SiiMhlTxRapkSend
+//
+// This function sends RAPK to the peer device. 
+//
+static	bool SiiMhlTxRapkSend( void )
+{
+	return	( MhlTxSendMscMsg ( MHL_MSC_MSG_RAPK, 0 ) );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// SiiMhlTxRcpeSend
+//
+// The function will return a value of true if it could successfully send the RCPE
+// subcommand. Otherwise false.
+//
+// When successful, MhlTx internally sends RCPK with original (last known)
+// keycode.
+//
+bool SiiMhlTxRcpeSend( byte rcpeErrorCode )
+{
+	return( MhlTxSendMscMsg ( MHL_MSC_MSG_RCPE, rcpeErrorCode ) );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+//
+
+// SiiMhlTxReadDevcap
+//
+// This function sends a READ DEVCAP MHL command to the peer.
+// It  returns TRUE if successful in doing so.
+//
+// The value of devcap should be obtained by making a call to SiiMhlTxGetEvents()
+//
+// offset		Which byte in devcap register is required to be read. 0..0x0E
+//
+bool SiiMhlTxReadDevcap( byte offset )
+{
+	cbus_req_t	req;
+	//
+	// Send MHL_READ_DEVCAP command
+	//
+	req.command     = mhlTxConfig.mscLastCommand = MHL_READ_DEVCAP;
+	req.offsetData  = mhlTxConfig.mscLastOffset  = offset;
+	return(SiiMhlTxDrvSendCbusCommand( &req  ));
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// MhlTxSendMscMsg
+//
+// This function sends a MSC_MSG command to the peer.
+// It  returns TRUE if successful in doing so.
+//
+// The value of devcap should be obtained by making a call to SiiMhlTxGetEvents()
+//
+// offset		Which byte in devcap register is required to be read. 0..0x0E
+//
+static bool MhlTxSendMscMsg ( byte command, byte cmdData )
+{
+	cbus_req_t	req;
+	byte		ccode;
+
+	//
+	// Send MSC_MSG command
+	//
+	req.command     = MHL_MSC_MSG;
+	req.msgData[0]  = mhlTxConfig.mscMsgLastCommand = command;
+	req.msgData[1]  = mhlTxConfig.mscMsgLastData    = cmdData;
+
+
+
+	ccode = SiiMhlTxDrvSendCbusCommand( &req  );
+	return( (bool) ccode );
+
+}
+///////////////////////////////////////////////////////////////////////////////
+// 
+// SiiMhlTxNotifyConnection
+//
+//
+void	SiiMhlTxNotifyConnection( bool mhlConnected )
+{
+	//	printk(KERN_ERR "SiiMhlTxNotifyConnection %01X\n", (int) mhlConnected );
+
+	mhlTxConfig.mhlConnectionEvent = TRUE;
+
+  mhlTxConfig.mscState	 = MSC_STATE_IDLE;
+	if(mhlConnected)
+	{
+		mhlTxConfig.mhlConnected = MHL_TX_EVENT_CONNECTION;
+	}
+	else
+	{
+		mhlTxConfig.mhlConnected = MHL_TX_EVENT_DISCONNECTION;
+	}
+}
+///////////////////////////////////////////////////////////////////////////////
+//
+// SiiMhlTxNotifyDsHpdChange
+// Driver tells about arrival of SET_HPD or CLEAR_HPD by calling this function.
+//
+// Turn the content off or on based on what we got.
+//
+void	SiiMhlTxNotifyDsHpdChange( byte dsHpdStatus )
+{
+	if( 0 == dsHpdStatus )
+	{
+		TX_DEBUG_PRINT(("MhlTx: Disable TMDS\n"));
+		SiiMhlTxDrvTmdsControl( FALSE );
+	}
+	else
+	{
+		TX_DEBUG_PRINT(("MhlTx: Enable TMDS\n"));
+		SiiMhlTxDrvTmdsControl( TRUE );
+	}
+}
+///////////////////////////////////////////////////////////////////////////////
+//
+// MhlTxResetStates
+//
+// Application picks up mhl connection and rcp events at periodic intervals.
+// Interrupt handler feeds these variables. Reset them on disconnection. 
+//
+static void	MhlTxResetStates( void )
+{
+	mhlTxConfig.mhlConnectionEvent	= FALSE;
+	mhlTxConfig.mhlConnected		= MHL_TX_EVENT_DISCONNECTION;
+	mhlTxConfig.mscMsgArrived		= FALSE;
+	mhlTxConfig.mscState			= MSC_STATE_IDLE;
+}
+
+#define	APP_DEMO_RCP_SEND_KEY_CODE 0x44
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// AppRcpDemo
+//
+// This function is supposed to provide a demo code to elicit how to call RCP
+// API function.
+//
+void	AppRcpDemo( byte event, byte eventParameter)
+{
+	byte		rcpKeyCode;
+
+	//	printk(KERN_ERR "App: Got event = %02X, eventParameter = %02X\n", (int)event, (int)eventParameter);
+
+	switch( event )
+	{
+		case	MHL_TX_EVENT_DISCONNECTION:
+			printk(KERN_ERR "App: Got event = MHL_TX_EVENT_DISCONNECTION\n");
+			break;
+
+		case	MHL_TX_EVENT_CONNECTION:
+			printk(KERN_ERR "App: Got event = MHL_TX_EVENT_CONNECTION\n");
+			break;
+
+		case	MHL_TX_EVENT_RCP_READY:
+
+			// Demo RCP key code PLAY
+			rcpKeyCode = APP_DEMO_RCP_SEND_KEY_CODE;
+
+			printk(KERN_ERR "App: Got event = MHL_TX_EVENT_RCP_READY...Sending RCP (%02X)\n", (int) rcpKeyCode);
+
+#if 0
+			if( (0 == (MHL_FEATURE_RCP_SUPPORT & eventParameter)) )
+			{
+				printk(KERN_ERR  "App: Peer does NOT support RCP\n" );
+			}
+			if( (0 == (MHL_FEATURE_RAP_SUPPORT & eventParameter)) )
+			{
+				printk(KERN_ERR  "App: Peer does NOT support RAP\n" );
+			}
+			if( (0 == (MHL_FEATURE_SP_SUPPORT & eventParameter)) )
+			{
+				printk(KERN_ERR  "App: Peer does NOT support WRITE_BURST\n" );
+			}
+
+
+			//
+			// If RCP engine is ready, send one code
+			//
+			if( SiiMhlTxRcpSend( rcpKeyCode ))
+			{
+				printk(KERN_ERR "App: SiiMhlTxRcpSend (%02X)\n", (int) rcpKeyCode);
+			}
+			else
+			{
+				printk(KERN_ERR "App: SiiMhlTxRcpSend (%02X) Returned Failure.\n", (int) rcpKeyCode);
+			}
+#endif
+
+			break;
+
+		case	MHL_TX_EVENT_RCP_RECEIVED:
+			//
+			// Check if we got an RCP. Application can perform the operation here
+			// and send RCPK or RCPE. For now, we send the RCPK
+			//
+			printk(KERN_ERR "App: Received an RCP key code = %02X\n", eventParameter );
+
+			switch(eventParameter)
+			{
+
+				case MHD_RCP_CMD_SELECT:
+					TX_DEBUG_PRINT(( "\nSelect received = %02x\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_UP:
+					TX_DEBUG_PRINT(( "\nUp received = %02x\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_DOWN:
+					TX_DEBUG_PRINT(( "\nDown received = %02x\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_LEFT:
+					TX_DEBUG_PRINT(( "\nLeft received = %02x\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_RIGHT:
+					TX_DEBUG_PRINT(( "\nRight received = %02x\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_RIGHT_UP:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_RIGHT_UP = %02x\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_RIGHT_DOWN:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_RIGHT_DOWN = %02x\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_LEFT_UP:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_LEFT_UP = %02x\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_LEFT_DOWN:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_LEFT_DOWN\n\n", (int)eventParameter ));
+					break;      
+
+				case MHD_RCP_CMD_ROOT_MENU:
+					TX_DEBUG_PRINT(( "\nRoot Menu received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_SETUP_MENU:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_SETUP_MENU\n\n", (int)eventParameter ));
+					break;      
+
+				case MHD_RCP_CMD_CONTENTS_MENU:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_CONTENTS_MENU\n\n", (int)eventParameter ));
+					break;      
+
+				case MHD_RCP_CMD_FAVORITE_MENU:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_FAVORITE_MENU\n\n", (int)eventParameter ));
+					break;            
+
+				case MHD_RCP_CMD_EXIT:
+					TX_DEBUG_PRINT(( "\nExit received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_NUM_0:
+					TX_DEBUG_PRINT(( "\nNumber 0 received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_NUM_1:
+					TX_DEBUG_PRINT(( "\nNumber 1 received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_NUM_2:
+					TX_DEBUG_PRINT(( "\nNumber 2 received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_NUM_3:
+					TX_DEBUG_PRINT(( "\nNumber 3 received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_NUM_4:
+					TX_DEBUG_PRINT(( "\nNumber 4 received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_NUM_5:
+					TX_DEBUG_PRINT(( "\nNumber 5 received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_NUM_6:
+					TX_DEBUG_PRINT(( "\nNumber 6 received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_NUM_7:
+					TX_DEBUG_PRINT(( "\nNumber 7 received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_NUM_8:
+					TX_DEBUG_PRINT(( "\nNumber 8 received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_NUM_9:
+					TX_DEBUG_PRINT(( "\nNumber 9 received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_DOT:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_DOT\n\n", (int)eventParameter ));
+					break;          
+
+				case MHD_RCP_CMD_ENTER:
+					TX_DEBUG_PRINT(( "\nEnter received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_CLEAR:
+					TX_DEBUG_PRINT(( "\nClear received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_CH_UP:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_CH_UP\n\n", (int)eventParameter ));
+					break; 
+
+				case MHD_RCP_CMD_CH_DOWN:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_CH_DOWN\n\n", (int)eventParameter ));
+					break;       
+
+				case MHD_RCP_CMD_PRE_CH:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_PRE_CH\n\n", (int)eventParameter ));
+					break;           
+
+				case MHD_RCP_CMD_SOUND_SELECT:
+					TX_DEBUG_PRINT(( "\nSound Select received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_INPUT_SELECT:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_INPUT_SELECT\n\n", (int)eventParameter ));
+					break;    
+
+				case MHD_RCP_CMD_SHOW_INFO:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_SHOW_INFO\n\n", (int)eventParameter ));
+					break;     
+
+				case MHD_RCP_CMD_HELP:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_HELP\n\n", (int)eventParameter ));
+					break;   
+
+				case MHD_RCP_CMD_PAGE_UP:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_PAGE_UP\n\n", (int)eventParameter ));
+					break;  
+
+				case MHD_RCP_CMD_PAGE_DOWN:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_PAGE_DOWN\n\n", (int)eventParameter ));
+					break;             
+
+				case MHD_RCP_CMD_VOL_UP:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_VOL_UP\n\n", (int)eventParameter ));
+					break;             
+
+				case MHD_RCP_CMD_VOL_DOWN:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_VOL_DOWN\n\n", (int)eventParameter ));
+					break;             
+
+				case MHD_RCP_CMD_MUTE:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_MUTE\n\n", (int)eventParameter ));
+					break;             
+
+				case MHD_RCP_CMD_PLAY:
+					TX_DEBUG_PRINT(( "\nPlay received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_STOP:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_STOP\n\n", (int)eventParameter ));
+					break;   
+
+				case MHD_RCP_CMD_PAUSE:
+					TX_DEBUG_PRINT(( "\nPause received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_RECORD:
+					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_RECORD\n\n", (int)eventParameter ));
+					break;   
+
+				case MHD_RCP_CMD_FAST_FWD:
+					TX_DEBUG_PRINT(( "\nFastfwd received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_REWIND:
+					TX_DEBUG_PRINT(( "\nRewind received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_EJECT:
+					TX_DEBUG_PRINT(( "\nEject received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_FWD:
+					TX_DEBUG_PRINT(( "\nForward received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_BKWD:
+					TX_DEBUG_PRINT(( "\nBackward received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_PLAY_FUNC:
+					TX_DEBUG_PRINT(( "\nPlay Function received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_PAUSE_PLAY_FUNC:
+					TX_DEBUG_PRINT(( "\nPause_Play Function received\n\n", (int)eventParameter ));
+					break;
+
+				case MHD_RCP_CMD_STOP_FUNC:
+					TX_DEBUG_PRINT(( "\nStop Function received\n\n", (int)eventParameter ));
+					break;
+
+				default:
+
+					break;
+			}
+
+      
+rcpKeyCode = eventParameter;
+			SiiMhlTxRcpkSend(rcpKeyCode);
+			break;
+
+		case	MHL_TX_EVENT_RCPK_RECEIVED:
+			printk(KERN_ERR "App: Received an RCPK = \n");
+			break;
+
+		case	MHL_TX_EVENT_RCPE_RECEIVED:
+			printk(KERN_ERR "App: Received an RCPE = \n");
+			break;
+
+		default:
+			break;
+	}
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// AppVbusControl
+//
+// This function or macro is invoked from MhlTx driver to ask application to
+// control the VBUS power. If powerOn is sent as non-zero, one should assume
+// peer does not need power so quickly remove VBUS power.
+//
+// if value of "powerOn" is 0, then application must turn the VBUS power on
+// within 50ms of this call to meet MHL specs timing.
+//
+// Application module must provide this function.
+//
+void	AppVbusControl( bool powerOn )
+{
+	if( powerOn )
+	{
+		printk(KERN_ERR "App: Peer's POW bit is set. Turn the VBUS power OFF here.\n");
+	}
+	else
+	{
+		printk(KERN_ERR "App: Peer's POW bit is cleared. Turn the VBUS power ON here.\n");
+	}
+}
+
+
+/*===========================================================================
+  FUNCTION sii9234_interrupt_event
+
+  DESCRIPTION
+  When SiI9234 H/W interrupt happen, call this event function
+
+  DEPENDENCIES
+  None
+
+  RETURN VALUE
+  None
+
+  SIDE EFFECTS
+  None
+  ===========================================================================*/
+void sii9234_interrupt_event(void)
+{
+	byte	event;
+	byte	eventParameter;
+	byte	flag;
+	//int	loop_try = 0;
+
+	//TX_DEBUG_PRINT(("Start PinTxInt Pin Init : %d \n",(int)PinTxInt));
+
+	do {
+		//
+		// Look for any events that might have occurred.
+		//
+
+		flag = 0;
+		SiiMhlTxGetEvents( &event, &eventParameter );
+		if( MHL_TX_EVENT_NONE != event )
+		{
+			AppRcpDemo( event, eventParameter);
+		}
+
+    	if(mhl_cable_status == MHL_TV_OFF_CABLE_CONNECT)
+		{
+			byte tmp;
+    		tmp = I2C_ReadByte(SA_TX_Page0_Primary, (0x74));   // read status
+    		I2C_WriteByte(SA_TX_Page0_Primary, (0x74), tmp);   // clear all interrupts
+    		tmp = I2C_ReadByte(SA_TX_Page0_Primary, 0x71);
+    		I2C_WriteByte(SA_TX_Page0_Primary, 0x71, tmp);
+
+    		tmp = ReadByteCBUS(0x08);
+    		WriteByteCBUS(0x08, tmp);  
+
+    		tmp = ReadByteCBUS(0x1E);
+    		WriteByteCBUS(0x1E, tmp);    
+		TX_DEBUG_PRINT(("mhl_cable_status == MHL_TV_OFF_CABLE_CONNECT\n"));
+    		return ;
+
+    	}
+    	else if(((fwPowerState == TX_POWER_STATE_D0_MHL)||(fwPowerState == TX_POWER_STATE_D0_NO_MHL))&& 
+        mhl_cable_status) //NAGSM_Android_SEL_Kernel_Aakash_20101214
+      {
+
+          byte tmp;
+
+          tmp = I2C_ReadByte(SA_TX_Page0_Primary, (0x74));   // read status
+	        flag |= (tmp&INTR_4_DESIRED_MASK);	  
+          printk("#1 (0x74) flag: %x\n",(int) flag );
+
+          //I2C_WriteByte(SA_TX_Page0_Primary, (0x74), tmp);   // clear all interrupts
+
+          tmp = I2C_ReadByte(SA_TX_Page0_Primary, 0x71);
+          //I2C_WriteByte(SA_TX_Page0_Primary, 0x71, tmp);
+          flag |= (tmp&INTR_1_DESIRED_MASK);
+          printk("#1 (0x71) flag: %x\n",(int) flag );
+
+          if(mhlTxConfig.mhlConnected == MHL_TX_EVENT_DISCONNECTION)//(mhlTxConfig_status()== MHL_TX_EVENT_DISCONNECTION)//
+          {
+            tmp = ReadByteCBUS(0x08);
+            printk("#2 (ReadByteCBUS(0x08)) Temp: %x\n",(int) tmp );
+            WriteByteCBUS(0x08, tmp);  
+
+            tmp = ReadByteCBUS(0x1E);
+            printk("#2 (ReadByteCBUS(0x1E)) Temp: %x\n",(int) tmp );
+            WriteByteCBUS(0x1E, tmp);    
+
+          }
+          else
+          {
+			tmp = ReadByteCBUS(0x08);
+            flag |= (tmp&INTR_CBUS1_DESIRED_MASK);
+            printk("#1 (ReadByteCBUS(0x08)) Temp: %x\n",(int) flag );
+
+			tmp = ReadByteCBUS(0x1E);
+            flag |= (tmp&INTR_CBUS2_DESIRED_MASK);
+            printk("#1 (ReadByteCBUS(0x1E)) Temp: %x\n",(int) flag );              
+          }
+
+			if((flag == 0xFA)||(flag == 0xFF))
+
+				flag = 0;
+
+		}
+
+	}while(flag);
+
+	printk(KERN_ERR "[MHL]sii9234_interrupt_event :: flag: %x\n",(int) flag );
+}
+EXPORT_SYMBOL(sii9234_interrupt_event);
+
+
+/*===========================================================================
+  FUNCTION sii9234_unmaks_interrupt
+
+  DESCRIPTION
+  Unmask interrupt, we add this function to prevent interrupt before sii9234 power on
+
+  DEPENDENCIES
+  None
+
+  RETURN VALUE
+  None
+
+  SIDE EFFECTS
+  None
+  ===========================================================================*/
+void sii9234_unmaks_interrupt(void)
+{
+	UNMASK_INTR_4_INTERRUPTS;
+	UNMASK_INTR_1_INTERRUPTS;
+
+	return;
+}
+
diff -rupN kernel/drivers/media/video/samsung/mhl_v1/sii9234_driver.h news/kernel/drivers/media/video/samsung/mhl_v1/sii9234_driver.h
--- kernel/drivers/media/video/samsung/mhl_v1/sii9234_driver.h	2011-05-09 19:13:15.000000000 +0900
+++ news/kernel/drivers/media/video/samsung/mhl_v1/sii9234_driver.h	2011-06-17 19:41:22.000000000 +0900
@@ -1,44 +1,54 @@
-/*===========================================================================
-
-                        SiI9234_DRIVER.H
-
-
-DESCRIPTION
-  This file explains the SiI9234 initialization and call the virtual main function.
- 
-
- Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.
-  No part of this work may be reproduced, modified, distributed, transmitted,
- transcribed, or translated into any language or computer format, in any form
-or by any means without written permission of: Silicon Image, Inc.,
-1060 East Arques Avenue, Sunnyvale, California 94085
-===========================================================================*/
-
-
-/*===========================================================================
-
-                      EDIT HISTORY FOR FILE
-
-when              who                         what, where, why
---------        ---                        ----------------------------------------------------------
-2010/11/06    Daniel Lee(Philju)      Initial version of file, SIMG Korea
-===========================================================================*/
-
-/*===========================================================================
-                     INCLUDE FILES FOR MODULE
-===========================================================================*/
-
-
-/*===========================================================================
-                   FUNCTION DEFINITIONS
-===========================================================================*/
-
-
-void sii9234_interrupt_event(void);
-bool sii9234_init(void);
-
-void sii9234_unmaks_interrupt(void);
-
-//MHL IOCTL INTERFACE
-#define MHL_READ_RCP_DATA 0x1
-
+/***************************************************************************
+
+* 
+
+*   SiI9244 ? MHL Transmitter Driver
+
+*
+
+* Copyright (C) (2011, Silicon Image Inc)
+
+*
+
+* This program is free software; you can redistribute it and/or modify
+
+* it under the terms of the GNU General Public License as published by
+
+* the Free Software Foundation version 2.
+
+*
+
+* This program is distributed Â¡Â°as isÂ¡Â± WITHOUT ANY WARRANTY of any
+
+* kind, whether express or implied; without even the implied warranty
+
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+* GNU General Public License for more details.
+
+*
+
+*****************************************************************************/
+
+
+
+
+
+/*===========================================================================
+                     INCLUDE FILES FOR MODULE
+===========================================================================*/
+
+
+/*===========================================================================
+                   FUNCTION DEFINITIONS
+===========================================================================*/
+
+
+void sii9234_interrupt_event(void);
+bool sii9234_init(void);
+
+void sii9234_unmaks_interrupt(void);
+
+//MHL IOCTL INTERFACE
+#define MHL_READ_RCP_DATA 0x1
+
